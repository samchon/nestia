import { IEncryptionPassword } from "./IEncryptionPassword";
import { IRandomGenerator } from "./IRandomGenerator";

/**
 * Connection information.
 *
 * `IConnection` is an interface ttype who represents connection information of the
 * remote HTTP server. You can target the remote HTTP server by wring the
 * {@link IConnection.host} variable down. Also, you can configure special header values
 * by specializing the {@link IConnection.headers} variable.
 *
 * If the remote HTTP server encrypts or decrypts its body data through the AES-128/256
 * algorithm, specify the {@link IConnection.encryption} with {@link IEncryptionPassword}
 * or {@link IEncryptionPassword.Closure} variable.
 *
 * @author Jenogho Nam - https://github.com/samchon
 * @author Seungjun We - https://github.com/SeungjunWe
 */
export interface IConnection<Headers extends object = {}> {
    /**
     * Host address of the remote HTTP server.
     */
    host: string;

    /**
     * Header values delivered to the remote HTTP server.
     */
    headers?: Record<string, IConnection.HeaderValue> &
        IConnection.Headerify<Headers>;

    /**
     * Encryption password of its closure function.
     */
    encryption?: IEncryptionPassword | IEncryptionPassword.Closure;

    /**
     * Use simulation mode.
     *
     * If you configure this property to be `true` or assign an {@link IRandomGenerator}
     * instance, your SDK library does not send any request to remote backend server,
     * but just returns random data generated by `typia.random<T>()` function with
     * request data validation.
     *
     * By the way, to utilize this simulation mode, SDK library must be generated with
     * {@link INestiaConfig.simulate} option, too. Open `nestia.config.ts` file, and
     * configure {@link INestiaConfig.simulate} property to be `true`. Them, newly
     * generated SDK library would have a built-in mock-up data generator.
     *
     * @default false
     */
    simulate?: boolean | Partial<IRandomGenerator>;

    /**
     * Additional options for the `fetch` function.
     */
    options?: IConnection.IOptions;
}
export namespace IConnection {
    /**
     * Addiotional options for the `fetch` function.
     *
     * Almost same with {@link RequestInit} type of the {@link fetch} function,
     * but `body`, `headers` and `method` properties are omitted.
     *
     * The reason why defining duplicated definition of {@link RequestInit}
     * is for legacy NodeJS environments, which does not have the {@link fetch}
     * function type.
     */
    export interface IOptions {
        /**
         * A string indicating how the request will interact with the browser's
         * cache to set request's cache.
         */
        cache?:
            | "default"
            | "force-cache"
            | "no-cache"
            | "no-store"
            | "only-if-cached"
            | "reload";

        /**
         * A string indicating whether credentials will be sent with the request
         * always, never, or only when sent to a same-origin URL. Sets request's
         * credentials.
         */
        credentials?: "omit" | "same-origin" | "include";

        /**
         * A cryptographic hash of the resource to be fetched by request.
         *
         * Sets request's integrity.
         */
        integrity?: string;

        /**
         * A boolean to set request's keepalive.
         */
        keepalive?: boolean;

        /**
         * A string to indicate whether the request will use CORS, or will be
         * restricted to same-origin URLs.
         *
         * Sets request's mode.
         */
        mode?: "cors" | "navigate" | "no-cors" | "same-origin";

        /**
         * A string indicating whether request follows redirects, results in
         * an error upon encountering a redirect, or returns the redirect
         * (in an opaque fashion).
         *
         * Sets request's redirect.
         */
        redirect?: "error" | "follow" | "manual";

        /**
         * A string whose value is a same-origin URL, "about:client", or the
         * empty string, to set request's referrer.
         */
        referrer?: string;

        /**
         * A referrer policy to set request's referrerPolicy.
         */
        referrerPolicy?:
            | ""
            | "no-referrer"
            | "no-referrer-when-downgrade"
            | "origin"
            | "origin-when-cross-origin"
            | "same-origin"
            | "strict-origin"
            | "strict-origin-when-cross-origin"
            | "unsafe-url";
    }

    export type HeaderValue =
        | string
        | boolean
        | number
        | bigint
        | string
        | Array<boolean>
        | Array<number>
        | Array<bigint>
        | Array<number>
        | Array<string>;

    export type Headerify<T extends object> = {
        [P in keyof T]?: T[P] extends HeaderValue | undefined
            ? T[P] | undefined
            : never;
    };
}
