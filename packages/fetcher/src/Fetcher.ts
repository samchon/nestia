import import2 from "import2";

import { IConnection } from "./IConnection";
import { IEncryptionPassword } from "./IEncryptionPassword";
import { Primitive } from "./Primitive";

import { AesPkcs5 } from "./AesPkcs5";
import { HttpError } from "./HttpError";
import { Singleton } from "./internal/Singleton";

/**
 * Fetcher, utility class for the [**Nestia**](https://github.com/samchon/nestia) fetch.
 *
 * `Fetcher` is a utility class providing the {@link Fetcher.fetch} functions who're being
 * used by all of the SDK libraries, interacting with the remote HTTP servers, who are
 * generated by the [**Nestia**](https://github.com/samchon/nestia).
 *
 * As this `Fetcher` be used only by the [**Nestia**](https://github.com/samchon/nestia)
 * generated SDK libraries, you don't need to handle this class directly. It may only be
 * appeared in the source codes of the [**Nestia**](https://github.com/samchon/nestia)
 * generated SDK libraries.
 *
 * @author Jeongho Nam - https://github.com/samchon
 */
export class Fetcher {
    public static fetch(
        connection: IConnection,
        encrypted: Fetcher.IEncrypted,
        method: "HEAD",
        path: string,
    ): Promise<void>;

    /**
     * Fetch function for the `GET` methods.
     *
     * @param connection Connection information for the remote HTTP server
     * @param encrypted Whether the request/response body be encrypted or not
     * @param method Method of the HTTP request
     * @param path Path of the HTTP request
     * @return Response body data from the remote HTTP server
     */
    public static fetch<Output>(
        connection: IConnection,
        encrypted: Fetcher.IEncrypted,
        method: "GET",
        path: string,
    ): Promise<Primitive<Output>>;

    /**
     * Fetch function for the `POST`, `PUT`, `PATCH` and `DELETE` methods.
     *
     * @param connection Connection information for the remote HTTP server
     * @param encrypted Whether the request/response body be encrypted or not
     * @param method Method of the HTTP request
     * @param path Path of the HTTP request
     * @param input Request body data for the HTTP request
     * @param stringify JSON string conversion function, default is the `JSON.stringify`
     * @return Response body data from the remote HTTP server
     */
    public static fetch<Input, Output>(
        connection: IConnection,
        encrypted: Fetcher.IEncrypted,
        method: "POST" | "PUT" | "PATCH" | "DELETE",
        path: string,
        input?: Input,
        stringify?: (input: Input) => string,
    ): Promise<Primitive<Output>>;

    public static async fetch<Output>(
        connection: IConnection,
        encrypted: Fetcher.IEncrypted,
        method: "GET" | "DELETE" | "POST" | "PUT" | "PATCH" | "HEAD",
        path: string,
        input?: object,
        stringify?: (input: object) => string,
    ): Promise<Primitive<Output>> {
        if (encrypted.request === true || encrypted.response === true)
            if (connection.encryption === undefined)
                throw new Error(
                    "Error on nestia.Fetcher.encrypt(): the encryption password has not been configured.",
                );

        //----
        // REQUEST MESSSAGE
        //----
        // METHOD & HEADERS
        const headers: Record<string, IConnection.HeaderValue | undefined> = {
            ...(connection.headers ?? {}),
        };
        if (input !== undefined)
            headers["Content-Type"] ??=
                encrypted.request === true || typeof input === "string"
                    ? "text/plain"
                    : "application/json";

        const init: RequestInit = {
            ...(connection.options ?? {}),
            method,
            headers: (() => {
                const output: [string, string][] = [];
                for (const [key, value] of Object.entries(headers))
                    if (value === undefined) continue;
                    else if (Array.isArray(value))
                        for (const v of value) output.push([key, String(v)]);
                    else output.push([key, String(value)]);
                return output;
            })(),
        };

        // REQUEST BODY (WITH ENCRYPTION)
        if (input !== undefined)
            init.body = (() => {
                const json: string =
                    encrypted.request === true ||
                    headers["Content-Type"] !== "text/plain"
                        ? (stringify ?? JSON.stringify)(input)
                        : String(input);
                if (encrypted.request !== true) return json;

                const password:
                    | IEncryptionPassword
                    | IEncryptionPassword.Closure =
                    connection.encryption instanceof Function
                        ? connection.encryption!(
                              {
                                  headers: init.headers as Record<
                                      string,
                                      string
                                  >,
                                  body: json,
                              },
                              true,
                          )
                        : connection.encryption!;
                return AesPkcs5.encrypt(json, password.key, password.iv);
            })();

        //----
        // RESPONSE MESSAGE
        //----
        // URL SPECIFICATION
        if (
            connection.host[connection.host.length - 1] !== "/" &&
            path[0] !== "/"
        )
            path = "/" + path;

        const url: URL = new URL(`${connection.host}${path}`);

        // DO FETCH
        const response: Response = await (await polyfill.get())(url.href, init);
        const text: string = (await response.text()) ?? "";

        // CHECK THE STATUS CODE
        if (
            (encrypted.status !== undefined &&
                response.status !== encrypted.status) ||
            (encrypted.status === undefined &&
                response.status !== 200 &&
                response.status !== 201)
        )
            throw new HttpError(method, path, response.status, text);

        //----
        // OUTPUT
        //----
        // HEAD METHOD CANNOT HAVE ANYTHING
        if (method === "HEAD") return undefined!;

        // DECRYPT RESPONSE BODY
        const content: string = !encrypted.response
            ? text
            : (() => {
                  const password:
                      | IEncryptionPassword
                      | IEncryptionPassword.Closure =
                      connection.encryption instanceof Function
                          ? connection.encryption!(
                                {
                                    headers: headers_to_object(
                                        response.headers,
                                    ),
                                    body: text,
                                },
                                false,
                            )
                          : connection.encryption!;
                  return AesPkcs5.decrypt(text, password.key, password.iv);
              })();
        let ret: { __set_headers__: Record<string, any> } & Primitive<Output> =
            content as any;

        try {
            // PARSE RESPONSE BODY
            if (
                encrypted.response ||
                (response.headers.get("Content-Type") ?? "").indexOf(
                    "application/json",
                ) !== -1
            )
                ret = JSON.parse(ret as any);
        } catch {}

        // RETURNS
        return ret;
    }
}

export namespace Fetcher {
    /**
     * Whether be encrypted or not.
     *
     * `Fetcher.IEncrypted` is a type of interface who represents whether the HTTP request
     * and response body must be encrypted or not.
     *
     * Like the {@link Fetcher} who are being used by all of the SDK libraries that are
     * generated by the [Nestia](https://github.com/samchon/nestia), this `IEncrypted`
     * interface would be used by the [Nestia](https://github.com/samchon/nestia) generated
     * SDK libaries.
     *
     * As this `Fetcher` be used only by the [**Nestia**](https://github.com/samchon/nestia)
     * generated SDK libraries, you don't need to handle this class directly. It may only be
     * appeared in the source codes of the [**Nestia**](https://github.com/samchon/nestia)
     * generated SDK libraries.
     */
    export interface IEncrypted {
        /**
         * Whether the request body be encrypted or not.
         */
        request?: boolean;

        /**
         * Whether the response body be encrypted or not.
         */
        response: boolean;

        /**
         * When special status code is allowed.
         */
        status?: number;
    }
}

const polyfill = new Singleton(async (): Promise<typeof fetch> => {
    if (
        typeof global === "object" &&
        typeof global.process === "object" &&
        typeof global.process.versions === "object" &&
        typeof global.process.versions.node !== undefined
    ) {
        if (global.fetch === undefined)
            global.fetch = ((await import2("node-fetch")) as any).default;
        return (global as any).fetch;
    }
    return window.fetch;
});

function headers_to_object(headers: Headers): Record<string, string> {
    const output: Record<string, string> = {};
    headers.forEach((value, key) => (output[key] = value));
    return output;
}
