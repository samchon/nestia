import { OpenApi } from "@samchon/openapi";
import ts from "typescript";
import { IdentifierFactory } from "typia/lib/factories/IdentifierFactory";

import { IMigrateProgram } from "../structures/IMigrateProgram";
import { IMigrateRoute } from "../structures/IMigrateRoute";
import { FilePrinter } from "../utils/FilePrinter";
import { MigrateImportProgrammer } from "./MigrateImportProgrammer";
import { MigrateSchemaProgrammer } from "./MigrateSchemaProgrammer";

export namespace MigrateApiFunctionProgrammer {
  export const write =
    (config: IMigrateProgram.IConfig) =>
    (components: OpenApi.IComponents) =>
    (importer: MigrateImportProgrammer) =>
    (route: IMigrateRoute): ts.FunctionDeclaration =>
      FilePrinter.description(
        ts.factory.createFunctionDeclaration(
          [
            ts.factory.createModifier(ts.SyntaxKind.ExportKeyword),
            ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword),
          ],
          undefined,
          route.accessor.at(-1)!,
          undefined,
          writeParameterDeclarations(components)(importer)(route),
          ts.factory.createTypeReferenceNode("Promise", [
            ts.factory.createTypeReferenceNode(
              route.success === null
                ? "void"
                : `${route.accessor.at(-1)!}.Output`,
            ),
          ]),
          ts.factory.createBlock(writeBody(config)(importer)(route), true),
        ),
        writeDescription(route),
      );

  export const writeParameterDeclarations =
    (components: OpenApi.IComponents) =>
    (importer: MigrateImportProgrammer) =>
    (route: IMigrateRoute): ts.ParameterDeclaration[] => [
      IdentifierFactory.parameter(
        "connection",
        ts.factory.createTypeReferenceNode(
          importer.external({
            type: "instance",
            library: "@nestia/fetcher",
            name: "IConnection",
          }),
          route.headers
            ? [
                ts.factory.createTypeReferenceNode(
                  `${route.accessor.at(-1)!}.Headers`,
                ),
              ]
            : undefined,
        ),
      ),
      ...route.parameters.map((p) =>
        IdentifierFactory.parameter(
          p.key,
          MigrateSchemaProgrammer.write(components)(importer)(p.schema),
        ),
      ),
      ...(route.query
        ? [
            IdentifierFactory.parameter(
              route.query.key,
              ts.factory.createTypeReferenceNode(
                `${route.accessor.at(-1)!}.Query`,
              ),
            ),
          ]
        : []),
      ...(route.body
        ? [
            IdentifierFactory.parameter(
              route.body.key,
              ts.factory.createTypeReferenceNode(
                `${route.accessor.at(-1)!}.Input`,
              ),
            ),
          ]
        : []),
    ];

  const writeDescription = (route: IMigrateRoute): string =>
    [
      route.comment(),
      `@path ${route.emendedPath}`,
      "@nestia Generated by Nestia - https://github.com/samchon/nestia",
    ].join("\n");

  const writeBody =
    (config: IMigrateProgram.IConfig) =>
    (importer: MigrateImportProgrammer) =>
    (route: IMigrateRoute): ts.Statement[] => {
      const encrypted: boolean = !!route.success?.["x-nestia-encrypted"];
      const contentType: string = route.body?.type ?? "application/json";

      const caller = () =>
        ts.factory.createCallExpression(
          IdentifierFactory.access(
            ts.factory.createIdentifier(
              importer.external({
                type: "instance",
                library: `@nestia/fetcher/lib/${encrypted ? "EncryptedFetcher" : "PlainFetcher"}`,
                name: encrypted ? "EncryptedFetcher" : "PlainFetcher",
              }),
            ),
          )("fetch"),
          undefined,
          [
            contentType && contentType !== "multipart/form-data"
              ? ts.factory.createObjectLiteralExpression(
                  [
                    ts.factory.createSpreadAssignment(
                      ts.factory.createIdentifier("connection"),
                    ),
                    ts.factory.createPropertyAssignment(
                      "headers",
                      ts.factory.createObjectLiteralExpression(
                        [
                          ts.factory.createSpreadAssignment(
                            IdentifierFactory.access(
                              ts.factory.createIdentifier("connection"),
                            )("headers"),
                          ),
                          ts.factory.createPropertyAssignment(
                            ts.factory.createStringLiteral("Content-Type"),
                            ts.factory.createStringLiteral(contentType),
                          ),
                        ],
                        true,
                      ),
                    ),
                  ],
                  true,
                )
              : ts.factory.createIdentifier("connection"),
            ts.factory.createObjectLiteralExpression(
              [
                ts.factory.createSpreadAssignment(
                  IdentifierFactory.access(
                    ts.factory.createIdentifier(route.accessor.at(-1)!),
                  )("METADATA"),
                ),
                ts.factory.createPropertyAssignment(
                  "path",
                  ts.factory.createCallExpression(
                    IdentifierFactory.access(
                      ts.factory.createIdentifier(route.accessor.at(-1)!),
                    )("path"),
                    undefined,
                    [
                      ...route.parameters.map((p) =>
                        ts.factory.createIdentifier(p.key),
                      ),
                      ...(route.query
                        ? [ts.factory.createIdentifier(route.query.key)]
                        : []),
                    ],
                  ),
                ),
                ts.factory.createPropertyAssignment(
                  "status",
                  ts.factory.createNull(),
                ),
              ],
              true,
            ),
            ...(route.body
              ? [ts.factory.createIdentifier(route.body.key)]
              : []),
          ],
        );
      if (config.simulate !== true)
        return [ts.factory.createReturnStatement(caller())];
      return [
        ts.factory.createReturnStatement(
          ts.factory.createConditionalExpression(
            ts.factory.createIdentifier("!!connection.simulate"),
            undefined,
            ts.factory.createCallExpression(
              ts.factory.createIdentifier(`${route.accessor.at(-1)!}.simulate`),
              [],
              [
                "connection",
                ...route.parameters.map((p) => p.key),
                ...(route.query ? [route.query.key] : []),
                ...(route.body ? [route.body.key] : []),
              ].map((key) => ts.factory.createIdentifier(key)),
            ),
            undefined,
            caller(),
          ),
        ),
      ];
    };
}
