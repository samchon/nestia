{"/docs/core/TypedException":{"title":"Typedexception","data":{"outline#Outline":"export function TypedException<T extends object>(\r\n  status: number | \"2XX\" | \"3XX\" | \"4XX\" | \"5XX\",\r\n  description?: string,\r\n): MethodDecorator;\nException decorator only for swagger documents.TypedException is a decorator function describing HTTP exception and its type which could be occured in a controller method. For reference, this decorator function does not affect to the method's behavior, but affects to the swagger documents generation, or SDK functions when propagation mode being used.","how-to-use#How to use":"import { Controller } from \"@nestjs/common\";\r\nimport typia, { TypeGuardError } from \"typia\";\r\n\r\nimport {\r\n  TypedBody,\r\n  TypedException,\r\n  TypedParam,\r\n  TypedRoute,\r\n} from \"@nestia/core\";\r\n\r\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\r\nimport { IInternalServerError } from \"@api/lib/structures/IInternalServerError\";\r\nimport { INotFound } from \"@api/lib/structures/INotFound\";\r\nimport { IUnprocessibleEntity } from \"@api/lib/structures/IUnprocessibleEntity\";\r\n\r\n@Controller(\"exception\")\r\nexport class ExceptionController {\r\n  @TypedRoute.Post(\":section/typed\")\r\n  @TypedException<TypeGuardError>(400, \"invalid request\")\r\n  @TypedException<INotFound>(404, \"unable to find the matched section\")\r\n  @TypedException<IUnprocessibleEntity>(428)\r\n  @TypedException<IInternalServerError>(\"5XX\", \"internal server error\")\r\n  public async typed(\r\n    @TypedParam(\"section\") section: string,\r\n    @TypedBody() input: IBbsArticle.IStore,\r\n  ): Promise<IBbsArticle> {\r\n    section;\r\n    input;\r\n    return typia.random<IBbsArticle>();\r\n  }\r\n}\nJust call TypedException() function with target type and status code.If you want to add description, you can add it as second parameter.For reference, swagger allows to use special pattern like 2XX, 3XX, 4XX, 5XX for status code.","swagger-example#Swagger Example":"Here is an example of swagger documents utilizing the @TypedException() decorator.https://editor.swagger.io/?url=https%3A%2F%2Fraw.githubusercontent.com%2Fsamchon%2Fnestia%2Fmaster%2Ftest%2Ffeatures%2Fexception%2Fswagger.json"}},"/docs/core/TypedParam":{"title":"Typedparam","data":{"outline#Outline":"export function TypedParam(name: string): ParameterDecorator;\nType safe path parameter decorator.@TypedParam() is a decorator parsing path parameter.It's almost same with original @Param() function of NestJS, however, @TypedParam() is more type safe.As @TypedParam() can anlayze source code in the compilation level, it can specify parameter type by itself. Also, while NestJS cannot distinguish nullable type and consider every parameter value as a string type, @TypedParam() can do it. Furthermore, @TypedParam() can validate special types like \"uuid\" or \"date\".Let's read below example code, and see how @TypedParam() works.\n@TypedParam() is not essential for Swagger Documents or SDK Library building.Therefore, it is not a matter to use @TypedParam() or @Param() of the original NestJS.","how-to-use#How to use":"import { TypedParam } from \"@nestia/core\";\r\nimport { Controller, Get } from \"@nestjs/common\";\r\nimport { tags } from \"typia\";\r\n\r\n@Controller(\"parameters\")\r\nexport class ParametersController {\r\n  @Get(\"uint32/:value\")\r\n  public async uint32(\r\n    @TypedParam(\"value\") value: (number & tags.Type<\"uint32\">) | null,\r\n  ): Promise<(number & tags.Type<\"uint32\">) | null> {\r\n    return value;\r\n  }\r\n\r\n  @Get(\"string/:value\")\r\n  public async string(\r\n    @TypedParam(\"value\") value: string\r\n  ): Promise<string> {\r\n    return value;\r\n  }\r\n\r\n  @Get(\"uuid/:value\")\r\n  public async uuid(\r\n    @TypedParam(\"value\") value: string & tags.Format<\"uuid\">,\r\n  ): Promise<string> {\r\n    return value;\r\n  }\r\n}\n\"use strict\";\r\nvar __decorate =\r\n  (this && this.__decorate) ||\r\n  function (decorators, target, key, desc) {\r\n    var c = arguments.length,\r\n      r =\r\n        c < 3\r\n          ? target\r\n          : desc === null\r\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\r\n          : desc,\r\n      d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\r\n      r = Reflect.decorate(decorators, target, key, desc);\r\n    else\r\n      for (var i = decorators.length - 1; i >= 0; i--)\r\n        if ((d = decorators[i]))\r\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n  };\r\nvar __metadata =\r\n  (this && this.__metadata) ||\r\n  function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\r\n      return Reflect.metadata(k, v);\r\n  };\r\nvar __param =\r\n  (this && this.__param) ||\r\n  function (paramIndex, decorator) {\r\n    return function (target, key) {\r\n      decorator(target, key, paramIndex);\r\n    };\r\n  };\r\nvar __awaiter =\r\n  (this && this.__awaiter) ||\r\n  function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) {\r\n      return value instanceof P\r\n        ? value\r\n        : new P(function (resolve) {\r\n            resolve(value);\r\n          });\r\n    }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n      function fulfilled(value) {\r\n        try {\r\n          step(generator.next(value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function rejected(value) {\r\n        try {\r\n          step(generator[\"throw\"](value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function step(result) {\r\n        result.done\r\n          ? resolve(result.value)\r\n          : adopt(result.value).then(fulfilled, rejected);\r\n      }\r\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ParametersController = void 0;\r\nconst core_1 = require(\"@nestia/core\");\r\nconst common_1 = require(\"@nestjs/common\");\r\nlet ParametersController = class ParametersController {\r\n  uint32(value) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return value;\r\n    });\r\n  }\r\n  string(value) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return value;\r\n    });\r\n  }\r\n  uuid(value) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return value;\r\n    });\r\n  }\r\n};\r\nexports.ParametersController = ParametersController;\r\n__decorate(\r\n  [\r\n    (0, common_1.Get)(\"uint32/:value\"),\r\n    __param(\r\n      0,\r\n      (0, core_1.TypedParam)(\"value\", {\r\n        name: '((number & Type<\"uint32\">) | null)',\r\n        is: (input) => {\r\n          return (\r\n            null === input ||\r\n            (\"number\" === typeof input &&\r\n              Math.floor(input) === input &&\r\n              0 <= input &&\r\n              input <= 4294967295)\r\n          );\r\n        },\r\n        cast: (str) => (\"null\" === str ? null : Number(str)),\r\n      }),\r\n    ),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object]),\r\n    __metadata(\"design:returntype\", Promise),\r\n  ],\r\n  ParametersController.prototype,\r\n  \"uint32\",\r\n  null,\r\n);\r\n__decorate(\r\n  [\r\n    (0, common_1.Get)(\"string/:value\"),\r\n    __param(\r\n      0,\r\n      (0, core_1.TypedParam)(\"value\", {\r\n        name: \"string\",\r\n        is: (input) => {\r\n          return \"string\" === typeof input;\r\n        },\r\n        cast: (str) => str,\r\n      }),\r\n    ),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [String]),\r\n    __metadata(\"design:returntype\", Promise),\r\n  ],\r\n  ParametersController.prototype,\r\n  \"string\",\r\n  null,\r\n);\r\n__decorate(\r\n  [\r\n    (0, common_1.Get)(\"uuid/:value\"),\r\n    __param(\r\n      0,\r\n      (0, core_1.TypedParam)(\"value\", {\r\n        name: '(string & Format<\"uuid\">)',\r\n        is: (input) => {\r\n          return (\r\n            \"string\" === typeof input &&\r\n            /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n              input,\r\n            )\r\n          );\r\n        },\r\n        cast: (str) => str,\r\n      }),\r\n    ),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object]),\r\n    __metadata(\"design:returntype\", Promise),\r\n  ],\r\n  ParametersController.prototype,\r\n  \"uuid\",\r\n  null,\r\n);\r\nexports.ParametersController = ParametersController = __decorate(\r\n  [(0, common_1.Controller)(\"parameters\")],\r\n  ParametersController,\r\n);\nJust call @TypedParam() function on the path paremeter, that's all.If you want to special parameter type like \"uint32\" or \"uuid\", utilize type tags of typia.When wrong typed value comes, 400 bad request error would be thrown.","restriction#Restriction":"@TypedParam() allows only atomic type.\nboolean\nnumber\nstring\nbigint\nAlso, @TypedParam() allows nullable like number | null, but undefindable type is not.\nnumber | null is allowed\nstring | undefined is prohibited\nIf you violate above condition, and try to declare object or union type, compilation error would be occured:\nError on nestia.core.TypedParam(): only atomic type is allowed"}},"/docs/editor":{"title":"Editor","data":{"typescript-swagger-editor#TypeScript Swagger Editor":"Supports OpenAPI v3.0 only.\nPut your swagger.json file, then \"TypeScript Swagger Editor\" be opened.\n\"TypeScript Swagger Editor\" is a web-based TypeScript editor (of StackBlitz) for Swagger API specifications, with SDK (Software Development Kit) library generated by @nestia/migrate. With the cloud \"TypeScript Swagger Editor\", you can easily test the backend API with TypeScript code, and it is much convenient than the traditional way of using Swagger UI, due to type checking and auto-completion.Also, \"TypeScript Swagger Editor\" also provides Mockup Simulator. With the simulator, you can start frontend (or client) development even when the backend API is not ready yet. Furthermore, \"TypeScript Swagger Editor\" supports automatic e2e (end-to-end) test functions' generator, so that you can easily validate the API with the generated test code.Here are the some of example projects generated by \"TypeScript Swagger Editor\". Traveling those example projects, you may understand how to utilize the \"TypeScript Swagger Editor\" for your project. Let's start the type safe API development with \"TypeScript Swagger Editor\"!\nDemo Editors\nBBS (Bullet-in Board System)\nShopping Mall\nClickhouse\nFireblocks\n아임포트\n토스페이먼츠","how-to-use-in-local#How to use in local":"npm install -g @nestia/migrate\r\nnpx @nestia/migrate\r\n? Migration mode (Use arrow keys):\r\n  > NestJS\r\n    SDK\r\n? Swagger file location: assets/input/clickhouse.json\r\n? Output directory path: assets/output/clickhouse-sdk-manual\r\n? Mokup Simulator: true\r\n? E2E Test Functions: true\nRelated document: Nestia > Guide Documents > Migration from Swagger\nInstall @nestia/migrate globally, and run npx @nestia/migrate command in your terminal. The @nestia/migrate program will inquiry you something. After that, you can generate the SDK library in your local machine, what you've seen in the \"TypeScript Swagger Editor\".For reference, if your backend application utilizes nestia (NestJS), you don't need to build the SDK (Software Development Kit) library by converting from the Swagger Documents. The nestia will automatically generate the much advanced SDK library, just by analyzing your backend application's source code.","roadmap#Roadmap":"Currently, \"TypeScript Swagger Editor\" is utilizing the StackBlitz as the web-based TypeScript editor.However, if many developers agree with the usefulness of the SDK and are interested in \"TypeScript Swagger Editor,\" I am planning to develop a new standalone web application called @nestia/editor. It will take advantages of both \"Swagger-UI\" and \"TypeScript Swagger Editor\", and provide more convenient features for the API interaction development.I don't know how popular \"TypeScript Swagger Editor\" would be at this stage, but I hope that I can proceed with the @nestia/editor project as I have created something that front (client) developers desperately need.Let's nestia togather."}},"/docs":{"title":"Index","data":{"outline#Outline":"Nestia is a set of helper libraries for NestJS, supporting below features:\n@nestia/core: super-fast decorators\n@nestia/sdk:\nSwagger generator evolved than ever\nSDK library generator for clients\nMockup Simulator for client developers\nAutomatic E2E test functions generator\n@nestia/migrate: migration from Swagger to NestJS\n@nestia/editor: Online TypeScript Swagger Editor\nnestia: just CLI (command line interface) tool\nOnly one line required, with pure TypeScript type\nEnhance performance 30x up\nRuntime validator is 20,000x faster than class-validator\nJSON serialization is 200x faster than class-transformer\nSoftware Development Kit\nCollection of typed fetch functions with DTO structures like tRPC\nMockup simulator means embedded backend simulator in the SDK\nsimilar with msw, but fully automated\nLeft is NestJS server code, and right is client (frontend) code utilizing SDK","sponsors#Sponsors":"Thanks for your support.Your donation would encourage nestia development."}},"/docs/migrate":{"title":"Migration from Swagger","data":{"outline#Outline":"Supports OpenAPI v3.0 only.\n# SETUP GLOBALLY\r\nnpm install -g @nestia/migrate\r\n\r\n# DO MIGRATE\r\nnpx @nestia/migrate\n@nestia/migrate converts swagger.json file to:\nNestJS Project\nStandalone SDK Library\nStandalone Mockup Simulator\nWhen you run npx @nestia/migrate command, @nestia/migrate will analyze your swagger.json file, and generate a NestJS project into the output direcory. If you're considering to migrate your backend project to NestJS, @nestia/migrate will be a good starting point.Of course, even if you're not considering to adapt NestJS, you can generate standalone SDK library and Mockup Simulator from the swagger.json file instead. Just run the npx @nestia/migrate command and build the SDK library and Mockup Simulator, then frontend (client) developers may get satisfied.\nLeft is NestJS server code, and right is client (frontend) code utilizing SDK","arguments#Arguments":"# GRAMMER\r\nnpx @nestia/migrate \r\n  --mode [nest|sdk] \r\n  --input [input] \r\n  --output [output] \r\n  --simulate [true|false]\r\n  --e2e [true|false]\r\n\r\n# EXAMPLES\r\nnpx @nestia/migrate --mode nest --input swagger.json --output directory --simulate false --e2e false\r\nnpx @nestia/migrate --mode sdk --input swagger.json --output directory --simulate true --e2e true\nYou can specify migration options like above.However, don't worry anything. If you omit something, prompt inquiries will help you.\nnpm install -g @nestia/migrate\r\nnpx @nestia/migrate\r\n? Migration mode (Use arrow keys):\r\n  > NestJS\r\n    SDK\r\n? Swagger file location: assets/input/clickhouse.json\r\n? Output directory path: assets/output/clickhouse-sdk-manual\r\n? Mokup Simulator: true\r\n? E2E Test Functions: true","cloud-editor#Cloud Editor":"You can test @nestia/migrate on the web browser only for the SDK mode.Visit TypeScript Swagger Editor and upload your swagger.json file.Then, you can test the generated SDK library and Mockup Simulator in the web browser.\nSupports OpenAPI v3.0 only.\nPut your swagger.json file, then \"TypeScript Swagger Editor\" be opened.\nDemo Editors\nBBS (Bullet-in Board System)\nShopping Mall\nClickhouse\nFireblocks\n아임포트\n토스페이먼츠"}},"/":{"title":"Index","data":{"key-features#Key Features":"","sponsors#Sponsors":"Thanks for your support.Your donation would encourage nestia development."}},"/playground":{"title":"Index","data":{}},"/docs/core/TypedBody":{"title":"Typedbody","data":{"outline#Outline":"export function TypedBody(): ParameterDecorator;\nRequest body decorator 20,000x faster, even easy to use.@TypedBody() is a decorator function parsing application/json typed request body, and validates the request body value type through typia.assert<T>() function. If the request body is not following the promised type, 400 bad request error would be thrown.It is almost same with original @Body() function of NestJS, however, 20,000x faster.Also, @TypedBody() is much more easier to use than class-validator, because it can use pure TypeScript type. If you can't understand the word \"pure TypeScript type\", then move to below #How to use section and read the IBbsArticle.IUpdate interface type. You may understand what it means.\nIf you want other Content-Type, use one of below:\napplication/x-www-form-urlencoded: @TypedQuery.Body().\nmultipart/form-data: @TypedFormData.Body()\n@TypedBody() is not essential for Swagger Documents or SDK Library building.Therefore, it is not a matter to use @TypedBody() or @Body() of the original NestJS.","how-to-use#How to use":"import { tags } from \"typia\";\r\n\r\nexport interface IBbsArticle extends IBbsArticle.IStore {\r\n  id: string & tags.Format<\"uuid\">;\r\n  created_at: string & tags.Format<\"date-time\">;\r\n}\r\nexport namespace IBbsArticle {\r\n  export interface IStore {\r\n    title: string & tags.MinLength<3> & tags.MaxLength<50>;\r\n    body: string;\r\n    files: IAttachmentFile[];\r\n  }\r\n}\nimport { tags } from \"typia\";\r\n\r\nexport interface IAttachmentFile {\r\n  name: null | (string & tags.MinLength<1> & tags.MaxLength<255>);\r\n  extension: null | (string & tags.MinLength<1> & tags.MaxLength<8>);\r\n  url: string & tags.Format<\"url\">;\r\n}\nimport { TypedBody, TypedRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport { tags } from \"typia\";\r\n\r\nimport { IBbsArticle } from \"./IBbsArticle\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  @TypedRoute.Post()\r\n  public async store(\r\n    @TypedBody() input: IBbsArticle.IStore,\r\n  ): Promise<IBbsArticle> {\r\n    return {\r\n      ...input,\r\n      id: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\r\n      created_at: \"2023-04-23T12:04:54.168Z\",\r\n    };\r\n  }\r\n}\n\"use strict\";\r\nvar __decorate =\r\n  (this && this.__decorate) ||\r\n  function (decorators, target, key, desc) {\r\n    var c = arguments.length,\r\n      r =\r\n        c < 3\r\n          ? target\r\n          : desc === null\r\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\r\n          : desc,\r\n      d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\r\n      r = Reflect.decorate(decorators, target, key, desc);\r\n    else\r\n      for (var i = decorators.length - 1; i >= 0; i--)\r\n        if ((d = decorators[i]))\r\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n  };\r\nvar __metadata =\r\n  (this && this.__metadata) ||\r\n  function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\r\n      return Reflect.metadata(k, v);\r\n  };\r\nvar __param =\r\n  (this && this.__param) ||\r\n  function (paramIndex, decorator) {\r\n    return function (target, key) {\r\n      decorator(target, key, paramIndex);\r\n    };\r\n  };\r\nvar __awaiter =\r\n  (this && this.__awaiter) ||\r\n  function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) {\r\n      return value instanceof P\r\n        ? value\r\n        : new P(function (resolve) {\r\n            resolve(value);\r\n          });\r\n    }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n      function fulfilled(value) {\r\n        try {\r\n          step(generator.next(value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function rejected(value) {\r\n        try {\r\n          step(generator[\"throw\"](value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function step(result) {\r\n        result.done\r\n          ? resolve(result.value)\r\n          : adopt(result.value).then(fulfilled, rejected);\r\n      }\r\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BbsArticlesController = void 0;\r\nconst core_1 = require(\"@nestia/core\");\r\nconst common_1 = require(\"@nestjs/common\");\r\nlet BbsArticlesController = class BbsArticlesController {\r\n  store(input) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return Object.assign(Object.assign({}, input), {\r\n        id: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\r\n        created_at: \"2023-04-23T12:04:54.168Z\",\r\n      });\r\n    });\r\n  }\r\n};\r\nexports.BbsArticlesController = BbsArticlesController;\r\n__decorate(\r\n  [\r\n    core_1.TypedRoute.Post({\r\n      type: \"assert\",\r\n      assert: (input) => {\r\n        const assert = (input) => {\r\n          const __is = (input) => {\r\n            const $io0 = (input) =>\r\n              \"string\" === typeof input.id &&\r\n              /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n                input.id,\r\n              ) &&\r\n              \"string\" === typeof input.created_at &&\r\n              !isNaN(new Date(input.created_at).getTime()) &&\r\n              \"string\" === typeof input.title &&\r\n              3 <= input.title.length &&\r\n              input.title.length <= 50 &&\r\n              \"string\" === typeof input.body &&\r\n              Array.isArray(input.files) &&\r\n              input.files.every(\r\n                (elem) =>\r\n                  \"object\" === typeof elem && null !== elem && $io1(elem),\r\n              );\r\n            const $io1 = (input) =>\r\n              (null === input.name ||\r\n                (\"string\" === typeof input.name &&\r\n                  1 <= input.name.length &&\r\n                  input.name.length <= 255)) &&\r\n              (null === input.extension ||\r\n                (\"string\" === typeof input.extension &&\r\n                  1 <= input.extension.length &&\r\n                  input.extension.length <= 8)) &&\r\n              \"string\" === typeof input.url &&\r\n              /^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(\r\n                input.url,\r\n              );\r\n            return \"object\" === typeof input && null !== input && $io0(input);\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.TypedRoute.Post.guard;\r\n              const $ao0 = (input, _path, _exceptionable = true) =>\r\n                ((\"string\" === typeof input.id &&\r\n                  (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n                    input.id,\r\n                  ) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".id\",\r\n                      expected: 'string & Format<\"uuid\">',\r\n                      value: input.id,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".id\",\r\n                    expected: '(string & Format<\"uuid\">)',\r\n                    value: input.id,\r\n                  })) &&\r\n                ((\"string\" === typeof input.created_at &&\r\n                  (!isNaN(new Date(input.created_at).getTime()) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".created_at\",\r\n                      expected: 'string & Format<\"date-time\">',\r\n                      value: input.created_at,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".created_at\",\r\n                    expected: '(string & Format<\"date-time\">)',\r\n                    value: input.created_at,\r\n                  })) &&\r\n                ((\"string\" === typeof input.title &&\r\n                  (3 <= input.title.length ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MinLength<3>\",\r\n                      value: input.title,\r\n                    })) &&\r\n                  (input.title.length <= 50 ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MaxLength<50>\",\r\n                      value: input.title,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".title\",\r\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\r\n                    value: input.title,\r\n                  })) &&\r\n                (\"string\" === typeof input.body ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".body\",\r\n                    expected: \"string\",\r\n                    value: input.body,\r\n                  })) &&\r\n                (((Array.isArray(input.files) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files\",\r\n                    expected: \"Array<IAttachmentFile>\",\r\n                    value: input.files,\r\n                  })) &&\r\n                  input.files.every(\r\n                    (elem, _index1) =>\r\n                      (((\"object\" === typeof elem && null !== elem) ||\r\n                        $guard(_exceptionable, {\r\n                          path: _path + \".files[\" + _index1 + \"]\",\r\n                          expected: \"IAttachmentFile\",\r\n                          value: elem,\r\n                        })) &&\r\n                        $ao1(\r\n                          elem,\r\n                          _path + \".files[\" + _index1 + \"]\",\r\n                          true && _exceptionable,\r\n                        )) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".files[\" + _index1 + \"]\",\r\n                        expected: \"IAttachmentFile\",\r\n                        value: elem,\r\n                      }),\r\n                  )) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files\",\r\n                    expected: \"Array<IAttachmentFile>\",\r\n                    value: input.files,\r\n                  }));\r\n              const $ao1 = (input, _path, _exceptionable = true) =>\r\n                (null === input.name ||\r\n                  (\"string\" === typeof input.name &&\r\n                    (1 <= input.name.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".name\",\r\n                        expected: \"string & MinLength<1>\",\r\n                        value: input.name,\r\n                      })) &&\r\n                    (input.name.length <= 255 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".name\",\r\n                        expected: \"string & MaxLength<255>\",\r\n                        value: input.name,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".name\",\r\n                    expected:\r\n                      \"((string & MinLength<1> & MaxLength<255>) | null)\",\r\n                    value: input.name,\r\n                  })) &&\r\n                (null === input.extension ||\r\n                  (\"string\" === typeof input.extension &&\r\n                    (1 <= input.extension.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".extension\",\r\n                        expected: \"string & MinLength<1>\",\r\n                        value: input.extension,\r\n                      })) &&\r\n                    (input.extension.length <= 8 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".extension\",\r\n                        expected: \"string & MaxLength<8>\",\r\n                        value: input.extension,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".extension\",\r\n                    expected: \"((string & MinLength<1> & MaxLength<8>) | null)\",\r\n                    value: input.extension,\r\n                  })) &&\r\n                ((\"string\" === typeof input.url &&\r\n                  (/^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(\r\n                    input.url,\r\n                  ) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".url\",\r\n                      expected: 'string & Format<\"url\">',\r\n                      value: input.url,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".url\",\r\n                    expected: '(string & Format<\"url\">)',\r\n                    value: input.url,\r\n                  }));\r\n              return (\r\n                (((\"object\" === typeof input && null !== input) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IBbsArticle\",\r\n                    value: input,\r\n                  })) &&\r\n                  $ao0(input, _path + \"\", true)) ||\r\n                $guard(true, {\r\n                  path: _path + \"\",\r\n                  expected: \"IBbsArticle\",\r\n                  value: input,\r\n                })\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        };\r\n        const stringify = (input) => {\r\n          const $io1 = (input) =>\r\n            (null === input.name ||\r\n              (\"string\" === typeof input.name &&\r\n                1 <= input.name.length &&\r\n                input.name.length <= 255)) &&\r\n            (null === input.extension ||\r\n              (\"string\" === typeof input.extension &&\r\n                1 <= input.extension.length &&\r\n                input.extension.length <= 8)) &&\r\n            \"string\" === typeof input.url &&\r\n            /^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(\r\n              input.url,\r\n            );\r\n          const $string = core_1.TypedRoute.Post.string;\r\n          const $so0 = (input) =>\r\n            `{\"id\":${$string(input.id)},\"created_at\":${$string(\r\n              input.created_at,\r\n            )},\"title\":${$string(input.title)},\"body\":${$string(\r\n              input.body,\r\n            )},\"files\":${`[${input.files\r\n              .map((elem) => $so1(elem))\r\n              .join(\",\")}]`}}`;\r\n          const $so1 = (input) =>\r\n            `{\"name\":${\r\n              null !== input.name ? $string(input.name) : \"null\"\r\n            },\"extension\":${\r\n              null !== input.extension ? $string(input.extension) : \"null\"\r\n            },\"url\":${$string(input.url)}}`;\r\n          return $so0(input);\r\n        };\r\n        return stringify(assert(input));\r\n      },\r\n    }),\r\n    __param(\r\n      0,\r\n      (0, core_1.TypedBody)({\r\n        type: \"assert\",\r\n        assert: (input) => {\r\n          const __is = (input) => {\r\n            const $io0 = (input) =>\r\n              \"string\" === typeof input.title &&\r\n              3 <= input.title.length &&\r\n              input.title.length <= 50 &&\r\n              \"string\" === typeof input.body &&\r\n              Array.isArray(input.files) &&\r\n              input.files.every(\r\n                (elem) =>\r\n                  \"object\" === typeof elem && null !== elem && $io1(elem),\r\n              );\r\n            const $io1 = (input) =>\r\n              (null === input.name ||\r\n                (\"string\" === typeof input.name &&\r\n                  1 <= input.name.length &&\r\n                  input.name.length <= 255)) &&\r\n              (null === input.extension ||\r\n                (\"string\" === typeof input.extension &&\r\n                  1 <= input.extension.length &&\r\n                  input.extension.length <= 8)) &&\r\n              \"string\" === typeof input.url &&\r\n              /^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(\r\n                input.url,\r\n              );\r\n            return \"object\" === typeof input && null !== input && $io0(input);\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.TypedBody.guard;\r\n              const $ao0 = (input, _path, _exceptionable = true) =>\r\n                ((\"string\" === typeof input.title &&\r\n                  (3 <= input.title.length ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MinLength<3>\",\r\n                      value: input.title,\r\n                    })) &&\r\n                  (input.title.length <= 50 ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MaxLength<50>\",\r\n                      value: input.title,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".title\",\r\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\r\n                    value: input.title,\r\n                  })) &&\r\n                (\"string\" === typeof input.body ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".body\",\r\n                    expected: \"string\",\r\n                    value: input.body,\r\n                  })) &&\r\n                (((Array.isArray(input.files) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files\",\r\n                    expected: \"Array<IAttachmentFile>\",\r\n                    value: input.files,\r\n                  })) &&\r\n                  input.files.every(\r\n                    (elem, _index1) =>\r\n                      (((\"object\" === typeof elem && null !== elem) ||\r\n                        $guard(_exceptionable, {\r\n                          path: _path + \".files[\" + _index1 + \"]\",\r\n                          expected: \"IAttachmentFile\",\r\n                          value: elem,\r\n                        })) &&\r\n                        $ao1(\r\n                          elem,\r\n                          _path + \".files[\" + _index1 + \"]\",\r\n                          true && _exceptionable,\r\n                        )) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".files[\" + _index1 + \"]\",\r\n                        expected: \"IAttachmentFile\",\r\n                        value: elem,\r\n                      }),\r\n                  )) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files\",\r\n                    expected: \"Array<IAttachmentFile>\",\r\n                    value: input.files,\r\n                  }));\r\n              const $ao1 = (input, _path, _exceptionable = true) =>\r\n                (null === input.name ||\r\n                  (\"string\" === typeof input.name &&\r\n                    (1 <= input.name.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".name\",\r\n                        expected: \"string & MinLength<1>\",\r\n                        value: input.name,\r\n                      })) &&\r\n                    (input.name.length <= 255 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".name\",\r\n                        expected: \"string & MaxLength<255>\",\r\n                        value: input.name,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".name\",\r\n                    expected:\r\n                      \"((string & MinLength<1> & MaxLength<255>) | null)\",\r\n                    value: input.name,\r\n                  })) &&\r\n                (null === input.extension ||\r\n                  (\"string\" === typeof input.extension &&\r\n                    (1 <= input.extension.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".extension\",\r\n                        expected: \"string & MinLength<1>\",\r\n                        value: input.extension,\r\n                      })) &&\r\n                    (input.extension.length <= 8 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".extension\",\r\n                        expected: \"string & MaxLength<8>\",\r\n                        value: input.extension,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".extension\",\r\n                    expected: \"((string & MinLength<1> & MaxLength<8>) | null)\",\r\n                    value: input.extension,\r\n                  })) &&\r\n                ((\"string\" === typeof input.url &&\r\n                  (/^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(\r\n                    input.url,\r\n                  ) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".url\",\r\n                      expected: 'string & Format<\"url\">',\r\n                      value: input.url,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".url\",\r\n                    expected: '(string & Format<\"url\">)',\r\n                    value: input.url,\r\n                  }));\r\n              return (\r\n                (((\"object\" === typeof input && null !== input) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IBbsArticle.IStore\",\r\n                    value: input,\r\n                  })) &&\r\n                  $ao0(input, _path + \"\", true)) ||\r\n                $guard(true, {\r\n                  path: _path + \"\",\r\n                  expected: \"IBbsArticle.IStore\",\r\n                  value: input,\r\n                })\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        },\r\n      }),\r\n    ),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object]),\r\n    __metadata(\"design:returntype\", Promise),\r\n  ],\r\n  BbsArticlesController.prototype,\r\n  \"store\",\r\n  null,\r\n);\r\nexports.BbsArticlesController = BbsArticlesController = __decorate(\r\n  [(0, common_1.Controller)(\"bbs/articles\")],\r\n  BbsArticlesController,\r\n);\nJust call @TypedBody() function on the request body parameter, that's all.Nestia will analyze your type (IBbsArticle.IUpdate), and writes optimal code for the target type, in the compilation level. If you click the \"Complied JavaScript File\" tab of above, you can see the optimal validation code.Such optimization is called AOT (Ahead of Time) compilation, and it is the secret of @TypedBody.","special-tags#Special Tags":"You can enhance validation logic, of @TypedBody(), through special tags.You know what? @TypedBody() utilizes typia.assert<T>() function for request body data validation, and the typia.assert<T>() function supports additional type checking logics through type and comment tags. For reference, \"Type Tag\" means a intersection type with atomic type and special tag type of typia like number & tags.Type<\"uint32\">, and \"Comment Tag\" means a comment starting from @ symbol following @${name} ${value} format.With those type and comment tags, you can add additional validation logics. If you want to add a custom validation logic, you also can do it. Read below Guide Docments of typia, and see the example code. You may understand how to utilize such type and comment tags, in a few minutes.\ntypia > Validators > Custom Tags\nOutline\nType Tags\nComment Tags\nCustomization\nimport typia, { tags } from \"typia\";\r\n\r\nexport const checkSpecialTag = typia.createIs<SpecialTag>();\r\n\r\ninterface SpecialTag {\r\n  int32: number & tags.Type<\"int32\">;\r\n  range?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\r\n  minLength: string & tags.MinLength<3>;\r\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\r\n  date: null | (string & tags.Format<\"date\">);\r\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\r\n  uuids: Array<string & tags.Format<\"uuid\">> &\r\n    tags.MinItems<3> &\r\n    tags.MaxItems<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.checkSpecialTag = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst checkSpecialTag = (input) => {\r\n  const $io0 = (input) =>\r\n    \"number\" === typeof input.int32 &&\r\n    Math.floor(input.int32) === input.int32 &&\r\n    -2147483648 <= input.int32 &&\r\n    input.int32 <= 2147483647 &&\r\n    (undefined === input.range ||\r\n      (\"number\" === typeof input.range &&\r\n        19 < input.range &&\r\n        input.range <= 100)) &&\r\n    \"string\" === typeof input.minLength &&\r\n    3 <= input.minLength.length &&\r\n    \"string\" === typeof input.pattern &&\r\n    /^[a-z]+$/.test(input.pattern) &&\r\n    (null === input.date ||\r\n      (\"string\" === typeof input.date &&\r\n        /^(d{4})-(d{2})-(d{2})$/.test(input.date))) &&\r\n    \"string\" === typeof input.ip &&\r\n    (/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\r\n      input.ip,\r\n    ) ||\r\n      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(\r\n        input.ip,\r\n      )) &&\r\n    Array.isArray(input.uuids) &&\r\n    3 <= input.uuids.length &&\r\n    input.uuids.length <= 100 &&\r\n    input.uuids.every(\r\n      (elem) =>\r\n        \"string\" === typeof elem &&\r\n        /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n          elem,\r\n        ),\r\n    );\r\n  return \"object\" === typeof input && null !== input && $io0(input);\r\n};\r\nexports.checkSpecialTag = checkSpecialTag;","configuration#Configuration":"{\r\n  \"strict\": true,\r\n  \"strictNullChecks\": true,\r\n  \"compilerOptions\": {\r\n    \"plugins\": [\r\n      { \"transform\": \"typia/lib/transform\" },\r\n      { \r\n        \"transform\": \"@nestia/core/lib/transform\",\r\n        \"validate\": \"valiateEquals\",\r\n        \"stringify\": \"assert\", \r\n      },\r\n    ],\r\n  },\r\n}\nChange type validation function to other one.If you configure validate property of plugin defined in the tsconfig.json file, you can change the @TypedBody() to use another validation function instead of using the default typia.assert<T> function. For example, if you want to use typia.validateEquals<T>() function instead, then set the validate property to validateEquals.Below is the list of available validation functions.\nis or equals: check validation only, and do not reveal the reason why\nassert or assertEquals: find the 1st type error with reason\nvalidate or validateEquals: find every type errors with detailed reasons\nassertPrune or validatePrune: prune extra properties with type checking\nassertClone or validateClone: deep clone with type checking for faster pruning","encryptedbody#EncryptedBody":"Encrypted request body decorator function.@EncryptedBody() is a decorator function similar with @TypedBody(), but it encrypts the request body through AES-128/256-CBC algorithm like below. Therefore, it would be slower than @TypedBody(), but it guarantees the security of request body data.\nAES-128/256\nCBC mode\nPKCS #5 Padding\nBase64 Encoding\nFor reference, such encryption spec is not supported in the Swagger-UI. Instead, SDK (Software Development Kit) generated by @nestia/sdk supports it. Thus, you have to build and distribute the SDK library to the client developers when using such encryption decorators.","benchmark#Benchmark":"Super-fast and super-safe.Nestia utilizes typia, and NestJS uses class-validator. One thing amazing is, typia is maximum 20,000x faster than class-validator of NestJS. Color of class-transformer is skyblue, and can you find the skyblue color in the below benchmark graph? It may hard to find because class-validator is extremely slow.\nMeasured on Intel i5-1135g7, Surface Pro 8\nFurthermore, while other libraries can't validate complicate union types, typia can validate every TypeScript types. However, in the class-validator case, it always be failed when any type of complicate comes. I can't understand why NestJS has adopted such slow and unstable library.Moreover, only typia can utilize pure TypeScript type, without any extra schema definition. Beside, all of other libraries require extra and duplicated schema definition, different with pure TypeScript type. Nestia is using such wonderful, super-fast and super-fast typia library.\nTypeBox requires TypeBox schema\najv requires JSON schema definition\nio-ts requires io-ts schema\nzod requires zod schema\nclass-validator requires DTO class with decorator function calls\nComponents\ttypia\tTypeBox\tajv\tio-ts\tzod\tC.V.\tEasy to use\t✅\t❌\t❌\t❌\t❌\t❌\tObject (simple)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (recursive)\t✔\t❌\t✔\t✔\t✔\t✔\t✔\tObject (union, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tObject (union, explicit)\t✔\t✔\t✔\t✔\t✔\t❌\tObject (additional tags)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (template literal types)\t✔\t✔\t✔\t❌\t❌\t❌\tObject (dynamic properties)\t✔\t✔\t✔\t❌\t❌\t❌\tArray (rest tuple)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tArray (recursive)\t✔\t✔\t✔\t✔\t✔\t❌\tArray (recursive, union)\t✔\t✔\t❌\t✔\t✔\t❌\tArray (R+U, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tUltimate Union Type\t✅\t❌\t❌\t❌\t❌\t❌\t\nC.V. means class-validator"}},"/docs/core/TypedFormData":{"title":"Typedformdata","data":{"outline#Outline":"export namespace TypedFormData {\r\n  export function Body(): ParameterDecorator;\r\n}\nRequest body decorator of multipart/form-data.@TypedFormData.Body() is a request body decorator function, for the multipart/form-data content type. It is useful for file uploading with additional data, and automatically casts property type following its DTO definition, performing the type validation.As you can see from the below code, @TypedFormData.Body() function is much easier and type safer than @UploadFile() of NestJS. Also, if you're considering the SDK library generation, only @TypedFormData.Body() is supported. Therefore, I recommend you to utilize @TypedFormData.Body() instead of the @UploadFile() function.Of course, as every features of nestia does, you don't need to define any extra schema definition for the Swagger Documents generation. @nestia/sdk and @TypedFormData.Body() will do everything just by analyzing your TypeScript types and codes.\nimport { TypedFormData, TypedRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  @TypedRoute.Post()\r\n  public async create(\r\n    @TypedFormData.Body() input: IBbsArticleCreate,\r\n  ): Promise<void> {\r\n    input;\r\n  }\r\n}\r\n\r\nexport interface IBbsArticleCreate {\r\n  title: string;\r\n  body: string | null;\r\n  thumbnail?: File | undefined;\r\n  files: File[];\r\n  tags: string[];\r\n}\nimport { \r\n  Body, \r\n  Controller, \r\n  Post, \r\n  UploadedFile, \r\n  UploadedFiles, \r\n  UseInterceptors \r\n} from \"@nestjs/common\";\r\nimport { ApiBody, ApiConsumes } from \"@nestjs/swagger\";\r\nimport { FileFieldsInterceptor } from \"@nestjs/platform-express\";\r\nimport { IsArray, IsOptional, IsString } from \"class-validator\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  @Post()\r\n  @ApiConsumes(\"multipart/form-data\")\r\n  @UseInterceptors(\r\n    FileFieldsInterceptor([\r\n      { name: \"thumbnail\", maxCount: 1 },\r\n      { name: \"files\" },\r\n    ]),\r\n  )\r\n  @ApiBody({\r\n    schema: {\r\n      type: \"object\",\r\n      properties: {\r\n        title: {\r\n          type: \"string\",\r\n        },\r\n        body: {\r\n          type: \"string\",\r\n          nullable: true,\r\n        },\r\n        thumbnail: {\r\n          type: \"string\",\r\n          format: \"binary\",\r\n        },\r\n        files: {\r\n          type: \"array\",\r\n          items: {\r\n            type: \"string\",\r\n            format: \"binary\",\r\n          },\r\n        },\r\n      },\r\n      required: [\r\n        \"id\", \r\n        \"title\", \r\n        \"body\", \r\n        \"files\",\r\n        \"tags\",\r\n        \"created_at\",\r\n      ],\r\n    },\r\n  })\r\n  public async create(\r\n    @Body() input: BbsArticleCreateDto,\r\n    @UploadedFiles() binary: {\r\n      thumbnail?: Express.Multer.File[];\r\n      files: Express.Multer.File[];\r\n    },\r\n  ): Promise<void> {\r\n    input;\r\n    binary;\r\n  }\r\n}\r\n\r\nexport class BbsArticleCreateDto {\r\n  @IsString()\r\n  title: string;\r\n\r\n  @IsString()\r\n  @IsOptional()\r\n  body: string | null;\r\n\r\n  @IsArray({ each: true })\r\n  @IsString()\r\n  tags: string[];\r\n}","how-to-use#How to use":"export interface IBbsArticleCreate {\r\n  title: string;\r\n  body: string | null;\r\n  thumbnail?: File | undefined;\r\n  files: File[];\r\n  tags: string[];\r\n}\nimport { TypedFormData, TypedRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\n\r\nimport { IBbsArticleCreate } from \"./IBbsArticleCreate\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  @TypedRoute.Post()\r\n  public async create(\r\n    @TypedFormData.Body() input: IBbsArticleCreate,\r\n  ): Promise<void> {\r\n    input;\r\n  }\r\n}\n\"use strict\";\r\nvar __decorate =\r\n  (this && this.__decorate) ||\r\n  function (decorators, target, key, desc) {\r\n    var c = arguments.length,\r\n      r =\r\n        c < 3\r\n          ? target\r\n          : desc === null\r\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\r\n          : desc,\r\n      d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\r\n      r = Reflect.decorate(decorators, target, key, desc);\r\n    else\r\n      for (var i = decorators.length - 1; i >= 0; i--)\r\n        if ((d = decorators[i]))\r\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n  };\r\nvar __metadata =\r\n  (this && this.__metadata) ||\r\n  function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\r\n      return Reflect.metadata(k, v);\r\n  };\r\nvar __param =\r\n  (this && this.__param) ||\r\n  function (paramIndex, decorator) {\r\n    return function (target, key) {\r\n      decorator(target, key, paramIndex);\r\n    };\r\n  };\r\nvar __awaiter =\r\n  (this && this.__awaiter) ||\r\n  function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) {\r\n      return value instanceof P\r\n        ? value\r\n        : new P(function (resolve) {\r\n            resolve(value);\r\n          });\r\n    }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n      function fulfilled(value) {\r\n        try {\r\n          step(generator.next(value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function rejected(value) {\r\n        try {\r\n          step(generator[\"throw\"](value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function step(result) {\r\n        result.done\r\n          ? resolve(result.value)\r\n          : adopt(result.value).then(fulfilled, rejected);\r\n      }\r\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BbsArticlesController = void 0;\r\nconst core_1 = require(\"@nestia/core\");\r\nconst common_1 = require(\"@nestjs/common\");\r\nlet BbsArticlesController = class BbsArticlesController {\r\n  create(input) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      input;\r\n    });\r\n  }\r\n};\r\nexports.BbsArticlesController = BbsArticlesController;\r\n__decorate(\r\n  [\r\n    core_1.TypedRoute.Post({\r\n      type: \"assert\",\r\n      assert: (input) => {\r\n        const assert = (input) => {\r\n          const __is = (input) => {\r\n            return null !== input && undefined === input;\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.TypedRoute.Post.guard;\r\n              return (\r\n                (null !== input ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"undefined\",\r\n                    value: input,\r\n                  })) &&\r\n                (undefined === input ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"undefined\",\r\n                    value: input,\r\n                  }))\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        };\r\n        const stringify = (input) => {\r\n          return undefined;\r\n        };\r\n        return stringify(assert(input));\r\n      },\r\n    }),\r\n    __param(\r\n      0,\r\n      core_1.TypedFormData.Body({\r\n        files: [\r\n          {\r\n            name: \"thumbnail\",\r\n            limit: 1,\r\n          },\r\n          {\r\n            name: \"files\",\r\n            limit: null,\r\n          },\r\n        ],\r\n        validator: {\r\n          type: \"assert\",\r\n          assert: (input) => {\r\n            const decode = (input) => {\r\n              var _a;\r\n              const $string = core_1.TypedFormData.Body.string;\r\n              const $file = core_1.TypedFormData.Body.file;\r\n              const output = {\r\n                title: $string(input.get(\"title\")),\r\n                body: $string(input.get(\"body\")),\r\n                thumbnail:\r\n                  (_a = $file(input.get(\"thumbnail\"))) !== null && _a !== void 0\r\n                    ? _a\r\n                    : undefined,\r\n                files: input.getAll(\"files\").map((elem) => $file(elem)),\r\n                tags: input.getAll(\"tags\").map((elem) => $string(elem)),\r\n              };\r\n              return output;\r\n            };\r\n            const assert = (input) => {\r\n              const __is = (input) => {\r\n                const $io0 = (input) =>\r\n                  \"string\" === typeof input.title &&\r\n                  (null === input.body || \"string\" === typeof input.body) &&\r\n                  (undefined === input.thumbnail ||\r\n                    input.thumbnail instanceof File) &&\r\n                  Array.isArray(input.files) &&\r\n                  input.files.every((elem) => elem instanceof File) &&\r\n                  Array.isArray(input.tags) &&\r\n                  input.tags.every((elem) => \"string\" === typeof elem);\r\n                return (\r\n                  \"object\" === typeof input && null !== input && $io0(input)\r\n                );\r\n              };\r\n              if (false === __is(input))\r\n                ((input, _path, _exceptionable = true) => {\r\n                  const $guard = core_1.TypedFormData.Body.guard;\r\n                  const $ao0 = (input, _path, _exceptionable = true) =>\r\n                    (\"string\" === typeof input.title ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".title\",\r\n                        expected: \"string\",\r\n                        value: input.title,\r\n                      })) &&\r\n                    (null === input.body ||\r\n                      \"string\" === typeof input.body ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".body\",\r\n                        expected: \"(null | string)\",\r\n                        value: input.body,\r\n                      })) &&\r\n                    (undefined === input.thumbnail ||\r\n                      input.thumbnail instanceof File ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".thumbnail\",\r\n                        expected: \"(File | undefined)\",\r\n                        value: input.thumbnail,\r\n                      })) &&\r\n                    (((Array.isArray(input.files) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".files\",\r\n                        expected: \"Array<File>\",\r\n                        value: input.files,\r\n                      })) &&\r\n                      input.files.every(\r\n                        (elem, _index1) =>\r\n                          elem instanceof File ||\r\n                          $guard(_exceptionable, {\r\n                            path: _path + \".files[\" + _index1 + \"]\",\r\n                            expected: \"File\",\r\n                            value: elem,\r\n                          }),\r\n                      )) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".files\",\r\n                        expected: \"Array<File>\",\r\n                        value: input.files,\r\n                      })) &&\r\n                    (((Array.isArray(input.tags) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".tags\",\r\n                        expected: \"Array<string>\",\r\n                        value: input.tags,\r\n                      })) &&\r\n                      input.tags.every(\r\n                        (elem, _index2) =>\r\n                          \"string\" === typeof elem ||\r\n                          $guard(_exceptionable, {\r\n                            path: _path + \".tags[\" + _index2 + \"]\",\r\n                            expected: \"string\",\r\n                            value: elem,\r\n                          }),\r\n                      )) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".tags\",\r\n                        expected: \"Array<string>\",\r\n                        value: input.tags,\r\n                      }));\r\n                  return (\r\n                    (((\"object\" === typeof input && null !== input) ||\r\n                      $guard(true, {\r\n                        path: _path + \"\",\r\n                        expected: \"IBbsArticleCreate\",\r\n                        value: input,\r\n                      })) &&\r\n                      $ao0(input, _path + \"\", true)) ||\r\n                    $guard(true, {\r\n                      path: _path + \"\",\r\n                      expected: \"IBbsArticleCreate\",\r\n                      value: input,\r\n                    })\r\n                  );\r\n                })(input, \"$input\", true);\r\n              return input;\r\n            };\r\n            const output = decode(input);\r\n            return assert(output);\r\n          },\r\n        },\r\n      }),\r\n    ),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object]),\r\n    __metadata(\"design:returntype\", Promise),\r\n  ],\r\n  BbsArticlesController.prototype,\r\n  \"create\",\r\n  null,\r\n);\r\nexports.BbsArticlesController = BbsArticlesController = __decorate(\r\n  [(0, common_1.Controller)(\"bbs/articles\")],\r\n  BbsArticlesController,\r\n);\r\n//# sourceMappingURL=BbsArticlesController.js.map\nJust call @TypedFormData.Body() function on the request body parameter, that's all.Nestia will analyze your type (IBbsArticleCreate), and writes optimal code for the target type, in the compilation level. If you click the \"Complied JavaScript File\" tab of above, you can see the optimal transformation and validation code.Such optimization is called AOT (Ahead of Time) compilation, and it is the secret of @TypedFormData.Body.By the way, if you're using fastify, you have to setup @fastify/multipart and configure like below when composing the NestJS application. If you don't do it, @TypedFormData.Body() will not work properly, and throw 500 internal server error when Blob or File type being utilized.\nimport multipart from \"fastify-multipart\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\nimport { \r\n  FastifyAdapter, \r\n  NestFastifyApplication \r\n} from \"@nestjs/platform-fastify\";\r\n\r\nexport async function main() {\r\n  const app = await NestFactory.create<NestFastifyApplication>(\r\n    AppModule,\r\n    new FastifyAdapter(),\r\n  );\r\n  app.register(multipart);\r\n  await app.listen(3000);\r\n}","special-tags#Special Tags":"You can enhance validation logic, of @TypedFormData.Body(), through comment tags.You know what? @TypedFormData.Body() utilizes typia.assert<T>() function for form data validation, and the typia.assert<T>() function supports additional type checking logics through comment tags. For reference, \"Type Tag\" means a intersection type with atomic type and special tag type of typia like number & tags.Type<\"uint32\">, and \"Comment Tag\" means a comment starting from @ symbol following @${name} ${value} format.With those type and comment tags, you can add additional validation logics. If you want to add a custom validation logic, you also can do it. Read below Guide Docments of typia, and see the example code. You may understand how to utilize such type and comment tags, in a few minutes.\ntypia > Validators > Custom Tags\nOutline\nType Tags\nComment Tags\nCustomization\nimport typia, { tags } from \"typia\";\r\n\r\nexport const checkSpecialTag = typia.createIs<SpecialTag>();\r\n\r\ninterface SpecialTag {\r\n  int32: number & tags.Type<\"int32\">;\r\n  range?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\r\n  minLength: string & tags.MinLength<3>;\r\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\r\n  date: null | (string & tags.Format<\"date\">);\r\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\r\n  uuids: Array<string & tags.Format<\"uuid\">> &\r\n    tags.MinItems<3> &\r\n    tags.MaxItems<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.checkSpecialTag = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst checkSpecialTag = (input) => {\r\n  const $io0 = (input) =>\r\n    \"number\" === typeof input.int32 &&\r\n    Math.floor(input.int32) === input.int32 &&\r\n    -2147483648 <= input.int32 &&\r\n    input.int32 <= 2147483647 &&\r\n    (undefined === input.range ||\r\n      (\"number\" === typeof input.range &&\r\n        19 < input.range &&\r\n        input.range <= 100)) &&\r\n    \"string\" === typeof input.minLength &&\r\n    3 <= input.minLength.length &&\r\n    \"string\" === typeof input.pattern &&\r\n    /^[a-z]+$/.test(input.pattern) &&\r\n    (null === input.date ||\r\n      (\"string\" === typeof input.date &&\r\n        /^(d{4})-(d{2})-(d{2})$/.test(input.date))) &&\r\n    \"string\" === typeof input.ip &&\r\n    (/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\r\n      input.ip,\r\n    ) ||\r\n      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(\r\n        input.ip,\r\n      )) &&\r\n    Array.isArray(input.uuids) &&\r\n    3 <= input.uuids.length &&\r\n    input.uuids.length <= 100 &&\r\n    input.uuids.every(\r\n      (elem) =>\r\n        \"string\" === typeof elem &&\r\n        /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n          elem,\r\n        ),\r\n    );\r\n  return \"object\" === typeof input && null !== input && $io0(input);\r\n};\r\nexports.checkSpecialTag = checkSpecialTag;","restriction#Restriction":"When using @TypedFormData.Body(), you've to follow such restrction.At first, type of @TypedFormData.Body() must be a pure object type. It does not allow union type. Also, nullable and undefindable types are not allowed, either. Note that, query parameter type must be a sole object type without any extra definition.At next, type of properties must be atomic, Blob, File or array of them. In the atomic type case, the atomic type allows both nullable and undefindable types. However, mixed union atomic type like string | number or \"1\" | \"2\" | 3 are not allowed. Also, the array type does not allow both nullable and undefindable types, either.\nboolean\nnumber\nbigint\nstring\nBlob\nFile\nexport interface SomeFormDataDto {\r\n  //----\r\n  // ATOMIC OR FILE TYPES\r\n  //----\r\n  // ALLOWED\r\n  boolean: boolean;\r\n  number: number;\r\n  string: string;\r\n  bigint: bigint;\r\n  optional_number?: number;\r\n  nullable_string: string | null;\r\n  literal_union: \"A\" | \"B\" | \"C\" | \"D\";\r\n  blob: Blob;\r\n  file: File;\r\n\r\n  // NOT ALLOWED\r\n  mixed_union: string | number | boolean;\r\n  mixed_literal: \"A\" | \"B\" | 3;\r\n\r\n  //----\r\n  // ARRAY TYPES\r\n  //----\r\n  // ALLOWED\r\n  nullable_element_array: (string | null)[];\r\n  string_array: string[];\r\n  number_array: number[];\r\n  literal_union_array: (\"A\" | \"B\" | \"C\")[];\r\n  literal_tuple: [\"A\", \"B\", \"C\"];\r\n  blobs: Blob[];\r\n  files: File[];\r\n\r\n  // NOT ALLOWED\r\n  optional_element_array: (string | undefined)[];\r\n  optional_array: string[] | undefined;\r\n  nullable_array: string[] | null;\r\n  union_atomic_array: (string | number)[];\r\n  mixed_literal_array: (\"A\", \"B\", 3)[];\r\n  mixed_tuple: [\"A\", \"B\", 3];\r\n}"}},"/docs/core/TypedHeaders":{"title":"Typedheaders","data":{"outline#Outline":"export function TypedHeaders(): ParameterDecorator;\nRequest headers decorator, type safe.@TypedHeaders() is a decorator function parsing request headers to a typed object. It validates the request header values through typia.assert<T>(). If the request header values are invalid, it will throw 400 bad request exception.It is almost same with original @Headers() of NestJS, but much type safe.\n@TypedHeaders() is not essential for Swagger Documents or SDK Library building.Therefore, it is not a matter to use @TypedHeaders() or @Headers() of the original NestJS.","how-to-use#How to use":"export interface IHeaders {\r\n  \"x-category\": \"x\" | \"y\" | \"z\";\r\n  \"x-memo\"?: string;\r\n  \"x-name\"?: string;\r\n  \"x-values\": number[];\r\n  \"x-flags\": boolean[];\r\n  \"X-Descriptions\": string[]; // ALLOW UPPER-CASE\r\n}\nimport { Controller } from \"@nestjs/common\";\r\n\r\nimport core from \"@nestia/core\";\r\n\r\nimport { IHeaders } from \"@api/lib/structures/IHeaders\";\r\n\r\n@Controller(\"headers/:section\")\r\nexport class HeadersController {\r\n  /**\r\n   * Emplace headers.\r\n   *\r\n   * @param headers Headers for authentication\r\n   * @param section Target section code\r\n   * @returns Store article\r\n   *\r\n   * @author Samchon\r\n   */\r\n  @core.TypedRoute.Patch()\r\n  public emplace(\r\n    @core.TypedHeaders() headers: IHeaders,\r\n    @core.TypedParam(\"section\", \"string\") section: string,\r\n  ): void {\r\n    headers;\r\n    section;\r\n  }\r\n}\n\"use strict\";\r\nvar __decorate =\r\n  (this && this.__decorate) ||\r\n  function (decorators, target, key, desc) {\r\n    var c = arguments.length,\r\n      r =\r\n        c < 3\r\n          ? target\r\n          : desc === null\r\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\r\n          : desc,\r\n      d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\r\n      r = Reflect.decorate(decorators, target, key, desc);\r\n    else\r\n      for (var i = decorators.length - 1; i >= 0; i--)\r\n        if ((d = decorators[i]))\r\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n  };\r\nvar __metadata =\r\n  (this && this.__metadata) ||\r\n  function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\r\n      return Reflect.metadata(k, v);\r\n  };\r\nvar __param =\r\n  (this && this.__param) ||\r\n  function (paramIndex, decorator) {\r\n    return function (target, key) {\r\n      decorator(target, key, paramIndex);\r\n    };\r\n  };\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.HeadersController = void 0;\r\nconst common_1 = require(\"@nestjs/common\");\r\nconst core_1 = __importDefault(require(\"@nestia/core\"));\r\nlet HeadersController = (exports.HeadersController = class HeadersController {\r\n  /**\r\n   * Emplace headers.\r\n   *\r\n   * @param headers Headers for authentication\r\n   * @param section Target section code\r\n   * @returns Store article\r\n   *\r\n   * @author Samchon\r\n   */\r\n  emplace(headers, section) {\r\n    headers;\r\n    section;\r\n  }\r\n});\r\n__decorate(\r\n  [\r\n    (0, common_1.Get)(),\r\n    __param(\r\n      0,\r\n      core_1.default.TypedHeaders((input) => {\r\n        const $number = core_1.default.TypedHeaders.number;\r\n        const $boolean = core_1.default.TypedHeaders.boolean;\r\n        const $string = core_1.default.TypedHeaders.string;\r\n        const output = {\r\n          \"x-category\": input[\"x-category\"],\r\n          \"x-memo\": input[\"x-memo\"],\r\n          \"x-name\": input[\"x-name\"],\r\n          \"x-values\": input[\"x-values\"]?.split(\", \")?.map($number),\r\n          \"x-flags\": input[\"x-flags\"]?.split(\", \")?.map($boolean),\r\n          \"X-Descriptions\": input[\"x-descriptions\"]?.split(\", \")?.map($string),\r\n          // AUTOMATIC UPPER-CASE CONVERTING\r\n        };\r\n        return ((input) => {\r\n          const __is = (input) => {\r\n            const $io0 = (input) =>\r\n              (\"x\" === input[\"x-category\"] ||\r\n                \"y\" === input[\"x-category\"] ||\r\n                \"z\" === input[\"x-category\"]) &&\r\n              (undefined === input[\"x-memo\"] ||\r\n                \"string\" === typeof input[\"x-memo\"]) &&\r\n              (undefined === input[\"x-name\"] ||\r\n                \"string\" === typeof input[\"x-name\"]) &&\r\n              Array.isArray(input[\"x-values\"]) &&\r\n              input[\"x-values\"].every(\r\n                (elem) => \"number\" === typeof elem && Number.isFinite(elem),\r\n              ) &&\r\n              Array.isArray(input[\"x-flags\"]) &&\r\n              input[\"x-flags\"].every((elem) => \"boolean\" === typeof elem) &&\r\n              Array.isArray(input[\"X-Descriptions\"]) &&\r\n              input[\"X-Descriptions\"].every((elem) => \"string\" === typeof elem);\r\n            return \"object\" === typeof input && null !== input && $io0(input);\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.default.TypedHeaders.guard;\r\n              const $ao0 = (input, _path, _exceptionable = true) =>\r\n                (\"x\" === input[\"x-category\"] ||\r\n                  \"y\" === input[\"x-category\"] ||\r\n                  \"z\" === input[\"x-category\"] ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + '[\"x-category\"]',\r\n                    expected: '(\"x\" | \"y\" | \"z\")',\r\n                    value: input[\"x-category\"],\r\n                  })) &&\r\n                (undefined === input[\"x-memo\"] ||\r\n                  \"string\" === typeof input[\"x-memo\"] ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + '[\"x-memo\"]',\r\n                    expected: \"(string | undefined)\",\r\n                    value: input[\"x-memo\"],\r\n                  })) &&\r\n                (undefined === input[\"x-name\"] ||\r\n                  \"string\" === typeof input[\"x-name\"] ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + '[\"x-name\"]',\r\n                    expected: \"(string | undefined)\",\r\n                    value: input[\"x-name\"],\r\n                  })) &&\r\n                (((Array.isArray(input[\"x-values\"]) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + '[\"x-values\"]',\r\n                    expected: \"Array<number>\",\r\n                    value: input[\"x-values\"],\r\n                  })) &&\r\n                  input[\"x-values\"].every(\r\n                    (elem, _index1) =>\r\n                      (\"number\" === typeof elem && Number.isFinite(elem)) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + '[\"x-values\"][' + _index1 + \"]\",\r\n                        expected: \"number\",\r\n                        value: elem,\r\n                      }),\r\n                  )) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + '[\"x-values\"]',\r\n                    expected: \"Array<number>\",\r\n                    value: input[\"x-values\"],\r\n                  })) &&\r\n                (((Array.isArray(input[\"x-flags\"]) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + '[\"x-flags\"]',\r\n                    expected: \"Array<boolean>\",\r\n                    value: input[\"x-flags\"],\r\n                  })) &&\r\n                  input[\"x-flags\"].every(\r\n                    (elem, _index2) =>\r\n                      \"boolean\" === typeof elem ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + '[\"x-flags\"][' + _index2 + \"]\",\r\n                        expected: \"boolean\",\r\n                        value: elem,\r\n                      }),\r\n                  )) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + '[\"x-flags\"]',\r\n                    expected: \"Array<boolean>\",\r\n                    value: input[\"x-flags\"],\r\n                  })) &&\r\n                (((Array.isArray(input[\"X-Descriptions\"]) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + '[\"X-Descriptions\"]',\r\n                    expected: \"Array<string>\",\r\n                    value: input[\"X-Descriptions\"],\r\n                  })) &&\r\n                  input[\"X-Descriptions\"].every(\r\n                    (elem, _index3) =>\r\n                      \"string\" === typeof elem ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + '[\"X-Descriptions\"][' + _index3 + \"]\",\r\n                        expected: \"string\",\r\n                        value: elem,\r\n                      }),\r\n                  )) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + '[\"X-Descriptions\"]',\r\n                    expected: \"Array<string>\",\r\n                    value: input[\"X-Descriptions\"],\r\n                  }));\r\n              return (\r\n                (((\"object\" === typeof input && null !== input) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IHeaders\",\r\n                    value: input,\r\n                  })) &&\r\n                  $ao0(input, _path + \"\", true)) ||\r\n                $guard(true, {\r\n                  path: _path + \"\",\r\n                  expected: \"IHeaders\",\r\n                  value: input,\r\n                })\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        })(output);\r\n      }),\r\n    ),\r\n    __param(1, core_1.default.TypedParam(\"section\", \"string\", false)),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object, String]),\r\n    __metadata(\"design:returntype\", void 0),\r\n  ],\r\n  HeadersController.prototype,\r\n  \"emplace\",\r\n  null,\r\n);\r\nexports.HeadersController = HeadersController = __decorate(\r\n  [(0, common_1.Controller)(\"headers/:section\")],\r\n  HeadersController,\r\n);\nJust call @TypedHeaders() function on the request headers parameter, that's all.Nestia will analyze your type (IHeaders), and write optimal conversion and validation code for the target type, in the compilation level. If you click the \"Compiled JavaScript File\" tab of above, you can see the optimal code.Also, as you can see from the \"Compiled JavaScript File\", when upper case alphabet is used in the header key name like IHeaders[\"X-Descriptions\"], @TypedHeaders() would automatically convert to the upper case alphabet key named property from lower case key named property of raw data.Such optimization is called AOT (Ahead of Time) compilation, and it is the secret of @TypedHeaders\nBesides, the original @Headers() decorator of NestJS does not support such automatic upper case conversion. When you've define upper-cased property name in DTO, undefined value always be assigned, even if you've sent upper-cased property in the client side.","special-tags#Special Tags":"You can enhance validation logic, of @TypedHeaders(), through comment tags.You know what? @TypedHeaders() utilizes typia.assert<T>() function for query data validation, and the typia.assert<T>() function supports additional type checking logics through comment tags. For reference, \"Type Tag\" means a intersection type with atomic type and special tag type of typia like number & tags.Type<\"uint32\">, and \"Comment Tag\" means a comment starting from @ symbol following @${name} ${value} format.With those type and comment tags, you can add additional validation logics. If you want to add a custom validation logic, you also can do it. Read below Guide Docments of typia, and see the example code. You may understand how to utilize such type and comment tags, in a few minutes.\ntypia > Validators > Custom Tags\nOutline\nType Tags\nComment Tags\nCustomization\nimport typia, { tags } from \"typia\";\r\n\r\nexport const checkSpecialTag = typia.createIs<SpecialTag>();\r\n\r\ninterface SpecialTag {\r\n  int32: number & tags.Type<\"int32\">;\r\n  range?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\r\n  minLength: string & tags.MinLength<3>;\r\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\r\n  date: null | (string & tags.Format<\"date\">);\r\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\r\n  uuids: Array<string & tags.Format<\"uuid\">> &\r\n    tags.MinItems<3> &\r\n    tags.MaxItems<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.checkSpecialTag = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst checkSpecialTag = (input) => {\r\n  const $io0 = (input) =>\r\n    \"number\" === typeof input.int32 &&\r\n    Math.floor(input.int32) === input.int32 &&\r\n    -2147483648 <= input.int32 &&\r\n    input.int32 <= 2147483647 &&\r\n    (undefined === input.range ||\r\n      (\"number\" === typeof input.range &&\r\n        19 < input.range &&\r\n        input.range <= 100)) &&\r\n    \"string\" === typeof input.minLength &&\r\n    3 <= input.minLength.length &&\r\n    \"string\" === typeof input.pattern &&\r\n    /^[a-z]+$/.test(input.pattern) &&\r\n    (null === input.date ||\r\n      (\"string\" === typeof input.date &&\r\n        /^(d{4})-(d{2})-(d{2})$/.test(input.date))) &&\r\n    \"string\" === typeof input.ip &&\r\n    (/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\r\n      input.ip,\r\n    ) ||\r\n      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(\r\n        input.ip,\r\n      )) &&\r\n    Array.isArray(input.uuids) &&\r\n    3 <= input.uuids.length &&\r\n    input.uuids.length <= 100 &&\r\n    input.uuids.every(\r\n      (elem) =>\r\n        \"string\" === typeof elem &&\r\n        /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n          elem,\r\n        ),\r\n    );\r\n  return \"object\" === typeof input && null !== input && $io0(input);\r\n};\r\nexports.checkSpecialTag = checkSpecialTag;","restriction#Restriction":"When using @TypedHeaders(), you've to follow such restrictions.At first, type of @TypedHeaders() must be a pure object type. It does not allow union type. Also, nullable types are not allowed, either. Note that, request headers type must be a sole object type without any extra definition. Of course, the word object does not contain array type.At next, type of properties must be atomic, or array of atomic type. In the atomic type case, the atomic type allows both nullable and undefindable types. However, mixed union atomic type like string | number or \"1\" | \"2\" | 3 are not allowed. Also, the array type does not allow both nullable and undefindable types, either.\nboolean\nnumber\nbigint\nstring\nAt last, HTTP headers has special restriction on value types for specific key names. For example, Set-Cookie must be Array type, and Authorization must be an atomic type like string. Therefore, @TypedHeaders() also restricts the value type of specific key names, and it is described in below.\nOnly array type allowed:\nset-cookie\nOnly atomic type allowed:\nage\nauthorization\ncontent-length\ncontent-type\netag\nexpires\nfrom\nhost\nif-modified-since\nif-unmodified-since\nlast-modified\nlocation\nmax-forwards\nproxy-authorization\nreferer\nretry-after\nserver\nuser-agent\nexport interface SomeHeadersDto {\r\n  //----\r\n  // ATOMIC TYPES\r\n  //----\r\n  // ALLOWED\r\n  boolean: boolean;\r\n  number: number;\r\n  string: string;\r\n  bigint: bigint;\r\n  optional_number?: number;\r\n  nullable_string: string | null;\r\n  literal_union: \"A\" | \"B\" | \"C\" | \"D\";\r\n\r\n  // NOT ALLOWED\r\n  mixed_union: string | number | boolean;\r\n  mixed_literal: \"A\" | \"B\" | 3;\r\n\r\n  //----\r\n  // ARRAY TYPES\r\n  //----\r\n  // ALLOWED\r\n  nullable_element_array: (string | null)[];\r\n  string_array: string[];\r\n  number_array: number[];\r\n  literal_union_array: (\"A\" | \"B\" | \"C\")[];\r\n  literal_tuple: [\"A\", \"B\", \"C\"];\r\n\r\n  // NOT ALLOWED\r\n  optional_element_array: (string | undefined)[];\r\n  optional_array: string[] | undefined;\r\n  nullable_array: string[] | null;\r\n  union_atomic_array: (string | number)[];\r\n  mixed_literal_array: (\"A\", \"B\", 3)[];\r\n  mixed_tuple: [\"A\", \"B\", 3];\r\n\r\n  //----\r\n  // SPECIAL CASES\r\n  //----\r\n  // MUST BE ARRAY\r\n  \"Set-Cookie\": string[];\r\n\r\n  // MUST BE ATOMIC\r\n  Accept: string;\r\n  Authorization: string;\r\n\r\n  // NOT ALLOWED - MUST BE ATOMIC\r\n  referer: string[];\r\n  age: number[];\r\n}"}},"/docs/core/TypedRoute":{"title":"Typedroute","data":{"outline#Outline":"export namespace TypedRoute {\r\n  export function Get(path?: string): MethodDecorator;\r\n  export function Post(path?: string): MethodDecorator;\r\n  export function Put(path?: string): MethodDecorator;\r\n  export function Patch(path?: string): MethodDecorator;\r\n  export function Delete(path?: string): MethodDecorator;\r\n}\nRoute decorators 200x faster, even type safe and easy to use.TypedRoute is a namespaced module containing router decorators utilizing typia.assertStringify<T>() function. Those decorators are almost same with original NestJS, but TypedRoute can boost up JSON serialization speed maximum 200x times faster than class-transformer, therefore much faster than original NestJS.Furthermore, as TypedRoute utilizes typia.assertStringify<T>() function, it is even type safe. The typia.assertStringify<T>() function validates response data type, via typia.assert<T>() function, before JSON serialization. Therefore, if you try to return wrong typed value, it would be blocked with 500 internal server error.Moreover, TypedRoute is much easier than class-transformer, because it just needs only pure TypeScript type definition. If you can't understand the word \"pure TypeScript type\", then move to below #How to use section and read the IBbsArticle interface type. You may understand what it means.\nIf you want application/x-www-form-urlencoded type, use @TypedQuery.Post() instead.\n@TypedRoute.Get() is not essential for Swagger Documents or SDK Library building.Therefore, it is not a matter to use @TypedRoute.Post() or @Post() of the original NestJS.","how-to-use#How to use":"import { tags } from \"typia\";\r\n\r\nexport interface IBbsArticle extends IBbsArticle.IStore {\r\n  id: string & tags.Format<\"uuid\">;\r\n  created_at: string & tags.Format<\"date-time\">;\r\n}\r\nexport namespace IBbsArticle {\r\n  export interface IStore {\r\n    title: string & tags.MinLength<3> & tags.MaxLength<50>;\r\n    body: string;\r\n    files: IAttachmentFile[];\r\n  }\r\n}\r\n\r\nexport interface IAttachmentFile {\r\n  name: null | (string & tags.MinLength<1> & tags.MaxLength<255>);\r\n  extension: null | (string & tags.MinLength<1> & tags.MaxLength<8>);\r\n  url: string & tags.Format<\"url\">;\r\n}\nimport { TypedRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\n\r\nimport { IBbsArticle } from \"./IBbsArticle\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  /**\r\n   * Get random article for testing.\r\n   */\r\n  @TypedRoute.Get(\"random\")\r\n  public async random(): Promise<IBbsArticle> {\r\n    return {\r\n      id: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\r\n      title: \"Hello nestia users\",\r\n      body: \"Just use `TypedRoute.Get()` function like this\",\r\n      created_at: \"2023-04-23T12:04:54.168Z\",\r\n      files: [],\r\n    };\r\n  }\r\n}\n\"use strict\";\r\nvar __decorate =\r\n  (this && this.__decorate) ||\r\n  function (decorators, target, key, desc) {\r\n    var c = arguments.length,\r\n      r =\r\n        c < 3\r\n          ? target\r\n          : desc === null\r\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\r\n          : desc,\r\n      d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\r\n      r = Reflect.decorate(decorators, target, key, desc);\r\n    else\r\n      for (var i = decorators.length - 1; i >= 0; i--)\r\n        if ((d = decorators[i]))\r\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n  };\r\nvar __metadata =\r\n  (this && this.__metadata) ||\r\n  function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\r\n      return Reflect.metadata(k, v);\r\n  };\r\nvar __awaiter =\r\n  (this && this.__awaiter) ||\r\n  function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) {\r\n      return value instanceof P\r\n        ? value\r\n        : new P(function (resolve) {\r\n            resolve(value);\r\n          });\r\n    }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n      function fulfilled(value) {\r\n        try {\r\n          step(generator.next(value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function rejected(value) {\r\n        try {\r\n          step(generator[\"throw\"](value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function step(result) {\r\n        result.done\r\n          ? resolve(result.value)\r\n          : adopt(result.value).then(fulfilled, rejected);\r\n      }\r\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BbsArticlesController = void 0;\r\nconst core_1 = require(\"@nestia/core\");\r\nconst common_1 = require(\"@nestjs/common\");\r\nlet BbsArticlesController = class BbsArticlesController {\r\n  /**\r\n   * Get random article for testing.\r\n   */\r\n  random() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return {\r\n        id: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\r\n        title: \"Hello nestia users\",\r\n        body: \"Just use `TypedRoute.Get()` function like this\",\r\n        created_at: \"2023-04-23T12:04:54.168Z\",\r\n        files: [],\r\n      };\r\n    });\r\n  }\r\n};\r\nexports.BbsArticlesController = BbsArticlesController;\r\n__decorate(\r\n  [\r\n    core_1.TypedRoute.Get(\"random\", {\r\n      type: \"assert\",\r\n      assert: (input) => {\r\n        const assert = (input) => {\r\n          const __is = (input) => {\r\n            const $io0 = (input) =>\r\n              \"string\" === typeof input.id &&\r\n              /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n                input.id,\r\n              ) &&\r\n              \"string\" === typeof input.created_at &&\r\n              !isNaN(new Date(input.created_at).getTime()) &&\r\n              \"string\" === typeof input.title &&\r\n              3 <= input.title.length &&\r\n              input.title.length <= 50 &&\r\n              \"string\" === typeof input.body &&\r\n              Array.isArray(input.files) &&\r\n              input.files.every(\r\n                (elem) =>\r\n                  \"object\" === typeof elem && null !== elem && $io1(elem),\r\n              );\r\n            const $io1 = (input) =>\r\n              (null === input.name ||\r\n                (\"string\" === typeof input.name &&\r\n                  1 <= input.name.length &&\r\n                  input.name.length <= 255)) &&\r\n              (null === input.extension ||\r\n                (\"string\" === typeof input.extension &&\r\n                  1 <= input.extension.length &&\r\n                  input.extension.length <= 8)) &&\r\n              \"string\" === typeof input.url &&\r\n              /^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(\r\n                input.url,\r\n              );\r\n            return \"object\" === typeof input && null !== input && $io0(input);\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.TypedRoute.Get.guard;\r\n              const $ao0 = (input, _path, _exceptionable = true) =>\r\n                ((\"string\" === typeof input.id &&\r\n                  (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n                    input.id,\r\n                  ) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".id\",\r\n                      expected: 'string & Format<\"uuid\">',\r\n                      value: input.id,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".id\",\r\n                    expected: '(string & Format<\"uuid\">)',\r\n                    value: input.id,\r\n                  })) &&\r\n                ((\"string\" === typeof input.created_at &&\r\n                  (!isNaN(new Date(input.created_at).getTime()) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".created_at\",\r\n                      expected: 'string & Format<\"date-time\">',\r\n                      value: input.created_at,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".created_at\",\r\n                    expected: '(string & Format<\"date-time\">)',\r\n                    value: input.created_at,\r\n                  })) &&\r\n                ((\"string\" === typeof input.title &&\r\n                  (3 <= input.title.length ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MinLength<3>\",\r\n                      value: input.title,\r\n                    })) &&\r\n                  (input.title.length <= 50 ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MaxLength<50>\",\r\n                      value: input.title,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".title\",\r\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\r\n                    value: input.title,\r\n                  })) &&\r\n                (\"string\" === typeof input.body ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".body\",\r\n                    expected: \"string\",\r\n                    value: input.body,\r\n                  })) &&\r\n                (((Array.isArray(input.files) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files\",\r\n                    expected: \"Array<IAttachmentFile>\",\r\n                    value: input.files,\r\n                  })) &&\r\n                  input.files.every(\r\n                    (elem, _index1) =>\r\n                      (((\"object\" === typeof elem && null !== elem) ||\r\n                        $guard(_exceptionable, {\r\n                          path: _path + \".files[\" + _index1 + \"]\",\r\n                          expected: \"IAttachmentFile\",\r\n                          value: elem,\r\n                        })) &&\r\n                        $ao1(\r\n                          elem,\r\n                          _path + \".files[\" + _index1 + \"]\",\r\n                          true && _exceptionable,\r\n                        )) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".files[\" + _index1 + \"]\",\r\n                        expected: \"IAttachmentFile\",\r\n                        value: elem,\r\n                      }),\r\n                  )) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files\",\r\n                    expected: \"Array<IAttachmentFile>\",\r\n                    value: input.files,\r\n                  }));\r\n              const $ao1 = (input, _path, _exceptionable = true) =>\r\n                (null === input.name ||\r\n                  (\"string\" === typeof input.name &&\r\n                    (1 <= input.name.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".name\",\r\n                        expected: \"string & MinLength<1>\",\r\n                        value: input.name,\r\n                      })) &&\r\n                    (input.name.length <= 255 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".name\",\r\n                        expected: \"string & MaxLength<255>\",\r\n                        value: input.name,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".name\",\r\n                    expected:\r\n                      \"((string & MinLength<1> & MaxLength<255>) | null)\",\r\n                    value: input.name,\r\n                  })) &&\r\n                (null === input.extension ||\r\n                  (\"string\" === typeof input.extension &&\r\n                    (1 <= input.extension.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".extension\",\r\n                        expected: \"string & MinLength<1>\",\r\n                        value: input.extension,\r\n                      })) &&\r\n                    (input.extension.length <= 8 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".extension\",\r\n                        expected: \"string & MaxLength<8>\",\r\n                        value: input.extension,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".extension\",\r\n                    expected: \"((string & MinLength<1> & MaxLength<8>) | null)\",\r\n                    value: input.extension,\r\n                  })) &&\r\n                ((\"string\" === typeof input.url &&\r\n                  (/^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(\r\n                    input.url,\r\n                  ) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".url\",\r\n                      expected: 'string & Format<\"url\">',\r\n                      value: input.url,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".url\",\r\n                    expected: '(string & Format<\"url\">)',\r\n                    value: input.url,\r\n                  }));\r\n              return (\r\n                (((\"object\" === typeof input && null !== input) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IBbsArticle\",\r\n                    value: input,\r\n                  })) &&\r\n                  $ao0(input, _path + \"\", true)) ||\r\n                $guard(true, {\r\n                  path: _path + \"\",\r\n                  expected: \"IBbsArticle\",\r\n                  value: input,\r\n                })\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        };\r\n        const stringify = (input) => {\r\n          const $io1 = (input) =>\r\n            (null === input.name ||\r\n              (\"string\" === typeof input.name &&\r\n                1 <= input.name.length &&\r\n                input.name.length <= 255)) &&\r\n            (null === input.extension ||\r\n              (\"string\" === typeof input.extension &&\r\n                1 <= input.extension.length &&\r\n                input.extension.length <= 8)) &&\r\n            \"string\" === typeof input.url &&\r\n            /^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(\r\n              input.url,\r\n            );\r\n          const $string = core_1.TypedRoute.Get.string;\r\n          const $so0 = (input) =>\r\n            `{\"id\":${$string(input.id)},\"created_at\":${$string(\r\n              input.created_at,\r\n            )},\"title\":${$string(input.title)},\"body\":${$string(\r\n              input.body,\r\n            )},\"files\":${`[${input.files\r\n              .map((elem) => $so1(elem))\r\n              .join(\",\")}]`}}`;\r\n          const $so1 = (input) =>\r\n            `{\"name\":${\r\n              null !== input.name ? $string(input.name) : \"null\"\r\n            },\"extension\":${\r\n              null !== input.extension ? $string(input.extension) : \"null\"\r\n            },\"url\":${$string(input.url)}}`;\r\n          return $so0(input);\r\n        };\r\n        return stringify(assert(input));\r\n      },\r\n    }),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", []),\r\n    __metadata(\"design:returntype\", Promise),\r\n  ],\r\n  BbsArticlesController.prototype,\r\n  \"random\",\r\n  null,\r\n);\r\nexports.BbsArticlesController = BbsArticlesController = __decorate(\r\n  [(0, common_1.Controller)(\"bbs/articles\")],\r\n  BbsArticlesController,\r\n);\nJust call @TypedRoute.${method}() function on the target method, that's all.Nestia will analyze your type (IBbsArticle), and writes optimal code for the target type, in the compilation level. If you click the \"Compiled JavaScript File\" tab of above, you can see the optimal validation and JSON serialization code.Such optimization is called AOT (Ahead of Time) compilation, and it is the secret of TypedRoute.","special-tags#Special Tags":"You can enhance validation logic, of TypedRoute, through comment tags.You know what? @TypedRoute.${method}() functions are using typia.assertStringify<T>() function, that is combined with typia.assert<T>() and typia.stringify<T>() functions. It is the secret of @TypedRoute.${method}() functions, which can validates response body data type before JSON serialization, and throws 500 internal server error when the data type is not matched.Also, as typia.assert<T>() function can utililze comment tags for additional validation, TypedRoute also can utillze them, too. For reference, \"Type Tag\" means a intersection type with atomic type and special tag type of typia like number & tags.Type<\"uint32\">, and \"Comment Tag\" means a comment starting from @ symbol following @${name} ${value} format.With those type and comment tags, you can add additional validation logics. If you want to add a custom validation logic, you also can do it. Read below Guide Docments of typia, and see the example code. You may understand how to utilize such type and comment tags, in a few minutes.\ntypia > Validators > Custom Tags\nOutline\nType Tags\nComment Tags\nCustomization\nimport typia, { tags } from \"typia\";\r\n\r\nexport const checkSpecialTag = typia.createIs<SpecialTag>();\r\n\r\ninterface SpecialTag {\r\n  int32: number & tags.Type<\"int32\">;\r\n  range?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\r\n  minLength: string & tags.MinLength<3>;\r\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\r\n  date: null | (string & tags.Format<\"date\">);\r\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\r\n  uuids: Array<string & tags.Format<\"uuid\">> &\r\n    tags.MinItems<3> &\r\n    tags.MaxItems<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.checkSpecialTag = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst checkSpecialTag = (input) => {\r\n  const $io0 = (input) =>\r\n    \"number\" === typeof input.int32 &&\r\n    Math.floor(input.int32) === input.int32 &&\r\n    -2147483648 <= input.int32 &&\r\n    input.int32 <= 2147483647 &&\r\n    (undefined === input.range ||\r\n      (\"number\" === typeof input.range &&\r\n        19 < input.range &&\r\n        input.range <= 100)) &&\r\n    \"string\" === typeof input.minLength &&\r\n    3 <= input.minLength.length &&\r\n    \"string\" === typeof input.pattern &&\r\n    /^[a-z]+$/.test(input.pattern) &&\r\n    (null === input.date ||\r\n      (\"string\" === typeof input.date &&\r\n        /^(d{4})-(d{2})-(d{2})$/.test(input.date))) &&\r\n    \"string\" === typeof input.ip &&\r\n    (/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\r\n      input.ip,\r\n    ) ||\r\n      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(\r\n        input.ip,\r\n      )) &&\r\n    Array.isArray(input.uuids) &&\r\n    3 <= input.uuids.length &&\r\n    input.uuids.length <= 100 &&\r\n    input.uuids.every(\r\n      (elem) =>\r\n        \"string\" === typeof elem &&\r\n        /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n          elem,\r\n        ),\r\n    );\r\n  return \"object\" === typeof input && null !== input && $io0(input);\r\n};\r\nexports.checkSpecialTag = checkSpecialTag;","encrypedroute#EncrypedRoute":"export namespace EncrypedRoute {\r\n  export function Get(path?: string): MethodDecorator;\r\n  export function Post(path?: string): MethodDecorator;\r\n  export function Put(path?: string): MethodDecorator;\r\n  export function Patch(path?: string): MethodDecorator;\r\n  export function Delete(path?: string): MethodDecorator;\r\n}\nEncrypted router decorator functions.EncryptedRoute is a namespaced module similar with TypedRoute, but it encrypts response body data through AES-128/256 CBC algorithm like below. Therefore, it would be slower than TypedRoute, but it guarantees the security of response body data.\nAES-128/256\nCBC mode\nPKCS #5 Padding\nBase64 Encoding\nFor reference, such encryption spec is not supported in the Swagger-UI. Instead, SDK (Software Development Kit) generated by @nestia/sdk supports it. Thus, you have to build and distribute the SDK library to the client developers when using such encryption decorators.","benchmark#Benchmark":"","json#JSON":"Comparing JSON serialization speed, typia is maximum 200x faster than class-transformer.For reference, Nestia is using typia, and NestJS is using class-transformer. The other one fast-json-stringify is made and used by fastify (do not mean NestJS fastify mode, but mean pure fastify library. NestJS fastify mode still utilizes class-transformer), and it requires JSON schema definition.From above benchmark graph, you can see that class-transformer is extremely slower than others, even including built-in JSON.stringify() function. I can't understand why NestJS has adopted such slow and difficult library. The other fast-json-stringify is enough faster, but it needs extra schema definition like class-validator, therefore not easy to use.\ntypia needs only pure TypeScript type.\nclass-transformer requires DTO class with decorator function calls.\nfast-json-stringify requires JSON schema definition.\nMeasured on Intel i5-1135g7, Surface Pro 8","server#Server":"Looking at above benchmark, someone may ask:\nJSON serialization speed affects on the server performance?I think that the JSON serialization is just a tiny thing in the server side, isn't it?\nMy answer is, \"Yes, it affects on the server performance\".Most operations in NodeJS server are asynchronously executed in background thread, what are called \"event based non-blocking I/O model\". However, JSON serialization is a synchronous operation running on the main thread. Therefore, if the JSON serialization speed is slow, it makes the entire server program slow.I'll show you the benchmark result that, how JSON serizliation speed affects on the server performance.\nMeasured on Intel i5-1135g7, Surface Pro 8"}},"/docs/core/TypedQuery":{"title":"Typedquery","data":{"outline#Outline":"export function TypedQuery(): ParameterDecorator;\r\nexport namespace TypedQuery {\r\n  export function Body(): ParameterDecorator;\r\n  export function Get(path?: string): MethodDecorator;\r\n  export function Post(path?: string): MethodDecorator;\r\n  export function Put(path?: string): MethodDecorator;\r\n  export function Patch(path?: string): MethodDecorator;\r\n  export function Delete(path?: string): MethodDecorator;\r\n}\nDecorators for query parameters.\nWhat the query parameters are?This is the query parameters!\nname=Samchon&age=20&sex=male\n@TypedQuery() is not essential for Swagger Documents or SDK Library building.Therefore, it is not a matter to use @TypedQuery() or @Query() of the original NestJS.","typedquery#@TypedQuery()":"export function TypedQuery(): ParameterDecorator;\nType safe URL query decorator.@TypedQuery() is a decorator parsing URL query.It's almost same with original @Query() function of NestJS, but @TypedQuery() is more stable and general.While NestJS does not support query type validation, @TypedQuery() validates the request query type and throws 400 bad request error when mismatched. Also, while NestJS does not support property type (@Query() only supports string typed properties), @TypedQuery() can define variable property types like bigint, number or boolean.\nimport { tags } from \"typia\";\r\n\r\nexport namespace IBbsArticle {\r\n  export interface ISummary {\r\n    id: string & tags.Format<\"uuid\">;\r\n    writer: string;\r\n    title: string & tags.MinLength<3> & tags.MaxLength<50>;\r\n    created_at: string & tags.Format<\"date-time\">;\r\n  }\r\n}\nimport { tags } from \"typia\";\r\n\r\nexport interface IPage<T> {\r\n  data: T[];\r\n  pagination: IPage.IPagination;\r\n}\r\nexport namespace IPage {\r\n  /**\r\n   * Page request data\r\n   */\r\n  export interface IRequest {\r\n    page?: number & tags.Type<\"uint32\">;\r\n    limit?: number & tags.Type<\"uint32\">;\r\n  }\r\n  /**\r\n   * Page information.\r\n   */\r\n  export interface IPagination {\r\n    current: number & tags.Type<\"uint32\">;\r\n    limit: number & tags.Type<\"uint32\">;\r\n    records: number & tags.Type<\"uint32\">;\r\n    pages: number & tags.Type<\"uint32\">;\r\n  }\r\n}\nimport { TypedQuery, TypedRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport { tags } from \"typia\";\r\n\r\nimport { IBbsArticle } from \"./IBbsArticle\";\r\nimport { IPage } from \"./IPage\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  @TypedRoute.Get()\r\n  public async index(\r\n    @TypedQuery() query: IPage.IRequest\r\n  ): Promise<IPage<IBbsArticle.ISummary>> {\r\n    return {\r\n      pagination: {\r\n        current: query.page ?? 1,\r\n        limit: query.limit ?? 100,\r\n        records: 0,\r\n        pages: 0,\r\n      },\r\n      data: [],\r\n    };\r\n  }\r\n}\n\"use strict\";\r\nvar __decorate =\r\n  (this && this.__decorate) ||\r\n  function (decorators, target, key, desc) {\r\n    var c = arguments.length,\r\n      r =\r\n        c < 3\r\n          ? target\r\n          : desc === null\r\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\r\n          : desc,\r\n      d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\r\n      r = Reflect.decorate(decorators, target, key, desc);\r\n    else\r\n      for (var i = decorators.length - 1; i >= 0; i--)\r\n        if ((d = decorators[i]))\r\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n  };\r\nvar __metadata =\r\n  (this && this.__metadata) ||\r\n  function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\r\n      return Reflect.metadata(k, v);\r\n  };\r\nvar __param =\r\n  (this && this.__param) ||\r\n  function (paramIndex, decorator) {\r\n    return function (target, key) {\r\n      decorator(target, key, paramIndex);\r\n    };\r\n  };\r\nvar __awaiter =\r\n  (this && this.__awaiter) ||\r\n  function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) {\r\n      return value instanceof P\r\n        ? value\r\n        : new P(function (resolve) {\r\n            resolve(value);\r\n          });\r\n    }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n      function fulfilled(value) {\r\n        try {\r\n          step(generator.next(value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function rejected(value) {\r\n        try {\r\n          step(generator[\"throw\"](value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function step(result) {\r\n        result.done\r\n          ? resolve(result.value)\r\n          : adopt(result.value).then(fulfilled, rejected);\r\n      }\r\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BbsArticlesController = void 0;\r\nconst core_1 = require(\"@nestia/core\");\r\nconst common_1 = require(\"@nestjs/common\");\r\nlet BbsArticlesController = class BbsArticlesController {\r\n  index(query) {\r\n    var _a, _b;\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return {\r\n        pagination: {\r\n          current: (_a = query.page) !== null && _a !== void 0 ? _a : 1,\r\n          limit: (_b = query.limit) !== null && _b !== void 0 ? _b : 100,\r\n          records: 0,\r\n          pages: 0,\r\n        },\r\n        data: [],\r\n      };\r\n    });\r\n  }\r\n};\r\nexports.BbsArticlesController = BbsArticlesController;\r\n__decorate(\r\n  [\r\n    core_1.TypedRoute.Get({\r\n      type: \"assert\",\r\n      assert: (input) => {\r\n        const assert = (input) => {\r\n          const __is = (input) => {\r\n            const $io0 = (input) =>\r\n              Array.isArray(input.data) &&\r\n              input.data.every(\r\n                (elem) =>\r\n                  \"object\" === typeof elem && null !== elem && $io1(elem),\r\n              ) &&\r\n              \"object\" === typeof input.pagination &&\r\n              null !== input.pagination &&\r\n              \"number\" === typeof input.pagination.current &&\r\n              Math.floor(input.pagination.current) ===\r\n                input.pagination.current &&\r\n              0 <= input.pagination.current &&\r\n              input.pagination.current <= 4294967295 &&\r\n              \"number\" === typeof input.pagination.limit &&\r\n              Math.floor(input.pagination.limit) === input.pagination.limit &&\r\n              0 <= input.pagination.limit &&\r\n              input.pagination.limit <= 4294967295 &&\r\n              \"number\" === typeof input.pagination.records &&\r\n              Math.floor(input.pagination.records) ===\r\n                input.pagination.records &&\r\n              0 <= input.pagination.records &&\r\n              input.pagination.records <= 4294967295 &&\r\n              \"number\" === typeof input.pagination.pages &&\r\n              Math.floor(input.pagination.pages) === input.pagination.pages &&\r\n              0 <= input.pagination.pages &&\r\n              input.pagination.pages <= 4294967295;\r\n            const $io1 = (input) =>\r\n              \"string\" === typeof input.id &&\r\n              /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n                input.id,\r\n              ) &&\r\n              \"string\" === typeof input.writer &&\r\n              \"string\" === typeof input.title &&\r\n              3 <= input.title.length &&\r\n              input.title.length <= 50 &&\r\n              \"string\" === typeof input.created_at &&\r\n              !isNaN(new Date(input.created_at).getTime());\r\n            return \"object\" === typeof input && null !== input && $io0(input);\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.TypedRoute.Get.guard;\r\n              const $ao0 = (input, _path, _exceptionable = true) =>\r\n                (((Array.isArray(input.data) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".data\",\r\n                    expected: \"Array<IBbsArticle.ISummary>\",\r\n                    value: input.data,\r\n                  })) &&\r\n                  input.data.every(\r\n                    (elem, _index1) =>\r\n                      (((\"object\" === typeof elem && null !== elem) ||\r\n                        $guard(_exceptionable, {\r\n                          path: _path + \".data[\" + _index1 + \"]\",\r\n                          expected: \"IBbsArticle.ISummary\",\r\n                          value: elem,\r\n                        })) &&\r\n                        $ao1(\r\n                          elem,\r\n                          _path + \".data[\" + _index1 + \"]\",\r\n                          true && _exceptionable,\r\n                        )) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".data[\" + _index1 + \"]\",\r\n                        expected: \"IBbsArticle.ISummary\",\r\n                        value: elem,\r\n                      }),\r\n                  )) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".data\",\r\n                    expected: \"Array<IBbsArticle.ISummary>\",\r\n                    value: input.data,\r\n                  })) &&\r\n                ((((\"object\" === typeof input.pagination &&\r\n                  null !== input.pagination) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".pagination\",\r\n                    expected: \"IPage.IPagination\",\r\n                    value: input.pagination,\r\n                  })) &&\r\n                  $ao2(\r\n                    input.pagination,\r\n                    _path + \".pagination\",\r\n                    true && _exceptionable,\r\n                  )) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".pagination\",\r\n                    expected: \"IPage.IPagination\",\r\n                    value: input.pagination,\r\n                  }));\r\n              const $ao1 = (input, _path, _exceptionable = true) =>\r\n                ((\"string\" === typeof input.id &&\r\n                  (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n                    input.id,\r\n                  ) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".id\",\r\n                      expected: 'string & Format<\"uuid\">',\r\n                      value: input.id,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".id\",\r\n                    expected: '(string & Format<\"uuid\">)',\r\n                    value: input.id,\r\n                  })) &&\r\n                (\"string\" === typeof input.writer ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".writer\",\r\n                    expected: \"string\",\r\n                    value: input.writer,\r\n                  })) &&\r\n                ((\"string\" === typeof input.title &&\r\n                  (3 <= input.title.length ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MinLength<3>\",\r\n                      value: input.title,\r\n                    })) &&\r\n                  (input.title.length <= 50 ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MaxLength<50>\",\r\n                      value: input.title,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".title\",\r\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\r\n                    value: input.title,\r\n                  })) &&\r\n                ((\"string\" === typeof input.created_at &&\r\n                  (!isNaN(new Date(input.created_at).getTime()) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".created_at\",\r\n                      expected: 'string & Format<\"date-time\">',\r\n                      value: input.created_at,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".created_at\",\r\n                    expected: '(string & Format<\"date-time\">)',\r\n                    value: input.created_at,\r\n                  }));\r\n              const $ao2 = (input, _path, _exceptionable = true) =>\r\n                ((\"number\" === typeof input.current &&\r\n                  ((Math.floor(input.current) === input.current &&\r\n                    0 <= input.current &&\r\n                    input.current <= 4294967295) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".current\",\r\n                      expected: 'number & Type<\"uint32\">',\r\n                      value: input.current,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".current\",\r\n                    expected: '(number & Type<\"uint32\">)',\r\n                    value: input.current,\r\n                  })) &&\r\n                ((\"number\" === typeof input.limit &&\r\n                  ((Math.floor(input.limit) === input.limit &&\r\n                    0 <= input.limit &&\r\n                    input.limit <= 4294967295) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".limit\",\r\n                      expected: 'number & Type<\"uint32\">',\r\n                      value: input.limit,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".limit\",\r\n                    expected: '(number & Type<\"uint32\">)',\r\n                    value: input.limit,\r\n                  })) &&\r\n                ((\"number\" === typeof input.records &&\r\n                  ((Math.floor(input.records) === input.records &&\r\n                    0 <= input.records &&\r\n                    input.records <= 4294967295) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".records\",\r\n                      expected: 'number & Type<\"uint32\">',\r\n                      value: input.records,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".records\",\r\n                    expected: '(number & Type<\"uint32\">)',\r\n                    value: input.records,\r\n                  })) &&\r\n                ((\"number\" === typeof input.pages &&\r\n                  ((Math.floor(input.pages) === input.pages &&\r\n                    0 <= input.pages &&\r\n                    input.pages <= 4294967295) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".pages\",\r\n                      expected: 'number & Type<\"uint32\">',\r\n                      value: input.pages,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".pages\",\r\n                    expected: '(number & Type<\"uint32\">)',\r\n                    value: input.pages,\r\n                  }));\r\n              return (\r\n                (((\"object\" === typeof input && null !== input) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IPage<IBbsArticle.ISummary>\",\r\n                    value: input,\r\n                  })) &&\r\n                  $ao0(input, _path + \"\", true)) ||\r\n                $guard(true, {\r\n                  path: _path + \"\",\r\n                  expected: \"IPage<IBbsArticle.ISummary>\",\r\n                  value: input,\r\n                })\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        };\r\n        const stringify = (input) => {\r\n          const $io1 = (input) =>\r\n            \"string\" === typeof input.id &&\r\n            /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n              input.id,\r\n            ) &&\r\n            \"string\" === typeof input.writer &&\r\n            \"string\" === typeof input.title &&\r\n            3 <= input.title.length &&\r\n            input.title.length <= 50 &&\r\n            \"string\" === typeof input.created_at &&\r\n            !isNaN(new Date(input.created_at).getTime());\r\n          const $io2 = (input) =>\r\n            \"number\" === typeof input.current &&\r\n            Math.floor(input.current) === input.current &&\r\n            0 <= input.current &&\r\n            input.current <= 4294967295 &&\r\n            \"number\" === typeof input.limit &&\r\n            Math.floor(input.limit) === input.limit &&\r\n            0 <= input.limit &&\r\n            input.limit <= 4294967295 &&\r\n            \"number\" === typeof input.records &&\r\n            Math.floor(input.records) === input.records &&\r\n            0 <= input.records &&\r\n            input.records <= 4294967295 &&\r\n            \"number\" === typeof input.pages &&\r\n            Math.floor(input.pages) === input.pages &&\r\n            0 <= input.pages &&\r\n            input.pages <= 4294967295;\r\n          const $string = core_1.TypedRoute.Get.string;\r\n          const $so0 = (input) =>\r\n            `{\"data\":${`[${input.data\r\n              .map(\r\n                (elem) =>\r\n                  `{\"id\":${$string(elem.id)},\"writer\":${$string(\r\n                    elem.writer,\r\n                  )},\"title\":${$string(elem.title)},\"created_at\":${$string(\r\n                    elem.created_at,\r\n                  )}}`,\r\n              )\r\n              .join(\r\n                \",\",\r\n              )}]`},\"pagination\":${`{\"current\":${input.pagination.current},\"limit\":${input.pagination.limit},\"records\":${input.pagination.records},\"pages\":${input.pagination.pages}}`}}`;\r\n          return $so0(input);\r\n        };\r\n        return stringify(assert(input));\r\n      },\r\n    }),\r\n    __param(\r\n      0,\r\n      (0, core_1.TypedQuery)((input) => {\r\n        var _a, _b;\r\n        const $number = core_1.TypedQuery.number;\r\n        const output = {\r\n          page:\r\n            (_a = $number(input.get(\"page\"))) !== null && _a !== void 0\r\n              ? _a\r\n              : undefined,\r\n          limit:\r\n            (_b = $number(input.get(\"limit\"))) !== null && _b !== void 0\r\n              ? _b\r\n              : undefined,\r\n        };\r\n        return ((input) => {\r\n          const __is = (input) => {\r\n            const $io0 = (input) =>\r\n              (undefined === input.page ||\r\n                (\"number\" === typeof input.page &&\r\n                  Math.floor(input.page) === input.page &&\r\n                  0 <= input.page &&\r\n                  input.page <= 4294967295)) &&\r\n              (undefined === input.limit ||\r\n                (\"number\" === typeof input.limit &&\r\n                  Math.floor(input.limit) === input.limit &&\r\n                  0 <= input.limit &&\r\n                  input.limit <= 4294967295));\r\n            return (\r\n              \"object\" === typeof input &&\r\n              null !== input &&\r\n              false === Array.isArray(input) &&\r\n              $io0(input)\r\n            );\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.TypedQuery.guard;\r\n              const $ao0 = (input, _path, _exceptionable = true) =>\r\n                (undefined === input.page ||\r\n                  (\"number\" === typeof input.page &&\r\n                    ((Math.floor(input.page) === input.page &&\r\n                      0 <= input.page &&\r\n                      input.page <= 4294967295) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".page\",\r\n                        expected: 'number & Type<\"uint32\">',\r\n                        value: input.page,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".page\",\r\n                    expected: '((number & Type<\"uint32\">) | undefined)',\r\n                    value: input.page,\r\n                  })) &&\r\n                (undefined === input.limit ||\r\n                  (\"number\" === typeof input.limit &&\r\n                    ((Math.floor(input.limit) === input.limit &&\r\n                      0 <= input.limit &&\r\n                      input.limit <= 4294967295) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".limit\",\r\n                        expected: 'number & Type<\"uint32\">',\r\n                        value: input.limit,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".limit\",\r\n                    expected: '((number & Type<\"uint32\">) | undefined)',\r\n                    value: input.limit,\r\n                  }));\r\n              return (\r\n                (((\"object\" === typeof input &&\r\n                  null !== input &&\r\n                  false === Array.isArray(input)) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IPage.IRequest\",\r\n                    value: input,\r\n                  })) &&\r\n                  $ao0(input, _path + \"\", true)) ||\r\n                $guard(true, {\r\n                  path: _path + \"\",\r\n                  expected: \"IPage.IRequest\",\r\n                  value: input,\r\n                })\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        })(output);\r\n      }),\r\n    ),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object]),\r\n    __metadata(\"design:returntype\", Promise),\r\n  ],\r\n  BbsArticlesController.prototype,\r\n  \"index\",\r\n  null,\r\n);\r\nexports.BbsArticlesController = BbsArticlesController = __decorate(\r\n  [(0, common_1.Controller)(\"bbs/articles\")],\r\n  BbsArticlesController,\r\n);\nJust call @TypedQuery() function on the query parameter, that's all.Nestia will analyze your type (IPage.IRequest), and writes optimal code for the target type, in the compilation level. If you click the \"Compiled JavaScript\" file tab of above and fine enhanced lines by blue lines, you can see the optimal parsing and validation code.Such optimization is called AOT (Ahead of Time) compilation, and it is the secret of @TypedQuery.","typedquerybody#TypedQuery.Body()":"export namespace TypedQuery {\r\n  export function Body(): ParameterDecorator;\r\n}\nRequest body decorator of application/x-www-form-urlencoded format.If you call @TypedQuery.Body() decorator function on a specific parameter, the parameter will be parsed from the request body as application/x-www-form-urlencoded format. Otherwise, you want to declare a application/json format response body, use @TypedBody() decorator function instead.\nimport { tags } from \"typia\";\r\n\r\nexport interface IBbsArticle {\r\n  id: string;\r\n  writer: string;\r\n  title: string & tags.MinLength<3> & tags.MaxLength<50>;\r\n  body: string;\r\n  created_at: string & tags.Format<\"date-time\">;\r\n}\r\nexport namespace IBbsArticle {\r\n  export interface IStore {\r\n    title: string & tags.MinLength<3> & tags.MaxLength<50>;\r\n    body: string;\r\n  }\r\n}\nimport { TypedQuery } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\n\r\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  @TypedQuery.Post()\r\n  public async store(\r\n    @TypedQuery.Body() body: IBbsArticle.IStore,\r\n  ): Promise<IBbsArticle> {\r\n    return {\r\n      id: \"00000000-0000-0000-0000-000000000000\",\r\n      writer: \"Samchon\",\r\n      title: body.title,\r\n      body: body.body,\r\n      created_at: new Date().toISOString(),\r\n    };\r\n  }\r\n}\n\"use strict\";\r\nvar __decorate =\r\n  (this && this.__decorate) ||\r\n  function (decorators, target, key, desc) {\r\n    var c = arguments.length,\r\n      r =\r\n        c < 3\r\n          ? target\r\n          : desc === null\r\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\r\n          : desc,\r\n      d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\r\n      r = Reflect.decorate(decorators, target, key, desc);\r\n    else\r\n      for (var i = decorators.length - 1; i >= 0; i--)\r\n        if ((d = decorators[i]))\r\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n  };\r\nvar __metadata =\r\n  (this && this.__metadata) ||\r\n  function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\r\n      return Reflect.metadata(k, v);\r\n  };\r\nvar __param =\r\n  (this && this.__param) ||\r\n  function (paramIndex, decorator) {\r\n    return function (target, key) {\r\n      decorator(target, key, paramIndex);\r\n    };\r\n  };\r\nvar __awaiter =\r\n  (this && this.__awaiter) ||\r\n  function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) {\r\n      return value instanceof P\r\n        ? value\r\n        : new P(function (resolve) {\r\n            resolve(value);\r\n          });\r\n    }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n      function fulfilled(value) {\r\n        try {\r\n          step(generator.next(value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function rejected(value) {\r\n        try {\r\n          step(generator[\"throw\"](value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function step(result) {\r\n        result.done\r\n          ? resolve(result.value)\r\n          : adopt(result.value).then(fulfilled, rejected);\r\n      }\r\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BbsArticlesController = void 0;\r\nconst core_1 = require(\"@nestia/core\");\r\nconst common_1 = require(\"@nestjs/common\");\r\nlet BbsArticlesController = class BbsArticlesController {\r\n  store(body) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return {\r\n        id: \"00000000-0000-0000-0000-000000000000\",\r\n        writer: \"Samchon\",\r\n        title: body.title,\r\n        body: body.body,\r\n        created_at: new Date().toISOString(),\r\n      };\r\n    });\r\n  }\r\n};\r\nexports.BbsArticlesController = BbsArticlesController;\r\n__decorate(\r\n  [\r\n    core_1.TypedQuery.Post({\r\n      type: \"assert\",\r\n      assert: (input) => {\r\n        const assert = (input) => {\r\n          const __is = (input) => {\r\n            return (\r\n              \"object\" === typeof input &&\r\n              null !== input &&\r\n              \"string\" === typeof input.id &&\r\n              \"string\" === typeof input.writer &&\r\n              \"string\" === typeof input.title &&\r\n              3 <= input.title.length &&\r\n              input.title.length <= 50 &&\r\n              \"string\" === typeof input.body &&\r\n              \"string\" === typeof input.created_at &&\r\n              !isNaN(new Date(input.created_at).getTime())\r\n            );\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.TypedQuery.Post.guard;\r\n              const $ao0 = (input, _path, _exceptionable = true) =>\r\n                (\"string\" === typeof input.id ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".id\",\r\n                    expected: \"string\",\r\n                    value: input.id,\r\n                  })) &&\r\n                (\"string\" === typeof input.writer ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".writer\",\r\n                    expected: \"string\",\r\n                    value: input.writer,\r\n                  })) &&\r\n                ((\"string\" === typeof input.title &&\r\n                  (3 <= input.title.length ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MinLength<3>\",\r\n                      value: input.title,\r\n                    })) &&\r\n                  (input.title.length <= 50 ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MaxLength<50>\",\r\n                      value: input.title,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".title\",\r\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\r\n                    value: input.title,\r\n                  })) &&\r\n                (\"string\" === typeof input.body ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".body\",\r\n                    expected: \"string\",\r\n                    value: input.body,\r\n                  })) &&\r\n                ((\"string\" === typeof input.created_at &&\r\n                  (!isNaN(new Date(input.created_at).getTime()) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".created_at\",\r\n                      expected: 'string & Format<\"date-time\">',\r\n                      value: input.created_at,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".created_at\",\r\n                    expected: '(string & Format<\"date-time\">)',\r\n                    value: input.created_at,\r\n                  }));\r\n              return (\r\n                (((\"object\" === typeof input && null !== input) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IBbsArticle\",\r\n                    value: input,\r\n                  })) &&\r\n                  $ao0(input, _path + \"\", true)) ||\r\n                $guard(true, {\r\n                  path: _path + \"\",\r\n                  expected: \"IBbsArticle\",\r\n                  value: input,\r\n                })\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        };\r\n        const stringify = (input) => {\r\n          const output = new URLSearchParams();\r\n          output.append(\"id\", input.id);\r\n          output.append(\"writer\", input.writer);\r\n          output.append(\"title\", input.title);\r\n          output.append(\"body\", input.body);\r\n          output.append(\"created_at\", input.created_at);\r\n          return output;\r\n        };\r\n        return stringify(assert(input));\r\n      },\r\n    }),\r\n    __param(\r\n      0,\r\n      core_1.TypedQuery.Body({\r\n        type: \"assert\",\r\n        assert: (input) => {\r\n          const decode = (input) => {\r\n            const $params = core_1.TypedQuery.Body.params;\r\n            const $string = core_1.TypedQuery.Body.string;\r\n            input = $params(input);\r\n            const output = {\r\n              title: $string(input.get(\"title\")),\r\n              body: $string(input.get(\"body\")),\r\n            };\r\n            return output;\r\n          };\r\n          const assert = (input) => {\r\n            const __is = (input) => {\r\n              return (\r\n                \"object\" === typeof input &&\r\n                null !== input &&\r\n                \"string\" === typeof input.title &&\r\n                3 <= input.title.length &&\r\n                input.title.length <= 50 &&\r\n                \"string\" === typeof input.body\r\n              );\r\n            };\r\n            if (false === __is(input))\r\n              ((input, _path, _exceptionable = true) => {\r\n                const $guard = core_1.TypedQuery.Body.guard;\r\n                const $ao0 = (input, _path, _exceptionable = true) =>\r\n                  ((\"string\" === typeof input.title &&\r\n                    (3 <= input.title.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".title\",\r\n                        expected: \"string & MinLength<3>\",\r\n                        value: input.title,\r\n                      })) &&\r\n                    (input.title.length <= 50 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".title\",\r\n                        expected: \"string & MaxLength<50>\",\r\n                        value: input.title,\r\n                      }))) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"(string & MinLength<3> & MaxLength<50>)\",\r\n                      value: input.title,\r\n                    })) &&\r\n                  (\"string\" === typeof input.body ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".body\",\r\n                      expected: \"string\",\r\n                      value: input.body,\r\n                    }));\r\n                return (\r\n                  (((\"object\" === typeof input && null !== input) ||\r\n                    $guard(true, {\r\n                      path: _path + \"\",\r\n                      expected: \"IBbsArticle.IStore\",\r\n                      value: input,\r\n                    })) &&\r\n                    $ao0(input, _path + \"\", true)) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IBbsArticle.IStore\",\r\n                    value: input,\r\n                  })\r\n                );\r\n              })(input, \"$input\", true);\r\n            return input;\r\n          };\r\n          const output = decode(input);\r\n          return assert(output);\r\n        },\r\n      }),\r\n    ),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object]),\r\n    __metadata(\"design:returntype\", Promise),\r\n  ],\r\n  BbsArticlesController.prototype,\r\n  \"store\",\r\n  null,\r\n);\r\nexports.BbsArticlesController = BbsArticlesController = __decorate(\r\n  [(0, common_1.Controller)(\"bbs/articles\")],\r\n  BbsArticlesController,\r\n);","typedquerypost#TypedQuery.Post()":"export namespace TypedQuery {\r\n  export function Get(path?: string): MethodDecorator;\r\n  export function Post(path?: string): MethodDecorator;\r\n  export function Put(path?: string): MethodDecorator;\r\n  export function Patch(path?: string): MethodDecorator;\r\n  export function Delete(path?: string): MethodDecorator;\r\n}\nRoute decorators of application/x-www-form-urlencoded format response body.If you call one of below decorator functions on a method, the method will return application/x-www-form-urlencoded format response body. Otherwise, you want to declare a application/json format response body, use @TypedRoute.Post() decorator function instead.\n@TypedQuery.Get()\n@TypedQuery.Post()\n@TypedQuery.Put()\n@TypedQuery.Patch()\n@TypedQuery.Delete()\nimport { tags } from \"typia\";\r\n\r\nexport interface IBbsArticle {\r\n  id: string;\r\n  writer: string;\r\n  title: string & tags.MinLength<3> & tags.MaxLength<50>;\r\n  body: string;\r\n  created_at: string & tags.Format<\"date-time\">;\r\n}\r\nexport namespace IBbsArticle {\r\n  export interface IStore {\r\n    title: string & tags.MinLength<3> & tags.MaxLength<50>;\r\n    body: string;\r\n  }\r\n}\nimport { TypedQuery } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\n\r\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  @TypedQuery.Post()\r\n  public async store(\r\n    @TypedQuery.Body() body: IBbsArticle.IStore,\r\n  ): Promise<IBbsArticle> {\r\n    return {\r\n      id: \"00000000-0000-0000-0000-000000000000\",\r\n      writer: \"Samchon\",\r\n      title: body.title,\r\n      body: body.body,\r\n      created_at: new Date().toISOString(),\r\n    };\r\n  }\r\n}\n\"use strict\";\r\nvar __decorate =\r\n  (this && this.__decorate) ||\r\n  function (decorators, target, key, desc) {\r\n    var c = arguments.length,\r\n      r =\r\n        c < 3\r\n          ? target\r\n          : desc === null\r\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\r\n          : desc,\r\n      d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\r\n      r = Reflect.decorate(decorators, target, key, desc);\r\n    else\r\n      for (var i = decorators.length - 1; i >= 0; i--)\r\n        if ((d = decorators[i]))\r\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n  };\r\nvar __metadata =\r\n  (this && this.__metadata) ||\r\n  function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\r\n      return Reflect.metadata(k, v);\r\n  };\r\nvar __param =\r\n  (this && this.__param) ||\r\n  function (paramIndex, decorator) {\r\n    return function (target, key) {\r\n      decorator(target, key, paramIndex);\r\n    };\r\n  };\r\nvar __awaiter =\r\n  (this && this.__awaiter) ||\r\n  function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) {\r\n      return value instanceof P\r\n        ? value\r\n        : new P(function (resolve) {\r\n            resolve(value);\r\n          });\r\n    }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n      function fulfilled(value) {\r\n        try {\r\n          step(generator.next(value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function rejected(value) {\r\n        try {\r\n          step(generator[\"throw\"](value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function step(result) {\r\n        result.done\r\n          ? resolve(result.value)\r\n          : adopt(result.value).then(fulfilled, rejected);\r\n      }\r\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BbsArticlesController = void 0;\r\nconst core_1 = require(\"@nestia/core\");\r\nconst common_1 = require(\"@nestjs/common\");\r\nlet BbsArticlesController = class BbsArticlesController {\r\n  store(body) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return {\r\n        id: \"00000000-0000-0000-0000-000000000000\",\r\n        writer: \"Samchon\",\r\n        title: body.title,\r\n        body: body.body,\r\n        created_at: new Date().toISOString(),\r\n      };\r\n    });\r\n  }\r\n};\r\nexports.BbsArticlesController = BbsArticlesController;\r\n__decorate(\r\n  [\r\n    core_1.TypedQuery.Post({\r\n      type: \"assert\",\r\n      assert: (input) => {\r\n        const assert = (input) => {\r\n          const __is = (input) => {\r\n            return (\r\n              \"object\" === typeof input &&\r\n              null !== input &&\r\n              \"string\" === typeof input.id &&\r\n              \"string\" === typeof input.writer &&\r\n              \"string\" === typeof input.title &&\r\n              3 <= input.title.length &&\r\n              input.title.length <= 50 &&\r\n              \"string\" === typeof input.body &&\r\n              \"string\" === typeof input.created_at &&\r\n              !isNaN(new Date(input.created_at).getTime())\r\n            );\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.TypedQuery.Post.guard;\r\n              const $ao0 = (input, _path, _exceptionable = true) =>\r\n                (\"string\" === typeof input.id ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".id\",\r\n                    expected: \"string\",\r\n                    value: input.id,\r\n                  })) &&\r\n                (\"string\" === typeof input.writer ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".writer\",\r\n                    expected: \"string\",\r\n                    value: input.writer,\r\n                  })) &&\r\n                ((\"string\" === typeof input.title &&\r\n                  (3 <= input.title.length ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MinLength<3>\",\r\n                      value: input.title,\r\n                    })) &&\r\n                  (input.title.length <= 50 ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MaxLength<50>\",\r\n                      value: input.title,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".title\",\r\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\r\n                    value: input.title,\r\n                  })) &&\r\n                (\"string\" === typeof input.body ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".body\",\r\n                    expected: \"string\",\r\n                    value: input.body,\r\n                  })) &&\r\n                ((\"string\" === typeof input.created_at &&\r\n                  (!isNaN(new Date(input.created_at).getTime()) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".created_at\",\r\n                      expected: 'string & Format<\"date-time\">',\r\n                      value: input.created_at,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".created_at\",\r\n                    expected: '(string & Format<\"date-time\">)',\r\n                    value: input.created_at,\r\n                  }));\r\n              return (\r\n                (((\"object\" === typeof input && null !== input) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IBbsArticle\",\r\n                    value: input,\r\n                  })) &&\r\n                  $ao0(input, _path + \"\", true)) ||\r\n                $guard(true, {\r\n                  path: _path + \"\",\r\n                  expected: \"IBbsArticle\",\r\n                  value: input,\r\n                })\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        };\r\n        const stringify = (input) => {\r\n          const output = new URLSearchParams();\r\n          output.append(\"id\", input.id);\r\n          output.append(\"writer\", input.writer);\r\n          output.append(\"title\", input.title);\r\n          output.append(\"body\", input.body);\r\n          output.append(\"created_at\", input.created_at);\r\n          return output;\r\n        };\r\n        return stringify(assert(input));\r\n      },\r\n    }),\r\n    __param(\r\n      0,\r\n      core_1.TypedQuery.Body({\r\n        type: \"assert\",\r\n        assert: (input) => {\r\n          const decode = (input) => {\r\n            const $params = core_1.TypedQuery.Body.params;\r\n            const $string = core_1.TypedQuery.Body.string;\r\n            input = $params(input);\r\n            const output = {\r\n              title: $string(input.get(\"title\")),\r\n              body: $string(input.get(\"body\")),\r\n            };\r\n            return output;\r\n          };\r\n          const assert = (input) => {\r\n            const __is = (input) => {\r\n              return (\r\n                \"object\" === typeof input &&\r\n                null !== input &&\r\n                \"string\" === typeof input.title &&\r\n                3 <= input.title.length &&\r\n                input.title.length <= 50 &&\r\n                \"string\" === typeof input.body\r\n              );\r\n            };\r\n            if (false === __is(input))\r\n              ((input, _path, _exceptionable = true) => {\r\n                const $guard = core_1.TypedQuery.Body.guard;\r\n                const $ao0 = (input, _path, _exceptionable = true) =>\r\n                  ((\"string\" === typeof input.title &&\r\n                    (3 <= input.title.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".title\",\r\n                        expected: \"string & MinLength<3>\",\r\n                        value: input.title,\r\n                      })) &&\r\n                    (input.title.length <= 50 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".title\",\r\n                        expected: \"string & MaxLength<50>\",\r\n                        value: input.title,\r\n                      }))) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"(string & MinLength<3> & MaxLength<50>)\",\r\n                      value: input.title,\r\n                    })) &&\r\n                  (\"string\" === typeof input.body ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".body\",\r\n                      expected: \"string\",\r\n                      value: input.body,\r\n                    }));\r\n                return (\r\n                  (((\"object\" === typeof input && null !== input) ||\r\n                    $guard(true, {\r\n                      path: _path + \"\",\r\n                      expected: \"IBbsArticle.IStore\",\r\n                      value: input,\r\n                    })) &&\r\n                    $ao0(input, _path + \"\", true)) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IBbsArticle.IStore\",\r\n                    value: input,\r\n                  })\r\n                );\r\n              })(input, \"$input\", true);\r\n            return input;\r\n          };\r\n          const output = decode(input);\r\n          return assert(output);\r\n        },\r\n      }),\r\n    ),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object]),\r\n    __metadata(\"design:returntype\", Promise),\r\n  ],\r\n  BbsArticlesController.prototype,\r\n  \"store\",\r\n  null,\r\n);\r\nexports.BbsArticlesController = BbsArticlesController = __decorate(\r\n  [(0, common_1.Controller)(\"bbs/articles\")],\r\n  BbsArticlesController,\r\n);","special-tags#Special Tags":"You can enhance validation logic, of @TypedQuery(), through comment tags.You know what? @TypedQuery() utilizes typia.assert<T>() function for query data validation, and the typia.assert<T>() function supports additional type checking logics through comment tags. For reference, \"Type Tag\" means a intersection type with atomic type and special tag type of typia like number & tags.Type<\"uint32\">, and \"Comment Tag\" means a comment starting from @ symbol following @${name} ${value} format.With those type and comment tags, you can add additional validation logics. If you want to add a custom validation logic, you also can do it. Read below Guide Docments of typia, and see the example code. You may understand how to utilize such type and comment tags, in a few minutes.\ntypia > Validators > Custom Tags\nOutline\nType Tags\nComment Tags\nCustomization\nimport typia, { tags } from \"typia\";\r\n\r\nexport const checkSpecialTag = typia.createIs<SpecialTag>();\r\n\r\ninterface SpecialTag {\r\n  int32: number & tags.Type<\"int32\">;\r\n  range?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\r\n  minLength: string & tags.MinLength<3>;\r\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\r\n  date: null | (string & tags.Format<\"date\">);\r\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\r\n  uuids: Array<string & tags.Format<\"uuid\">> &\r\n    tags.MinItems<3> &\r\n    tags.MaxItems<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.checkSpecialTag = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst checkSpecialTag = (input) => {\r\n  const $io0 = (input) =>\r\n    \"number\" === typeof input.int32 &&\r\n    Math.floor(input.int32) === input.int32 &&\r\n    -2147483648 <= input.int32 &&\r\n    input.int32 <= 2147483647 &&\r\n    (undefined === input.range ||\r\n      (\"number\" === typeof input.range &&\r\n        19 < input.range &&\r\n        input.range <= 100)) &&\r\n    \"string\" === typeof input.minLength &&\r\n    3 <= input.minLength.length &&\r\n    \"string\" === typeof input.pattern &&\r\n    /^[a-z]+$/.test(input.pattern) &&\r\n    (null === input.date ||\r\n      (\"string\" === typeof input.date &&\r\n        /^(d{4})-(d{2})-(d{2})$/.test(input.date))) &&\r\n    \"string\" === typeof input.ip &&\r\n    (/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\r\n      input.ip,\r\n    ) ||\r\n      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(\r\n        input.ip,\r\n      )) &&\r\n    Array.isArray(input.uuids) &&\r\n    3 <= input.uuids.length &&\r\n    input.uuids.length <= 100 &&\r\n    input.uuids.every(\r\n      (elem) =>\r\n        \"string\" === typeof elem &&\r\n        /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n          elem,\r\n        ),\r\n    );\r\n  return \"object\" === typeof input && null !== input && $io0(input);\r\n};\r\nexports.checkSpecialTag = checkSpecialTag;","restriction#Restriction":"When using @TypedQuery(), you've to follow such restrction.At first, type of @TypedQuery() must be a pure object type. It does not allow union type. Also, nullable and undefindable types are not allowed, either. Note that, query parameter type must be a sole object type without any extra definition.At next, type of properties must be atomic, or array of atomic type. In the atomic type case, the atomic type allows both nullable and undefindable types. However, mixed union atomic type like string | number or \"1\" | \"2\" | 3 are not allowed. Also, the array type does not allow both nullable and undefindable types, either.\nboolean\nnumber\nbigint\nstring\nexport interface SomeQueryDto {\r\n  //----\r\n  // ATOMIC TYPES\r\n  //----\r\n  // ALLOWED\r\n  boolean: boolean;\r\n  number: number;\r\n  string: string;\r\n  bigint: bigint;\r\n  optional_number?: number;\r\n  nullable_string: string | null;\r\n  literal_union: \"A\" | \"B\" | \"C\" | \"D\";\r\n\r\n  // NOT ALLOWED\r\n  mixed_union: string | number | boolean;\r\n  mixed_literal: \"A\" | \"B\" | 3;\r\n\r\n  //----\r\n  // ARRAY TYPES\r\n  //----\r\n  // ALLOWED\r\n  nullable_element_array: (string | null)[];\r\n  string_array: string[];\r\n  number_array: number[];\r\n  literal_union_array: (\"A\" | \"B\" | \"C\")[];\r\n  literal_tuple: [\"A\", \"B\", \"C\"];\r\n\r\n  // NOT ALLOWED\r\n  optional_element_array: (string | undefined)[];\r\n  optional_array: string[] | undefined;\r\n  nullable_array: string[] | null;\r\n  union_atomic_array: (string | number)[];\r\n  mixed_literal_array: (\"A\", \"B\", 3)[];\r\n  mixed_tuple: [\"A\", \"B\", 3];\r\n}"}},"/docs/pure":{"title":"Pure TypeScript","data":{"outline#Outline":"nestia can use pure TypeScript type.You know what? NestJS needs triple duplicated DTO schema definitions. The 1st is defining TypeScript type, the 2nd and 3rd are calling decorator functions of class-validator and @nestjs/swagger. It's not only annoying, but also error-prone. If you take any mistake on the 2nd or 3rd, it can't be detected by TypeScript compiler. It will be detected only at runtime. Another words, it is not type safe.Besides, nestia needs only pure TypeScript type. You don't need to define any extra schema like class-validator or @nestjs/swagger. Just define pure TypeScript type only (especially recommend to use interface type), then nestia will do all the rest.","demonstration#Demonstration":"If you're confusing how DTO of NestJS and nestia are different, just see example codes below.At first, look at the first (Triple duplicated NestJS DTO) tab, and find the BbsArticle.files property, enhanced by blue coloured blocks. Looking at the files property, how do you feel? Just defining an array object type, you've to call 7 decorator functions. If you take any mistake when using the decorator like omitting isArray property, it would be a critical runtime error.Besides, nestia needs only one line. Click the second (Pure Nestia DTO) tab, and find the IAttachmentFile.files property. Only one line being used, and IBbsArticle and IAttachment types are not even class, but just interface types. Comparing it to the first tab, how do you feel? Isn't it more simple and readable?This is the power of nestia, with pure TypeScript type.\nimport { ApiProperty } from \"@nestjs/swagger\";\r\nimport {\r\n  ArrayNotEmpty,\r\n  IsArray,\r\n  IsObject,\r\n  IsOptional,\r\n  IsString,\r\n  Match,\r\n  MaxLength,\r\n  Type,\r\n  ValidateNested,\r\n} from \"class-validator\";\r\n\r\nexport class BbsArticle {\r\n  @ApiProperty({\r\n    format: \"uuid\",\r\n  })\r\n  @IsString()\r\n  id!: string;\r\n\r\n  // DUPLICATED SCHEMA DEFINITION\r\n  // - duplicated function call + property type\r\n  // - have to specify `isArray` and `nullable` props by yourself\r\n  @ApiProperty({\r\n    type: () => AttachmentFile,\r\n    nullable: true,\r\n    isArray: true,\r\n    description: \"List of attached files.\",\r\n  })\r\n  @Type(() => AttachmentFile)\r\n  @IsArray()\r\n  @IsOptional()\r\n  @IsObject({ each: true })\r\n  @ValidateNested({ each: true })\r\n  files!: AttachmentFile[] | null;\r\n\r\n  @ApiProperty({\r\n    type: \"string\",\r\n    nullable: true,\r\n    minLength: 5,\r\n    maxLength: 100,\r\n    description: \"Title of the article.\",\r\n  })\r\n  @IsOptional()\r\n  @IsString()\r\n  title!: string | null;\r\n\r\n  @ApiProperty({\r\n    description: \"Main content body of the article.\",\r\n  })\r\n  @IsString()\r\n  body!: string;\r\n\r\n  @ApiProperty({\r\n    format: \"date-time\",\r\n    description: \"Creation time of article\",\r\n  })\r\n  @IsString()\r\n  created_at!: string;\r\n}\r\n\r\nexport class AttachmentFile {\r\n  @ApiProperty({\r\n    type: \"string\",\r\n    maxLength: 255,\r\n    pattern: \"^[a-zA-Z0-9-_]+$\",\r\n    description: \"File name.\",\r\n  })\r\n  @Matches(/^[a-z0-9]+$/)\r\n  @MaxLength(255)\r\n  @IsString()\r\n  name!: string | null;\r\n\r\n  @ApiProperty({\r\n    type: \"string\",\r\n    nullable: true,\r\n    maxLength: 255,\r\n    pattern: \"^[a-zA-Z0-9-_]+$\",\r\n    description: \"File extension.\",\r\n  })\r\n  @Matches(/^[a-z0-9]+$/)\r\n  @MaxLength(8)\r\n  @IsOptional()\r\n  @IsString()\r\n  extension!: string | null;\r\n\r\n  @ApiProperty({\r\n    format: \"url\",\r\n    description: \"URL of the file.\",\r\n  })\r\n  @IsString()\r\n  url!: string;\r\n}\nimport { tags } from \"typia\";\r\n\r\nexport interface IBbsArticle {\r\n  /**\r\n   * Primary Key.\r\n   */\r\n  id: string & tags.Format<\"uuid\">;\r\n\r\n  /**\r\n   * List of attached files.\r\n   */\r\n  files: null | IAttachmentFile[];\r\n\r\n  /**\r\n   * Title of the article.\r\n   *\r\n   * @minLength 5\r\n   * @maxLength 100\r\n   */\r\n  title: null | (string & tags.MinLength<5> & tags.MaxLength<100>);\r\n\r\n  /**\r\n   * Main content body of the article.\r\n   */\r\n  body: string;\r\n\r\n  /**\r\n   * Creation time of article.\r\n   *\r\n   * @format date-time\r\n   */\r\n  created_at: string & tags.Format<\"date-time\">;\r\n}\r\n\r\nexport interface IAttachmentFile {\r\n  /**\r\n   * File name.\r\n   *\r\n   * @pattern ^[a-z0-9]+$\r\n   * @maxLength 255\r\n   */\r\n  name: string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<255>;\r\n\r\n  /**\r\n   * File extension.\r\n   */\r\n  extension: null | (string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<8>);\r\n\r\n  /**\r\n   * URL of the file.\r\n   */\r\n  url: string;\r\n}","aot-compilation#AOT Compilation":"Someone may be suspicious of the phrase \"Pure TypeScript Type\".\n\"As you know, TypeScript types do not have any tangible instance when compiled to JS.However, with only these fictitious TypeScript types, how can nestia validates types at runtime? How nestia builds swagger documents or SDK library with only these types? Are these things really possible without extra schema definition like class-validator or @nestjs/swagger?\"\nMy answer is: \"Yes, it is possible due to nestia analyzes your server code, and performs AOT compilation\".When compiling, nestia travels your NestJS server codes, and analyzes DTO definitions. And then, nestia writes optimal code to the compiled JavaScript file. In the @TypedBody() case, nestia transforms it to optimal validation code for the IBbsArticle.IStore type. Also, nestia transforms @TypedRoute.Post() function to optimal JSON serialization code for the IBbsArticle type.Such compile time optimization is called AOT (Ahead of Time) compilation. And this is the secret why nestia can do everything with only pure TypeScript type. Read below example codes, and just look how JavaScript file being compiled. Then you may understand why nestia is much easier, and futhermore much faster.\nRuntime validator is 20,000x faster than class-validator\nJSON serialization is 200x faster than class-transformer\nimport { tags } from \"typia\";\r\n\r\nexport interface IBbsArticle extends IBbsArticle.ICreate {\r\n  id: string & tags.Format<\"uuid\">;\r\n  created_at: string & tags.Format<\"date-time\">;\r\n}\r\nexport namespace IBbsArticle {\r\n  export interface ICreate {\r\n    title: string & tags.MinLength<3> & tags.MaxLength<50>;\r\n    body: string;\r\n    files: IAttachmentFile[];\r\n  }\r\n}\r\n\r\nexport interface IAttachmentFile {\r\n  name: null | (string & tags.MinLength<1> & tags.MaxLength<255>);\r\n  extension: null | (string & tags.MinLength<1> & tags.MaxLength<8>);\r\n  url: string | (string & tags.Format<\"url\">);\r\n}\nimport { TypedBody, TypedRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\n\r\nimport { IBbsArticle } from \"./IBbsArticle\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  @TypedRoute.Post() // 200x faster JSON serialization\r\n  public async store(\r\n    // 20,000x faster validation\r\n    @TypedBody() input: IBbsArticle.ICreate,\r\n  ): Promise<IBbsArticle> {\r\n    return {\r\n      ...input,\r\n      id: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\r\n      created_at: \"2023-04-23T12:04:54.168Z\",\r\n    };\r\n  }\r\n}\n\"use strict\";\r\n\"use strict\";\r\nvar __decorate =\r\n  (this && this.__decorate) ||\r\n  function (decorators, target, key, desc) {\r\n    var c = arguments.length,\r\n      r =\r\n        c < 3\r\n          ? target\r\n          : desc === null\r\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\r\n          : desc,\r\n      d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\r\n      r = Reflect.decorate(decorators, target, key, desc);\r\n    else\r\n      for (var i = decorators.length - 1; i >= 0; i--)\r\n        if ((d = decorators[i]))\r\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n  };\r\nvar __metadata =\r\n  (this && this.__metadata) ||\r\n  function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\r\n      return Reflect.metadata(k, v);\r\n  };\r\nvar __param =\r\n  (this && this.__param) ||\r\n  function (paramIndex, decorator) {\r\n    return function (target, key) {\r\n      decorator(target, key, paramIndex);\r\n    };\r\n  };\r\nvar __awaiter =\r\n  (this && this.__awaiter) ||\r\n  function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) {\r\n      return value instanceof P\r\n        ? value\r\n        : new P(function (resolve) {\r\n            resolve(value);\r\n          });\r\n    }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n      function fulfilled(value) {\r\n        try {\r\n          step(generator.next(value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function rejected(value) {\r\n        try {\r\n          step(generator[\"throw\"](value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function step(result) {\r\n        result.done\r\n          ? resolve(result.value)\r\n          : adopt(result.value).then(fulfilled, rejected);\r\n      }\r\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BbsArticlesController = void 0;\r\nconst core_1 = require(\"@nestia/core\");\r\nconst common_1 = require(\"@nestjs/common\");\r\nlet BbsArticlesController = class BbsArticlesController {\r\n  store(\r\n    // 20,000x faster validation\r\n    input,\r\n  ) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return Object.assign(Object.assign({}, input), {\r\n        id: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\r\n        created_at: \"2023-04-23T12:04:54.168Z\",\r\n      });\r\n    });\r\n  }\r\n};\r\nexports.BbsArticlesController = BbsArticlesController;\r\n__decorate(\r\n  [\r\n    core_1.TypedRoute.Post({\r\n      type: \"assert\",\r\n      assert: (input) => {\r\n        const assert = (input) => {\r\n          const __is = (input) => {\r\n            const $io0 = (input) =>\r\n              \"string\" === typeof input.id &&\r\n              /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n                input.id,\r\n              ) &&\r\n              \"string\" === typeof input.created_at &&\r\n              !isNaN(new Date(input.created_at).getTime()) &&\r\n              \"string\" === typeof input.title &&\r\n              3 <= input.title.length &&\r\n              input.title.length <= 50 &&\r\n              \"string\" === typeof input.body &&\r\n              Array.isArray(input.files) &&\r\n              input.files.every(\r\n                (elem) =>\r\n                  \"object\" === typeof elem && null !== elem && $io1(elem),\r\n              );\r\n            const $io1 = (input) =>\r\n              (null === input.name ||\r\n                (\"string\" === typeof input.name &&\r\n                  1 <= input.name.length &&\r\n                  input.name.length <= 255)) &&\r\n              (null === input.extension ||\r\n                (\"string\" === typeof input.extension &&\r\n                  1 <= input.extension.length &&\r\n                  input.extension.length <= 8)) &&\r\n              \"string\" === typeof input.url &&\r\n              /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu.test(\r\n                input.url,\r\n              );\r\n            return \"object\" === typeof input && null !== input && $io0(input);\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.TypedRoute.Post.guard;\r\n              const $ao0 = (input, _path, _exceptionable = true) =>\r\n                ((\"string\" === typeof input.id &&\r\n                  (/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n                    input.id,\r\n                  ) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".id\",\r\n                      expected: 'string & Format<\"uuid\">',\r\n                      value: input.id,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".id\",\r\n                    expected: '(string & Format<\"uuid\">)',\r\n                    value: input.id,\r\n                  })) &&\r\n                ((\"string\" === typeof input.created_at &&\r\n                  (!isNaN(new Date(input.created_at).getTime()) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".created_at\",\r\n                      expected: 'string & Format<\"date-time\">',\r\n                      value: input.created_at,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".created_at\",\r\n                    expected: '(string & Format<\"date-time\">)',\r\n                    value: input.created_at,\r\n                  })) &&\r\n                ((\"string\" === typeof input.title &&\r\n                  (3 <= input.title.length ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MinLength<3>\",\r\n                      value: input.title,\r\n                    })) &&\r\n                  (input.title.length <= 50 ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MaxLength<50>\",\r\n                      value: input.title,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".title\",\r\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\r\n                    value: input.title,\r\n                  })) &&\r\n                (\"string\" === typeof input.body ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".body\",\r\n                    expected: \"string\",\r\n                    value: input.body,\r\n                  })) &&\r\n                (((Array.isArray(input.files) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files\",\r\n                    expected: \"Array<IAttachmentFile>\",\r\n                    value: input.files,\r\n                  })) &&\r\n                  input.files.every(\r\n                    (elem, _index1) =>\r\n                      (((\"object\" === typeof elem && null !== elem) ||\r\n                        $guard(_exceptionable, {\r\n                          path: _path + \".files[\" + _index1 + \"]\",\r\n                          expected: \"IAttachmentFile\",\r\n                          value: elem,\r\n                        })) &&\r\n                        $ao1(\r\n                          elem,\r\n                          _path + \".files[\" + _index1 + \"]\",\r\n                          true && _exceptionable,\r\n                        )) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".files[\" + _index1 + \"]\",\r\n                        expected: \"IAttachmentFile\",\r\n                        value: elem,\r\n                      }),\r\n                  )) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files\",\r\n                    expected: \"Array<IAttachmentFile>\",\r\n                    value: input.files,\r\n                  }));\r\n              const $ao1 = (input, _path, _exceptionable = true) =>\r\n                (null === input.name ||\r\n                  (\"string\" === typeof input.name &&\r\n                    (1 <= input.name.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".name\",\r\n                        expected: \"string & MinLength<1>\",\r\n                        value: input.name,\r\n                      })) &&\r\n                    (input.name.length <= 255 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".name\",\r\n                        expected: \"string & MaxLength<255>\",\r\n                        value: input.name,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".name\",\r\n                    expected:\r\n                      \"((string & MinLength<1> & MaxLength<255>) | null)\",\r\n                    value: input.name,\r\n                  })) &&\r\n                (null === input.extension ||\r\n                  (\"string\" === typeof input.extension &&\r\n                    (1 <= input.extension.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".extension\",\r\n                        expected: \"string & MinLength<1>\",\r\n                        value: input.extension,\r\n                      })) &&\r\n                    (input.extension.length <= 8 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".extension\",\r\n                        expected: \"string & MaxLength<8>\",\r\n                        value: input.extension,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".extension\",\r\n                    expected: \"((string & MinLength<1> & MaxLength<8>) | null)\",\r\n                    value: input.extension,\r\n                  })) &&\r\n                ((\"string\" === typeof input.url &&\r\n                  (/^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu.test(\r\n                    input.url,\r\n                  ) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".url\",\r\n                      expected: 'string & Format<\"url\">',\r\n                      value: input.url,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".url\",\r\n                    expected: '(string & Format<\"url\">)',\r\n                    value: input.url,\r\n                  }));\r\n              return (\r\n                (((\"object\" === typeof input && null !== input) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IBbsArticle\",\r\n                    value: input,\r\n                  })) &&\r\n                  $ao0(input, _path + \"\", true)) ||\r\n                $guard(true, {\r\n                  path: _path + \"\",\r\n                  expected: \"IBbsArticle\",\r\n                  value: input,\r\n                })\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        };\r\n        const stringify = (input) => {\r\n          const $io1 = (input) =>\r\n            (null === input.name ||\r\n              (\"string\" === typeof input.name &&\r\n                1 <= input.name.length &&\r\n                input.name.length <= 255)) &&\r\n            (null === input.extension ||\r\n              (\"string\" === typeof input.extension &&\r\n                1 <= input.extension.length &&\r\n                input.extension.length <= 8)) &&\r\n            \"string\" === typeof input.url &&\r\n            /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu.test(\r\n              input.url,\r\n            );\r\n          const $string = core_1.TypedRoute.Post.string;\r\n          const $so0 = (input) =>\r\n            `{\"id\":${$string(input.id)},\"created_at\":${$string(\r\n              input.created_at,\r\n            )},\"title\":${$string(input.title)},\"body\":${$string(\r\n              input.body,\r\n            )},\"files\":${`[${input.files\r\n              .map((elem) => $so1(elem))\r\n              .join(\",\")}]`}}`;\r\n          const $so1 = (input) =>\r\n            `{\"name\":${\r\n              null !== input.name ? $string(input.name) : \"null\"\r\n            },\"extension\":${\r\n              null !== input.extension ? $string(input.extension) : \"null\"\r\n            },\"url\":${$string(input.url)}}`;\r\n          return $so0(input);\r\n        };\r\n        return stringify(assert(input));\r\n      },\r\n    }), // 200x faster JSON serialization\r\n    __param(\r\n      0,\r\n      (0, core_1.TypedBody)({\r\n        type: \"assert\",\r\n        assert: (input) => {\r\n          const __is = (input) => {\r\n            const $io0 = (input) =>\r\n              \"string\" === typeof input.title &&\r\n              3 <= input.title.length &&\r\n              input.title.length <= 50 &&\r\n              \"string\" === typeof input.body &&\r\n              Array.isArray(input.files) &&\r\n              input.files.every(\r\n                (elem) =>\r\n                  \"object\" === typeof elem && null !== elem && $io1(elem),\r\n              );\r\n            const $io1 = (input) =>\r\n              (null === input.name ||\r\n                (\"string\" === typeof input.name &&\r\n                  1 <= input.name.length &&\r\n                  input.name.length <= 255)) &&\r\n              (null === input.extension ||\r\n                (\"string\" === typeof input.extension &&\r\n                  1 <= input.extension.length &&\r\n                  input.extension.length <= 8)) &&\r\n              \"string\" === typeof input.url &&\r\n              /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu.test(\r\n                input.url,\r\n              );\r\n            return \"object\" === typeof input && null !== input && $io0(input);\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.TypedBody.guard;\r\n              const $ao0 = (input, _path, _exceptionable = true) =>\r\n                ((\"string\" === typeof input.title &&\r\n                  (3 <= input.title.length ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MinLength<3>\",\r\n                      value: input.title,\r\n                    })) &&\r\n                  (input.title.length <= 50 ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MaxLength<50>\",\r\n                      value: input.title,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".title\",\r\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\r\n                    value: input.title,\r\n                  })) &&\r\n                (\"string\" === typeof input.body ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".body\",\r\n                    expected: \"string\",\r\n                    value: input.body,\r\n                  })) &&\r\n                (((Array.isArray(input.files) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files\",\r\n                    expected: \"Array<IAttachmentFile>\",\r\n                    value: input.files,\r\n                  })) &&\r\n                  input.files.every(\r\n                    (elem, _index1) =>\r\n                      (((\"object\" === typeof elem && null !== elem) ||\r\n                        $guard(_exceptionable, {\r\n                          path: _path + \".files[\" + _index1 + \"]\",\r\n                          expected: \"IAttachmentFile\",\r\n                          value: elem,\r\n                        })) &&\r\n                        $ao1(\r\n                          elem,\r\n                          _path + \".files[\" + _index1 + \"]\",\r\n                          true && _exceptionable,\r\n                        )) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".files[\" + _index1 + \"]\",\r\n                        expected: \"IAttachmentFile\",\r\n                        value: elem,\r\n                      }),\r\n                  )) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files\",\r\n                    expected: \"Array<IAttachmentFile>\",\r\n                    value: input.files,\r\n                  }));\r\n              const $ao1 = (input, _path, _exceptionable = true) =>\r\n                (null === input.name ||\r\n                  (\"string\" === typeof input.name &&\r\n                    (1 <= input.name.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".name\",\r\n                        expected: \"string & MinLength<1>\",\r\n                        value: input.name,\r\n                      })) &&\r\n                    (input.name.length <= 255 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".name\",\r\n                        expected: \"string & MaxLength<255>\",\r\n                        value: input.name,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".name\",\r\n                    expected:\r\n                      \"((string & MinLength<1> & MaxLength<255>) | null)\",\r\n                    value: input.name,\r\n                  })) &&\r\n                (null === input.extension ||\r\n                  (\"string\" === typeof input.extension &&\r\n                    (1 <= input.extension.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".extension\",\r\n                        expected: \"string & MinLength<1>\",\r\n                        value: input.extension,\r\n                      })) &&\r\n                    (input.extension.length <= 8 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".extension\",\r\n                        expected: \"string & MaxLength<8>\",\r\n                        value: input.extension,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".extension\",\r\n                    expected: \"((string & MinLength<1> & MaxLength<8>) | null)\",\r\n                    value: input.extension,\r\n                  })) &&\r\n                ((\"string\" === typeof input.url &&\r\n                  (/^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu.test(\r\n                    input.url,\r\n                  ) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".url\",\r\n                      expected: 'string & Format<\"url\">',\r\n                      value: input.url,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".url\",\r\n                    expected: '(string & Format<\"url\">)',\r\n                    value: input.url,\r\n                  }));\r\n              return (\r\n                (((\"object\" === typeof input && null !== input) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IBbsArticle.ICreate\",\r\n                    value: input,\r\n                  })) &&\r\n                  $ao0(input, _path + \"\", true)) ||\r\n                $guard(true, {\r\n                  path: _path + \"\",\r\n                  expected: \"IBbsArticle.ICreate\",\r\n                  value: input,\r\n                })\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        },\r\n      }),\r\n    ),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object]),\r\n    __metadata(\"design:returntype\", Promise),\r\n  ],\r\n  BbsArticlesController.prototype,\r\n  \"store\",\r\n  null,\r\n);\r\nexports.BbsArticlesController = BbsArticlesController = __decorate(\r\n  [(0, common_1.Controller)(\"bbs/articles\")],\r\n  BbsArticlesController,\r\n);\r\n//# sourceMappingURL=BbsArticlesController.js.map\nMeasured on Intel i5-1135g7, Surface Pro 8"}},"/docs/sdk/e2e":{"title":"E2e","data":{"outline#Outline":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdaptor } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdaptor());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nnpx nestia e2e\r\nnpx nestia e2e --config nestia.config.ts --project tsconfig.json\nConfigure nestia.config.ts file and run npx nestia e2e command.Then, @nestia/sdk will analyze your NestJS backend server code, and generate both SDK (Software Development Kit) library for client developers. Also, E2E test functions, utilizing the SDK library, will be automatically generated for correspnding to every API functions.Here is an example of generated E2E test functions:\nimport typia, { Primitive } from \"typia\";\r\n\r\nimport api from \"../../../../src/api\";\r\nimport type { IBbsArticle } from \"../../../../src/api/structures/IBbsArticle\";\r\n\r\nexport const test_api_body_store = async (\r\n  connection: api.IConnection,\r\n): Promise<void> => {\r\n  const output = await api.functional.body.store(\r\n    connection,\r\n    typia.random<Primitive<IBbsArticle.IStore>>(),\r\n  );\r\n  typia.assert(output);\r\n};\nLeft is server code, and right is e2e test code utilizing SDK library","configuration#Configuration":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdaptor } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdaptor());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport type { INestApplication } from \"@nestjs/common\";\r\n\r\nimport type { ISwagger } from \"./structures/ISwagger\";\r\nimport type { ISwaggerInfo } from \"./structures/ISwaggerInfo\";\r\nimport type { ISwaggerSecurityScheme } from \"./structures/ISwaggerSecurityScheme\";\r\n\r\n/**\r\n * Definition for the `nestia.config.ts` file.\r\n *\r\n * @author Jeongho Nam - https://github.com/samchon\r\n */\r\nexport interface INestiaConfig {\r\n  /**\r\n   * Accessor of controller classes.\r\n   *\r\n   * You can specify it within two ways\r\n   *\r\n   *   - Asynchronous function returning `INestApplication` instance\r\n   *   - Specify the path or directory of controller class files\r\n   */\r\n  input:\r\n    | (() => Promise<INestApplication>)\r\n    | INestiaConfig.IInput\r\n    | string[]\r\n    | string;\r\n\r\n  /**\r\n   * Output directory that SDK would be placed in.\r\n   *\r\n   * If not configured, you can't build the SDK library.\r\n   */\r\n  output?: string;\r\n\r\n  /**\r\n   * Building `swagger.json` is also possible.\r\n   *\r\n   * If not specified, you can't build the `swagger.json`.\r\n   */\r\n  swagger?: INestiaConfig.ISwaggerConfig;\r\n\r\n  /**\r\n   * Target directory that SDK distribution files would be placed in.\r\n   *\r\n   * If you configure this property and runs `npx nestia sdk` command,\r\n   * distribution environments for the SDK library would be generated.\r\n   *\r\n   * After the SDK library generation, move to the `distribute` directory,\r\n   * and runs `npm publish` command, then you can share SDK library with\r\n   * other client (frontend) developers.\r\n   *\r\n   * Recommend to use `\"packages/api\"` value.\r\n   */\r\n  distribute?: string;\r\n\r\n  /**\r\n   * Allow simulation mode.\r\n   *\r\n   * If you configure this property to be `true`, the SDK library would be contain\r\n   * simulation mode. In the simulation mode, the SDK library would not communicate\r\n   * with the real backend server, but just returns random mock-up data\r\n   * with requestion data validation.\r\n   *\r\n   * For reference, random mock-up data would be generated by `typia.random<T>()`\r\n   * function.\r\n   *\r\n   * @default false\r\n   */\r\n  simulate?: boolean;\r\n\r\n  /**\r\n   * Target directory that e2e test functions would be placed in.\r\n   *\r\n   * If you configure this property and runs `npx nestia e2e` command,\r\n   * `@nestia/sdk` will analyze your NestJS backend server code, and\r\n   * generates e2e test functions for every API endpoints.\r\n   *\r\n   * If not configured, you can't run `npx nestia e2e` command.\r\n   */\r\n  e2e?: string;\r\n\r\n  /**\r\n   * Whether to use propagation mode or not.\r\n   *\r\n   * If being configured, interaction functions of the SDK library would\r\n   * perform the propagation mode. The propagation mode means that never\r\n   * throwing exception even when status code is not 200 (or 201), but just\r\n   * returning the {@link IPropagation} typed instance, which can specify its body\r\n   * type through discriminated union determined by status code.\r\n   *\r\n   * @default false\r\n   */\r\n  propagate?: boolean;\r\n\r\n  /**\r\n   * Whether to clone DTO structures or not.\r\n   *\r\n   * If being configured, all of DTOs used in the backend server would be cloned\r\n   * into the `structures` directory, and the SDK library would be refer to the\r\n   * cloned DTOs instead of the original.\r\n   *\r\n   * @default false\r\n   */\r\n  clone?: boolean;\r\n\r\n  /**\r\n   * Whether to wrap DTO by primitive type.\r\n   *\r\n   * If you don't configure this property as `false`, all of DTOs in the\r\n   * SDK library would be automatically wrapped by {@link Primitive} type.\r\n   *\r\n   * For refenrece, if a DTO type be capsuled by the {@link Primitive} type,\r\n   * all of methods in the DTO type would be automatically erased. Also, if\r\n   * the DTO has a `toJSON()` method, the DTO type would be automatically\r\n   * converted to return type of the `toJSON()` method.\r\n   *\r\n   * @default true\r\n   */\r\n  primitive?: boolean;\r\n\r\n  /**\r\n   * Whether to assert parameter types or not.\r\n   *\r\n   * If you configure this property to be `true`, all of the function\r\n   * parameters of SDK library would be checked through\r\n   * [`typia.assert<T>()` function](https://typia.io/docs/validators/assert/).\r\n   *\r\n   * This option would make your SDK library compilation time a little bit slower,\r\n   * but would enahcne the type safety even in the runtime level.\r\n   *\r\n   * @default false\r\n   */\r\n  assert?: boolean;\r\n\r\n  /**\r\n   * Whether to optimize JSON string conversion 10x faster or not.\r\n   *\r\n   * If you configure this property to be `true`, the SDK library would utilize the\r\n   * [`typia.assertStringify<T>() function`](https://github.com/samchon/typia#enhanced-json)\r\n   * to boost up JSON serialization speed and ensure type safety.\r\n   *\r\n   * This option would make your SDK library compilation time a little bit slower,\r\n   * but would enhance JSON serialization speed 10x faster. Also, it can ensure type\r\n   * safety even in the rumtime level.\r\n   *\r\n   * @default false\r\n   */\r\n  json?: boolean;\r\n}\r\nexport namespace INestiaConfig {\r\n  /**\r\n   * List of files or directories to include or exclude to specifying the NestJS\r\n   * controllers.\r\n   */\r\n  export interface IInput {\r\n    /**\r\n     * List of files or directories containing the NestJS controller classes.\r\n     */\r\n    include: string[];\r\n\r\n    /**\r\n     * List of files or directories to be excluded.\r\n     */\r\n    exclude?: string[];\r\n  }\r\n\r\n  /**\r\n   * Building `swagger.json` is also possible.\r\n   */\r\n  export interface ISwaggerConfig {\r\n    /**\r\n     * Output path of the `swagger.json`.\r\n     *\r\n     * If you've configured only directory, the file name would be the `swagger.json`.\r\n     * Otherwise you've configured the full path with file name and extension, the\r\n     * `swagger.json` file would be renamed to it.\r\n     */\r\n    output: string;\r\n\r\n    /**\r\n     * API information.\r\n     *\r\n     * If omitted, `package.json` content would be used instead.\r\n     */\r\n    info?: Partial<ISwaggerInfo>;\r\n\r\n    /**\r\n     * List of server addresses.\r\n     */\r\n    servers?: ISwagger.IServer[];\r\n\r\n    /**\r\n     * Security schemes.\r\n     *\r\n     * When generating `swagger.json` file through `nestia`, if your controllers or\r\n     * theirs methods have a security key which is not enrolled in here property,\r\n     * it would be an error.\r\n     */\r\n    security?: Record<string, ISwaggerSecurityScheme>;\r\n\r\n    /**\r\n     * Decompose query DTO.\r\n     *\r\n     * If you configure this property to be `true`, the query DTO would be decomposed\r\n     * into individual query parameters per each property.\r\n     *\r\n     * @default false\r\n     */\r\n    decompose?: boolean;\r\n\r\n    operationId?(props: {\r\n      class: string;\r\n      function: string;\r\n      method: \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\r\n      path: string;\r\n    }): string;\r\n  }\r\n}\nMake nestia.config.ts file and run npx nestia e2e command.At first, create nestia.config.ts file through npx nestia init command. It would be placed on the top level directory of your NestJS backend project. For reference, tsconfig.json file also must be placed in the top level directory, too. After creation, configure the nestia.config.ts file referencing above example code and type definition.At least, you've to configure those three properties:\ninput: Accessor of controller classes\noutput: Path of output directory for SDK library\ne2e: Path of output directory for E2E test functions\nWhen you've completed above configuration, just run npx nestia e2e command. Then, SDK library would be generated into the $config.output directory, and E2E test functions would be generated into the $config.e2e directory, following your nestia.config.ts option.By the way, nestia.config.ts supports alternative options specifying the target controller classes instead of using the Module instance. If your backend application server does not have special configuration like setGlobalPrefix, enableVersioning and RouterModule, it is okay to specifying the target controller classes just by writing their file path like below.\nimport { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\nimport { FastifyAdaptor } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule, new FastifyAdaptor());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: [\"src/controllers\", \"src/fake/controllers\", \"src/test/controllers\"],\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: \"src/**/*.controller.ts\",\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: {\r\n    include: [\"src/controllers\"],\r\n    exclude: [\"src/**/*.fake.ts\"],\r\n  },\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;","customization#Customization":"import core from \"@nestia/core\";\r\nimport { DynamicExecutor } from \"@nestia/e2e\";\r\n\r\nimport { INestApplication } from \"@nestjs/common\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n\r\nasync function main(): Promise<void> {\r\n  const server: INestApplication = await NestFactory.create(\r\n    await core.DynamicModule.mount({\r\n      // follows your nestia.config.ts setting\r\n      controllers: {\r\n        input: [\"src/controllers\"],\r\n        exclude: [\"src/**/*.fake.ts\"],\r\n      },\r\n    }),\r\n  );\r\n  await server.listen(37_000);\r\n\r\n  const report: DynamicExecutor.IReport = await DynamicExecutor.validate({\r\n    prefix: \"test\",\r\n    parameters: () => [\r\n      {\r\n        host: \"http://127.0.0.1:37000\",\r\n      },\r\n    ],\r\n  })(`${__dirname}/features`);\r\n  await server.close();\r\n\r\n  const exceptions: Error[] = report.executions\r\n    .filter((exec) => exec.error !== null)\r\n    .map((exec) => exec.error!);\r\n  if (exceptions.length === 0) {\r\n    console.log(\"Success\");\r\n    console.log(\"Elapsed time\", report.time.toLocaleString(), `ms`);\r\n  } else {\r\n    for (const exp of exceptions) console.log(exp);\r\n    console.log(\"Failed\");\r\n    console.log(\"Elapsed time\", report.time.toLocaleString(), `ms`);\r\n    process.exit(-1);\r\n  }\r\n}\r\nmain().catch((exp) => {\r\n  console.log(exp);\r\n  process.exit(-1);\r\n});\nNothing be specified, customize by yourself.When you generate e2e test functions through npx nestia e2e command, such index.ts file would be placed into the top level directory of test program. As you can see, the initial e2e test program only opens your NestJS backend server only with path of controllers with port number 37,000.However, it may not fully meet your requirements. For example, you may connect to a database server, and also need to configure DI (Dependency Injection) classes, too. You've to configure those things by yourself. @nestia/sdk can analyzes your backend server in the compilation level, but unable to reproduce such customizations.\nimport { Controller } from \"@nestjs/common\";\r\nimport typia, { tags } from \"typia\";\r\n\r\nimport core from \"@nestia/core\";\r\n\r\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\r\n\r\n@Controller(\"bbs/articles/:section\")\r\nexport class BbsArticlesController {\r\n  /**\r\n   * Store a new article.\r\n   *\r\n   * @param section Section code\r\n   * @param input Content to store\r\n   * @returns Newly archived article\r\n   */\r\n  @core.TypedRoute.Post()\r\n  public async store(\r\n    @core.TypedParam(\"section\") section: string,\r\n    @core.TypedBody() input: IBbsArticle.IStore,\r\n  ): Promise<IBbsArticle> {\r\n    return {\r\n      ...typia.random<IBbsArticle>(),\r\n      section,\r\n      ...input,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Update an article.\r\n   *\r\n   * @param section Section code\r\n   * @param id Target article ID\r\n   * @param input Content to update\r\n   * @returns Updated content\r\n   */\r\n  @core.TypedRoute.Put(\":id\")\r\n  public async update(\r\n    @core.TypedParam(\"section\") section: string,\r\n    @core.TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\r\n    @core.TypedBody() input: IBbsArticle.IStore,\r\n  ): Promise<IBbsArticle> {\r\n    return {\r\n      ...typia.random<IBbsArticle>(),\r\n      id,\r\n      section,\r\n      ...input,\r\n    };\r\n  }\r\n}\n/**\r\n * @packageDocumentation\r\n * @module api.functional.bbs.articles\r\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\r\n */\r\n//================================================================\r\nimport type { IConnection, Primitive } from \"@nestia/fetcher\";\r\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\r\nimport type { Format } from \"typia/lib/tags/Format\";\r\n\r\nimport type { IBbsArticle } from \"../../../structures/IBbsArticle\";\r\n\r\n/**\r\n * Store a new article.\r\n *\r\n * @param section Section code\r\n * @param input Content to store\r\n * @returns Newly archived article\r\n *\r\n * @controller [object Object]\r\n * @path POST /bbs/articles/:section\r\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\r\n */\r\nexport async function store(\r\n  connection: IConnection,\r\n  section: string,\r\n  input: store.Input,\r\n): Promise<store.Output> {\r\n  return PlainFetcher.fetch(\r\n    {\r\n      ...connection,\r\n      headers: {\r\n        ...connection.headers,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n    },\r\n    {\r\n      ...store.METADATA,\r\n      path: store.path(section),\r\n    } as const,\r\n    input,\r\n  );\r\n}\r\nexport namespace store {\r\n  export type Input = Primitive<IBbsArticle.IStore>;\r\n  export type Output = Primitive<IBbsArticle>;\r\n\r\n  export const METADATA = {\r\n    method: \"POST\",\r\n    path: \"/bbs/articles/:section\",\r\n    request: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    response: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    status: null,\r\n  } as const;\r\n\r\n  export const path = (section: string): string => {\r\n    return `/bbs/articles/${encodeURIComponent(section ?? \"null\")}`;\r\n  };\r\n}\r\n\r\n/**\r\n * Update an article.\r\n *\r\n * @param section Section code\r\n * @param id Target article ID\r\n * @param input Content to update\r\n * @returns Updated content\r\n *\r\n * @controller [object Object]\r\n * @path PUT /bbs/articles/:section/:id\r\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\r\n */\r\nexport async function update(\r\n  connection: IConnection,\r\n  section: string,\r\n  id: string & Format<\"uuid\">,\r\n  input: update.Input,\r\n): Promise<update.Output> {\r\n  return PlainFetcher.fetch(\r\n    {\r\n      ...connection,\r\n      headers: {\r\n        ...connection.headers,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n    },\r\n    {\r\n      ...update.METADATA,\r\n      path: update.path(section, id),\r\n    } as const,\r\n    input,\r\n  );\r\n}\r\nexport namespace update {\r\n  export type Input = Primitive<IBbsArticle.IStore>;\r\n  export type Output = Primitive<IBbsArticle>;\r\n\r\n  export const METADATA = {\r\n    method: \"PUT\",\r\n    path: \"/bbs/articles/:section/:id\",\r\n    request: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    response: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    status: null,\r\n  } as const;\r\n\r\n  export const path = (\r\n    section: string,\r\n    id: string & Format<\"uuid\">,\r\n  ): string => {\r\n    return `/bbs/articles/${encodeURIComponent(\r\n      section ?? \"null\",\r\n    )}/${encodeURIComponent(id ?? \"null\")}`;\r\n  };\r\n}\nimport type { IConnection, Primitive } from \"@nestia/fetcher\";\r\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\r\nimport type { Format } from \"typia/lib/tags/Format\";\r\n\r\nimport api from \"../../../../src/api\";\r\nimport type { IBbsArticle } from \"../../../../src/api/structures/IBbsArticle\";\r\n\r\nexport const test_api_bbs_articles_update = async (\r\n  connection: api.IConnection,\r\n): Promise<void> => {\r\n  const output = await api.functional.bbs.articles.update(\r\n    connection,\r\n    typia.random<string>(),\r\n    typia.random<string & Format<\"uuid\">>(),\r\n    typia.random<Primitive<IBbsArticle.IStore>>(),\r\n  );\r\n  typia.assert(output);\r\n};\nYou also need to customize each e2e test functions.When you run npx nestia e2e command, every e2e functions would be placed into $config.e2e/features/api/automated directory. Also, automatically generated e2e test functions are composing parameters through typia.random<T>() function.If your NestJS backend server development has not been completed, and your API functions are in the mock-up level, such random parameter composition would not be problem. Otherwise your API functions are enoughly completed, such random parameter composition may occur logic error.Therefore, you also need to customize automatically generated e2e test functions. Move each e2e test files from the $config.e2e/features/api/automated directory to somewhere else, and customize those e2e test functions to be suitable for your domain logics."}},"/docs/sdk/sdk":{"title":"Sdk","data":{"outline#Outline":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdaptor } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdaptor());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n};\r\nexport default NESTIA_CONFIG;\nnpx nestia sdk\r\nnpx nestia sdk --config nestia.config.ts --project tsconfig.json\n/**\r\n * Update an article.\r\n *\r\n * @param section Section code\r\n * @param id Target article ID\r\n * @param input Content to update\r\n * @returns Updated content\r\n *\r\n * @controller BbsArticlesController.update()\r\n * @path PUT /bbs/:section/articles/:id\r\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\r\n */\r\nexport async function update(\r\n  connection: IConnection,\r\n  section: string,\r\n  id: string & Format<\"uuid\">,\r\n  input: update.Input,\r\n): Promise<update.Output> {\r\n  return PlainFetcher.fetch(\r\n    {\r\n      ...connection,\r\n      headers: {\r\n        ...connection.headers,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n    },\r\n    {\r\n      ...update.METADATA,\r\n      path: update.path(section, id),\r\n    } as const,\r\n    input,\r\n  );\r\n}\r\nexport namespace update {\r\n  export type Input = Primitive<IBbsArticle.IStore>;\r\n  export type Output = Primitive<IBbsArticle>;\r\n\r\n  export const METADATA = {\r\n    method: \"PUT\",\r\n    path: \"/bbs/articles/:section/:id\",\r\n    request: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    response: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    status: null,\r\n  } as const;\r\n\r\n  export const path = (\r\n    section: string,\r\n    id: string & Format<\"uuid\">,\r\n  ): string => {\r\n    return `/bbs/articles/${encodeURIComponent(\r\n      section ?? \"null\",\r\n    )}/${encodeURIComponent(id ?? \"null\")}`;\r\n  };\r\n}\nCollection of typed fetch functions with DTO structures.Configure nestia.config.ts file and run npx nestia sdk command. Then, @nestia/sdk will analyze your NestJS backend server code, and generate SDK (Software Development Kit) library. The newly generated SDK library would be composed with DTO and fetch functions with type definitions following your NestJS server.With the SDK library, you can easily develop e2e test program. Also, frontend developers can utilize the SDK library to interact with your NestJS backend server, much safely and conveniently. If you can't imagine how the SDK library works, then look at the gif image of below. Left side is the NestJS backend server program, and right side is the Frontend program interacting with your server.Isn't it look like much more convenient and safer than before when using Swagger Documents?\nLeft is NestJS server code, and right is client (frontend) code utilizing SDK","configuration#Configuration":"","nestiaconfigts#nestia.config.ts":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdaptor } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdaptor());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport type { INestApplication } from \"@nestjs/common\";\r\n\r\nimport type { ISwagger } from \"./structures/ISwagger\";\r\nimport type { ISwaggerInfo } from \"./structures/ISwaggerInfo\";\r\nimport type { ISwaggerSecurityScheme } from \"./structures/ISwaggerSecurityScheme\";\r\n\r\n/**\r\n * Definition for the `nestia.config.ts` file.\r\n *\r\n * @author Jeongho Nam - https://github.com/samchon\r\n */\r\nexport interface INestiaConfig {\r\n  /**\r\n   * Accessor of controller classes.\r\n   *\r\n   * You can specify it within two ways\r\n   *\r\n   *   - Asynchronous function returning `INestApplication` instance\r\n   *   - Specify the path or directory of controller class files\r\n   */\r\n  input:\r\n    | (() => Promise<INestApplication>)\r\n    | INestiaConfig.IInput\r\n    | string[]\r\n    | string;\r\n\r\n  /**\r\n   * Output directory that SDK would be placed in.\r\n   *\r\n   * If not configured, you can't build the SDK library.\r\n   */\r\n  output?: string;\r\n\r\n  /**\r\n   * Building `swagger.json` is also possible.\r\n   *\r\n   * If not specified, you can't build the `swagger.json`.\r\n   */\r\n  swagger?: INestiaConfig.ISwaggerConfig;\r\n\r\n  /**\r\n   * Target directory that SDK distribution files would be placed in.\r\n   *\r\n   * If you configure this property and runs `npx nestia sdk` command,\r\n   * distribution environments for the SDK library would be generated.\r\n   *\r\n   * After the SDK library generation, move to the `distribute` directory,\r\n   * and runs `npm publish` command, then you can share SDK library with\r\n   * other client (frontend) developers.\r\n   *\r\n   * Recommend to use `\"packages/api\"` value.\r\n   */\r\n  distribute?: string;\r\n\r\n  /**\r\n   * Allow simulation mode.\r\n   *\r\n   * If you configure this property to be `true`, the SDK library would be contain\r\n   * simulation mode. In the simulation mode, the SDK library would not communicate\r\n   * with the real backend server, but just returns random mock-up data\r\n   * with requestion data validation.\r\n   *\r\n   * For reference, random mock-up data would be generated by `typia.random<T>()`\r\n   * function.\r\n   *\r\n   * @default false\r\n   */\r\n  simulate?: boolean;\r\n\r\n  /**\r\n   * Target directory that e2e test functions would be placed in.\r\n   *\r\n   * If you configure this property and runs `npx nestia e2e` command,\r\n   * `@nestia/sdk` will analyze your NestJS backend server code, and\r\n   * generates e2e test functions for every API endpoints.\r\n   *\r\n   * If not configured, you can't run `npx nestia e2e` command.\r\n   */\r\n  e2e?: string;\r\n\r\n  /**\r\n   * Whether to use propagation mode or not.\r\n   *\r\n   * If being configured, interaction functions of the SDK library would\r\n   * perform the propagation mode. The propagation mode means that never\r\n   * throwing exception even when status code is not 200 (or 201), but just\r\n   * returning the {@link IPropagation} typed instance, which can specify its body\r\n   * type through discriminated union determined by status code.\r\n   *\r\n   * @default false\r\n   */\r\n  propagate?: boolean;\r\n\r\n  /**\r\n   * Whether to clone DTO structures or not.\r\n   *\r\n   * If being configured, all of DTOs used in the backend server would be cloned\r\n   * into the `structures` directory, and the SDK library would be refer to the\r\n   * cloned DTOs instead of the original.\r\n   *\r\n   * @default false\r\n   */\r\n  clone?: boolean;\r\n\r\n  /**\r\n   * Whether to wrap DTO by primitive type.\r\n   *\r\n   * If you don't configure this property as `false`, all of DTOs in the\r\n   * SDK library would be automatically wrapped by {@link Primitive} type.\r\n   *\r\n   * For refenrece, if a DTO type be capsuled by the {@link Primitive} type,\r\n   * all of methods in the DTO type would be automatically erased. Also, if\r\n   * the DTO has a `toJSON()` method, the DTO type would be automatically\r\n   * converted to return type of the `toJSON()` method.\r\n   *\r\n   * @default true\r\n   */\r\n  primitive?: boolean;\r\n\r\n  /**\r\n   * Whether to assert parameter types or not.\r\n   *\r\n   * If you configure this property to be `true`, all of the function\r\n   * parameters of SDK library would be checked through\r\n   * [`typia.assert<T>()` function](https://typia.io/docs/validators/assert/).\r\n   *\r\n   * This option would make your SDK library compilation time a little bit slower,\r\n   * but would enahcne the type safety even in the runtime level.\r\n   *\r\n   * @default false\r\n   */\r\n  assert?: boolean;\r\n\r\n  /**\r\n   * Whether to optimize JSON string conversion 10x faster or not.\r\n   *\r\n   * If you configure this property to be `true`, the SDK library would utilize the\r\n   * [`typia.assertStringify<T>() function`](https://github.com/samchon/typia#enhanced-json)\r\n   * to boost up JSON serialization speed and ensure type safety.\r\n   *\r\n   * This option would make your SDK library compilation time a little bit slower,\r\n   * but would enhance JSON serialization speed 10x faster. Also, it can ensure type\r\n   * safety even in the rumtime level.\r\n   *\r\n   * @default false\r\n   */\r\n  json?: boolean;\r\n}\r\nexport namespace INestiaConfig {\r\n  /**\r\n   * List of files or directories to include or exclude to specifying the NestJS\r\n   * controllers.\r\n   */\r\n  export interface IInput {\r\n    /**\r\n     * List of files or directories containing the NestJS controller classes.\r\n     */\r\n    include: string[];\r\n\r\n    /**\r\n     * List of files or directories to be excluded.\r\n     */\r\n    exclude?: string[];\r\n  }\r\n\r\n  /**\r\n   * Building `swagger.json` is also possible.\r\n   */\r\n  export interface ISwaggerConfig {\r\n    /**\r\n     * Output path of the `swagger.json`.\r\n     *\r\n     * If you've configured only directory, the file name would be the `swagger.json`.\r\n     * Otherwise you've configured the full path with file name and extension, the\r\n     * `swagger.json` file would be renamed to it.\r\n     */\r\n    output: string;\r\n\r\n    /**\r\n     * API information.\r\n     *\r\n     * If omitted, `package.json` content would be used instead.\r\n     */\r\n    info?: Partial<ISwaggerInfo>;\r\n\r\n    /**\r\n     * List of server addresses.\r\n     */\r\n    servers?: ISwagger.IServer[];\r\n\r\n    /**\r\n     * Security schemes.\r\n     *\r\n     * When generating `swagger.json` file through `nestia`, if your controllers or\r\n     * theirs methods have a security key which is not enrolled in here property,\r\n     * it would be an error.\r\n     */\r\n    security?: Record<string, ISwaggerSecurityScheme>;\r\n\r\n    /**\r\n     * Decompose query DTO.\r\n     *\r\n     * If you configure this property to be `true`, the query DTO would be decomposed\r\n     * into individual query parameters per each property.\r\n     *\r\n     * @default false\r\n     */\r\n    decompose?: boolean;\r\n\r\n    operationId?(props: {\r\n      class: string;\r\n      function: string;\r\n      method: \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\r\n      path: string;\r\n    }): string;\r\n  }\r\n}\nMake nestia.config.ts file and run npx nestia sdk command.At first, create nestia.config.ts file through npx nestia init command. It would be placed on the top level directory of your NestJS backend project. For reference, tsconfig.json file also must be placed in the top level directory, too. After creation, configure the nestia.config.ts file referencing above example code and type definition.At least, you've to configure those two properties:\ninput: Accessor of controller classes\noutput: Path of output directory for SDK library\nWhen you've completed above configuration, just run npx nestia sdk command. Then, SDK library would be newly generated, and placed into the $config.output directory following your nestia.config.ts configuration.","input-pattern#Input Pattern":"nestia.config.ts supports alternative options instead of using the Module instance.If your backend application server does not have special configuration like setGlobalPrefix, enableVersioning and RouterModule, it is okay to specifying the target controller classes just by writing their file path like below.\nimport { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\nimport { FastifyAdaptor } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule, new FastifyAdaptor());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: [\"src/controllers\", \"src/fake/controllers\", \"src/test/controllers\"],\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: \"src/**/*.controller.ts\",\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: {\r\n    include: [\"src/controllers\"],\r\n    exclude: [\"src/**/*.fake.ts\"],\r\n  },\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n};\r\nexport default NESTIA_CONFIG;","clone-mode#Clone Mode":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdaptor } from \"@nestjs/platform-fastify\";\r\n \r\nimport { YourModule } from \"./src/YourModule\";\r\n \r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdaptor());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  clone: true,\r\n  distribute: \"packages/api\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport core from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport typia, { tags } from \"typia\";\r\n\r\n@Controller(\"bbs/articles/:section\")\r\nexport class TypedBodyControlleer {\r\n  @core.TypedRoute.Get()\r\n  public async index(\r\n    @core.TypedParam(\"section\") section: string,\r\n    @core.TypedQuery() query: IPage.IRequest,\r\n  ): Promise<IPage<IBbsArticle.ISummary>> {\r\n    const limit: number = query.limit ?? 100;\r\n    const current: number = query.page ?? 1;\r\n    const records: number = limit * (current + 3) + 5;\r\n\r\n    return {\r\n      pagination: {\r\n        current,\r\n        limit,\r\n        records,\r\n        pages: Math.ceil(records / limit),\r\n      },\r\n      data: new Array(limit).fill(\"\").map(() => ({\r\n        ...typia.random<IBbsArticle.ISummary>(),\r\n        section,\r\n      })),\r\n    };\r\n  }\r\n}\r\ninterface IPage<T> {\r\n  data: T[];\r\n  pagination: IPage.IPagination;\r\n}\r\nnamespace IPage {\r\n  export interface IRequest {\r\n    page?: null | (number & tags.Type<\"uint32\">);\r\n    limit?: null | (number & tags.Type<\"uint32\">);\r\n  }\r\n  export interface IPagination {\r\n    current: number & tags.Type<\"uint32\">;\r\n    limit: number & tags.Type<\"uint32\">;\r\n    records: number & tags.Type<\"uint32\">;\r\n    pages: number & tags.Type<\"uint32\">;\r\n  }\r\n}\r\n\r\nnamespace IBbsArticle {\r\n  export interface ISummary {\r\n    id: string & tags.Format<\"uuid\">;\r\n    section: string;\r\n    writer: string;\r\n    title: string & tags.MinLength<3> & tags.MaxLength<50>;\r\n    created_at: string & tags.Format<\"date-time\">;\r\n    /**\r\n     * @format date-time\r\n     */\r\n    updated_at: string;\r\n  }\r\n}\nexport namespace IPageIBbsArticle {\r\n  export type ISummary = {\r\n    data: IBbsArticle.ISummary[];\r\n    pagination: IPage.IPagination;\r\n  };\r\n}\r\nexport namespace IPage {\r\n  export type IRequest = {\r\n    page?: null | undefined | (number & Type<\"uint32\">);\r\n    limit?: null | undefined | (number & Type<\"uint32\">);\r\n  };\r\n  export type IPagination = {\r\n    current: number & Type<\"uint32\">;\r\n    limit: number & Type<\"uint32\">;\r\n    records: number & Type<\"uint32\">;\r\n    pages: number & Type<\"uint32\">;\r\n  };\r\n}\r\n\r\nexport namespace IBbsArticle {\r\n  export type ISummary = {\r\n    id: string & Format<\"uuid\">;\r\n    section: string;\r\n    writer: string;\r\n    title: string & MinLength<3> & MaxLength<50>;\r\n    created_at: string & Format<\"date-time\">;\r\n    updated_at: string & Format<\"date-time\">;\r\n  };\r\n}\nIf you configure clone property to be true in the nestia.config.ts file, all of DTO structures used in the backend server would be cloned into the structures directory, and the SDK library would be refer to the cloned DTO structures instead of the original.This clone mode is useful when you'd not separated DTO structures from the ORM models. When you're using TypeORM or Prisma, and returning the ORM generated instance directly in the controller without independent DTO structure definition, your SDK library requires the TypeORM or Prisma dependency install. By the dependency, client (frontend) developers may install the ORM library that they never need.In that case, it would better to remove the dependency by using this clone mode.","propagation-mode#Propagation Mode":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdaptor } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst config: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdaptor());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  propagate: true,\r\n  distribute: \"packages/api\",\r\n};\r\nexport default config;\nimport { Primitive } from \"./Primitive\";\r\n\r\n/**\r\n * Propagation type.\r\n *\r\n * `IPropagation` is a type gathering all possible status codes and their body\r\n * data types as a discriminated union type. You can specify the status code and\r\n * its body data type just by using conditional statement like below.\r\n *\r\n * ```typescript\r\n * type Output = IPropagation<{\r\n *    200: ISeller.IAuthorized;\r\n *    400: TypeGuardError.IProps;\r\n * >};\r\n *\r\n * const output: Output = await sdk.sellers.authenticate.join(input);\r\n * if (output.success) {\r\n *     // automatically casted to \"ISeller.IAuthorized\" type\r\n *     const authorized: ISeller.IAuthorized = output.data;\r\n * } else if (output.status === 400) {\r\n *     // automatically casted to \"TypeGuardError.IProps\" type\r\n *     const error: TypeGuardError.IProps = output.data;\r\n * } else {\r\n *     // unknown type when out of pre-defined status codes\r\n *     const result: unknown = output.data;\r\n * }\r\n * ```\r\n *\r\n * For reference, this `IPropagation` type is utilized by SDK library generated by\r\n * `@nestia/sdk`, when you've configured {@link INestiaConfig.propagate} to be `true`.\r\n * In that case, SDK functions generated by `@nestia/sdk` no more returns response DTO\r\n * typed data directly, but returns this `IPropagation` typed object instead.\r\n *\r\n * @template StatusMap Map of status code and its body data type.\r\n * @template Success Default success status code.\r\n * @author Jeongho Nam - https://github.com/samchon\r\n */\r\nexport type IPropagation<\r\n  StatusMap extends {\r\n    [P in IPropagation.Status]?: any;\r\n  },\r\n  Success extends number = 200 | 201,\r\n> =\r\n  | {\r\n      [P in keyof StatusMap]: IPropagation.IBranch<\r\n        P extends Success ? true : false,\r\n        P,\r\n        StatusMap[P]\r\n      >;\r\n    }[keyof StatusMap]\r\n  | IPropagation.IBranch<false, unknown, unknown>;\r\nexport namespace IPropagation {\r\n  /**\r\n   * Type of configurable status codes.\r\n   *\r\n   * The special characters like `2XX`, `3XX`, `4XX`, `5XX` are meaning the range\r\n   * of status codes. If `5XX` is specified, it means the status code is in the\r\n   * range of `500` to `599`.\r\n   */\r\n  export type Status = number | \"2XX\" | \"3XX\" | \"4XX\" | \"5XX\";\r\n\r\n  /**\r\n   * Branch type of propagation.\r\n   *\r\n   * `IPropagation.IBranch` is a branch type composing `IPropagation` type,\r\n   * which is gathering all possible status codes and their body data types\r\n   * as a union type.\r\n   */\r\n  export interface IBranch<Success extends boolean, StatusValue, BodyData> {\r\n    success: Success;\r\n    status: StatusValue extends \"2XX\" | \"3XX\" | \"4XX\" | \"5XX\"\r\n      ? StatusRange<StatusValue>\r\n      : StatusValue extends number\r\n      ? StatusValue\r\n      : never;\r\n    data: Primitive<BodyData>;\r\n    headers: Record<string, string | string[]>;\r\n  }\r\n\r\n  /**\r\n   * Range of status codes by the first digit.\r\n   */\r\n  export type StatusRange<T extends \"2XX\" | \"3XX\" | \"4XX\" | \"5XX\"> = T extends 0\r\n    ? IntRange<200, 299>\r\n    : T extends 3\r\n    ? IntRange<300, 399>\r\n    : T extends 4\r\n    ? IntRange<400, 499>\r\n    : IntRange<500, 599>;\r\n\r\n  type IntRange<F extends number, T extends number> = Exclude<\r\n    Enumerate<T>,\r\n    Enumerate<F>\r\n  >;\r\n\r\n  type Enumerate<\r\n    N extends number,\r\n    Acc extends number[] = [],\r\n  > = Acc[\"length\"] extends N\r\n    ? Acc[number]\r\n    : Enumerate<N, [...Acc, Acc[\"length\"]]>;\r\n}\nReturns IPropagation typed instance instead of throwing exception.When you configure propagate property of nestia.config.ts file, all of SDK functions generated by @nestia/sdk will perform propagation mode. The propagation mode means that never throwing exception (HttpError) even when response status code is not 200 (or 201), but just returning the IPropagation typed object, which can specify its body data type through discriminated union determined by status code.Looking at below code tabs one by one, then you may understand exactly, what the propagation mode is. As you can see from below example code, @TypedException() decorator function can be utilized to define the failure type with specific status code. Also, if returned status code is out of pre-defined, the IPropagation.data type would be automatically casted to unknown type.\nimport core from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport typia, { tags } from \"typia\";\r\n\r\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\r\n\r\n@Controller(\"bbs/articles/:section\")\r\nexport class BbsArticlesController {\r\n  /**\r\n   * Update an article.\r\n   *\r\n   * @param section Section code\r\n   * @param id Target article ID\r\n   * @param input Content to update\r\n   * @returns Updated content\r\n   */\r\n  @core.TypedException<TypeGuardError.IProps>(400)\r\n  @core.TypedRoute.Put(\":id\")\r\n  public async update(\r\n    @core.TypedParam(\"section\") section: string,\r\n    @core.TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\r\n    @core.TypedBody() input: IBbsArticle.IStore,\r\n  ): Promise<IBbsArticle> {\r\n    return {\r\n      ...typia.random<IBbsArticle>(),\r\n      id,\r\n      section,\r\n      ...input,\r\n    };\r\n  }\r\n}\n/**\r\n * Update an article.\r\n *\r\n * @param section Section code\r\n * @param id Target article ID\r\n * @param input Content to update\r\n * @returns Updated content\r\n *\r\n * @controller BbsArticlesController.update()\r\n * @path PUT /bbs/:section/articles/:id\r\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\r\n */\r\nexport async function update(\r\n  connection: IConnection,\r\n  section: string,\r\n  id: string & Format<\"uuid\">,\r\n  input: update.Input,\r\n): Promise<update.Output> {\r\n  return PlainFetcher.propagate(\r\n    {\r\n      ...connection,\r\n      headers: {\r\n        ...connection.headers,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n    },\r\n    {\r\n      ...update.METADATA,\r\n      path: update.path(section, id),\r\n    } as const,\r\n    input,\r\n  );\r\n}\r\nexport namespace update {\r\n  export type Input = Primitive<IBbsArticle.IStore>;\r\n  export type Output = IPropagation<\r\n    {\r\n      200: IBbsArticle;\r\n      400: TypeGuardError.IProps;\r\n    },\r\n    200\r\n  >;\r\n\r\n  export const METADATA = {\r\n    method: \"PUT\",\r\n    path: \"/bbs/articles/:section/:id\",\r\n    request: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    response: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    status: null,\r\n  } as const;\r\n\r\n  export const path = (\r\n    section: string,\r\n    id: string & Format<\"uuid\">,\r\n  ): string => {\r\n    return `/bbs/articles/${encodeURIComponent(\r\n      section ?? \"null\",\r\n    )}/${encodeURIComponent(id ?? \"null\")}`;\r\n  };\r\n}\nconst output = await api.functional.bbs.articles.update(section, id, input);\r\nif (output.success) {\r\n  // automatically casted to \"IBbsArticle\" when status 200 (success)\r\n  const article: IBbsArticle = output.data;\r\n} else if (output.status === 400) {\r\n  // casted to \"TypeGuardError.IProps\" when status 400\r\n  const error: TypeGuardError.IProps = output.data;\r\n} else {\r\n  // casted to \"unknown\" when out of pre-defined status codes\r\n  const result: unknown = output.data;\r\n}","comment-tags#Comment Tags":"","hiding#Hiding":"If you want to hide some API endpoints from the SDK library, write a comment tag to the controller method.\n@deprepcated: warning from IDE\n@internal: hide from d.ts files\n@ignore: actually ignore, so that not even generated\nAt first, @deprecated does not hide target API from the SDK library, but just mark as deprecated. In that case, IDE will warn to the SDK users. In such reason, @deprecated comment tag is useful for legacy API endpoints that would be removed in the future.The second @internal tag also does not hide from the SDK library, but it would be disappeared from d.ts files, so that client developers can't identify the API. Therefore, @internal tag is useful for some API endpoints that would be used only in the backend server for testing or debugging purpose.The last @ignore tag is the most powerful one. If you write @ignore tag to the controller method, the SDK library would never generate the API endpoint at all. In that case, client developers can't use the API endpoint even if they know the API endpoint path and method. It is useful for some endpoints that are not supported in the SDK library.\nimport { Controller } from \"@nestjs/common\";\r\n\r\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  /**\r\n   * Store an article.\r\n   *\r\n   * @param input Content to store\r\n   * @returns Newly archived article\r\n   * @deprecated\r\n   */\r\n  public async create(\r\n    @TypedBody() input: IBbsArticle.IStore,\r\n  ): Promise<IBbsArticle> {\r\n      ...\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public async update(\r\n    @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\r\n    @TypedBody() input: IBbsArticle.IUpdate,\r\n  ): Promise<void> {\r\n      ...\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   */\r\n  public async erase(\r\n    @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\r\n  ): Promise<void> {\r\n      ...\r\n  }\r\n}\n/**\r\n * @packageDocumentation\r\n * @module api.functional.bbs.articles\r\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\r\n */\r\n//================================================================\r\nimport type { IConnection, Primitive } from \"@nestia/fetcher\";\r\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\r\nimport type { Format } from \"typia/lib/tags/Format\";\r\n\r\nimport type { IBbsArticle } from \"../../../structures/IBbsArticle\";\r\n\r\n/**\r\n * Store an article.\r\n *\r\n * @param input Content to store\r\n * @returns Newly archived article\r\n * @deprecated\r\n *\r\n * @controller BbsArticlesController.store\r\n * @path POST /bbs/articles\r\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\r\n */\r\nexport async function store(\r\n  connection: IConnection,\r\n  input: store.Input,\r\n): Promise<store.Output> {\r\n  return PlainFetcher.fetch(\r\n    {\r\n      ...connection,\r\n      headers: {\r\n        ...connection.headers,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n    },\r\n    {\r\n      ...store.METADATA,\r\n      path: store.path(),\r\n    } as const,\r\n    input,\r\n  );\r\n}\r\nexport namespace store {\r\n  export type Input = Primitive<IBbsArticle.IStore>;\r\n  export type Output = Primitive<IBbsArticle>;\r\n\r\n  export const METADATA = {\r\n    method: \"POST\",\r\n    path: \"/bbs/articles\",\r\n    request: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    response: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    status: null,\r\n  } as const;\r\n\r\n  export const path = (): string => {\r\n    return `/bbs/articles`;\r\n  };\r\n}\r\n\r\n/**\r\n *\r\n * @internal\r\n *\r\n * @controller BbsArticlesController.update\r\n * @path PUT /bbs/articles/:id\r\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\r\n */\r\nexport async function update(\r\n  connection: IConnection,\r\n  id: string & Format<\"uuid\">,\r\n  input: update.Input,\r\n): Promise<void> {\r\n  return PlainFetcher.fetch(\r\n    {\r\n      ...connection,\r\n      headers: {\r\n        ...connection.headers,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n    },\r\n    {\r\n      ...update.METADATA,\r\n      path: update.path(id),\r\n    } as const,\r\n    input,\r\n  );\r\n}\r\nexport namespace update {\r\n  export type Input = Primitive<Partial<IBbsArticle.IStore>>;\r\n\r\n  export const METADATA = {\r\n    method: \"PUT\",\r\n    path: \"/bbs/articles/:id\",\r\n    request: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    response: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    status: null,\r\n  } as const;\r\n\r\n  export const path = (id: string & Format<\"uuid\">): string => {\r\n    return `/bbs/articles/${encodeURIComponent(id ?? \"null\")}`;\r\n  };\r\n}","headers#Headers":"Also, SDK library of @nestia/sdk supports special comment tags configuring client headers.\n@setHeader\n@assignHeaders\nAt first, @setHeader {accessor} configures only one header property. It reads special value of response body data with the accessor, and configures the special value to client header with last accessor key. In the below example case, key of authorization.token would be token, and key of authorization.timeout would be timeout.The other one @assignHeaders overwrites every property values to the client headers, with special instance of response body data with accessor. In the below example case, every properties in IShoppingCustomer.IActivated[\"authorization\"] would be assigned to the clinet headers.If you're confused, read example codes of below, clicking each tabs.\nimport { Controller } from \"@nestjs/common\";\r\n\r\n@Controller(\"shoppings/consumers/authenticate\")\r\nexport class ShoppingConsumerAuthenticateController {\r\n  /**\r\n   * @setHeader authorization.token token\r\n   * @setHeader authorization.timeout timeout\r\n   */\r\n  @TypedRoute.Post(\"join\")\r\n  public join(\r\n    @TypedBody() input: IShoppingConsumer.IJoin\r\n  ): Promise<IShoppingConsumer.IActivated>;\r\n\r\n  /**\r\n   * @assignHeaders authorization\r\n   */\r\n  @TypedRoute.Post(\"login\")\r\n  public login(\r\n    @TypedBody() inpu: IShoppingConsumer.ILogin\r\n  ): Promise<IShoppingConsumer.IActivated>;\r\n}\n/**\r\n * @packageDocumentation\r\n * @module api.functional.shoppings.consumers.authenticate\r\n * @nestia Generated by Nestia - https://github.com/samchon/nestia \r\n */\r\n//================================================================\r\nimport type { IConnection, Primitive } from \"@nestia/fetcher\";\r\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\r\n\r\nimport type { IShoppingConsumer } from \"../../../../structures/IShoppingConsumer\";\r\n\r\nexport async function join(\r\n  connection: IConnection,\r\n  input: IShoppingConsumer.IJoin,\r\n): Promise<IShoppingConsumer.IActivated> {\r\n  const output: IShoppingConsumer.IActivated = await Fetcher.fetch(\r\n    connection,\r\n    join.ENCRYPTED,\r\n    join.METHOD,\r\n    join.path(),\r\n    input,\r\n  );\r\n\r\n  // configure header(s)\r\n  connection.headers ??= {};\r\n  connection.headers.token = output.authorization.token;\r\n  connection.headers.timeout = output.authorization.timeout;\r\n\r\n  return output;\r\n}\r\nexport namespace join {\r\n    ...\r\n}\r\n\r\nexport async function login(\r\n  connection: IConnection,\r\n  input: IShoppingConsumer.IJoin,\r\n): Promise<IShoppingConsumer.IActivated> {\r\n  const output: IShoppingConsumer.IActivated = await Fetcher.fetch(\r\n    connection,\r\n    login.ENCRYPTED,\r\n    login.METHOD,\r\n    login.path(),\r\n    input,\r\n  );\r\n\r\n  // configure header(s)\r\n  connection.headers ??= {};\r\n  Object.assign(connection.headers, output.authorization);\r\n\r\n  return output;\r\n}\r\nexport namespace login {\r\n    ...\r\n}","distribution#Distribution":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdaptor } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdaptor());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n};\r\nexport default NESTIA_CONFIG;\nThe best to way to distributing SDK library is just publishing as an NPM module.Configure distribute property of nestia.config.ts file, and run npx nestia sdk command. After that, distribution environments would be automatically composed with SDK library generation. At last, move to the packages/api directory, and run npm run deploy command for publishing.From now on, client developers can use the SDK library just by using npm install command.\ncd packages/api\r\nnpm run deploy\nOf course, before publishing the NPM module, you've to customize some configurations like package name. Initial name of the distribution envirionments is @ORGANIZATION/PROJECT-api, but you must change the package name of yours, isn't it?Also, if your SDK library utilize special alias paths, you also need to customize tsconfig.json file, too. Reading below example package.json and tsconfig.json files generated by nestia, consider which features to customize.\n{\r\n  \"name\": \"@ORGANIZATION/PROJECT-api\",\r\n  \"version\": \"0.1.0\",\r\n  \"description\": \"SDK library generated by Nestia\",\r\n  \"main\": \"lib/index.js\",\r\n  \"typings\": \"lib/index.d.ts\",\r\n  \"scripts\": {\r\n    \"build\": \"npm run build:sdk && npm run compile\",\r\n    \"build:sdk\": \"rimraf ../../src/api/functional && cd ../.. && npx nestia sdk && cd packages/api\",\r\n    \"compile\": \"rimraf lib && tsc\",\r\n    \"deploy\": \"npm run build && npm publish\"\r\n  },\r\n  \"repository\": {\r\n    \"type\": \"git\",\r\n    \"url\": \"https://github.com/samchon/nestia\"\r\n  },\r\n  \"author\": \"Jeongho Nam\",\r\n  \"license\": \"MIT\",\r\n  \"bugs\": {\r\n    \"url\": \"https://github.com/samchon/nestia/issues\"\r\n  },\r\n  \"homepage\": \"https://nestia.io\",\r\n  \"devDependencies\": {\r\n    \"rimraf\": \"^5.0.0\",\r\n    \"typescript\": \"^5.3.2\",\r\n    \"ts-patch\": \"^3.1.0\"\r\n  },\r\n  \"dependencies\": {\r\n    \"@nestia/fetcher\": \"^2.3.4\",\r\n    \"typia\": \"^5.4.5\"\r\n  },\r\n  \"files\": [\r\n    \"lib\",\r\n    \"package.json\",\r\n    \"README.md\"\r\n  ]\r\n}\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"ES5\",\r\n    \"lib\": [\r\n      \"DOM\",\r\n      \"ES2015\"\r\n    ],\r\n    \"module\": \"commonjs\",\r\n    \"declaration\": true,\r\n    \"sourceMap\": true,\r\n    \"outDir\": \"./lib\",\r\n    \"downlevelIteration\": true,\r\n    \"newLine\": \"lf\",\r\n    \"esModuleInterop\": true,\r\n    \"forceConsistentCasingInFileNames\": true,\r\n    \"strict\": true,\r\n    \"skipLibCheck\": true\r\n  },\r\n  \"include\": [\r\n    \"../../src/api\"\r\n  ]\r\n}"}},"/docs/sdk/simulator":{"title":"Simulator","data":{"outline#Outline":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdaptor } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdaptor());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n      //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  simulate: true, // supports simulation mode\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nnpx nestia sdk\r\nnpx nestia sdk --config nestia.config.ts --project tsconfig.json\n/**\r\n * Update an article.\r\n *\r\n * @param section Section code\r\n * @param id Target article ID\r\n * @param input Content to update\r\n * @returns Updated content\r\n *\r\n * @controller BbsArticlesController.update()\r\n * @path PUT /bbs/:section/articles/:id\r\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\r\n */\r\nexport async function update(\r\n  connection: IConnection,\r\n  section: string,\r\n  id: string & Format<\"uuid\">,\r\n  input: update.Input,\r\n): Promise<update.Output> {\r\n  return !!connection.simulate\r\n    ? update.simulate(connection, section, id, input)\r\n    : PlainFetcher.fetch(\r\n        {\r\n          ...connection,\r\n          headers: {\r\n            ...connection.headers,\r\n            \"Content-Type\": \"application/json\",\r\n          },\r\n        },\r\n        {\r\n          ...update.METADATA,\r\n          path: update.path(section, id),\r\n        } as const,\r\n        input,\r\n      );\r\n}\r\nexport namespace update {\r\n  export type Input = Primitive<IBbsArticle.IStore>;\r\n  export type Output = Primitive<IBbsArticle>;\r\n\r\n  export const METADATA = {\r\n    method: \"PUT\",\r\n    path: \"/bbs/articles/:section/:id\",\r\n    request: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    response: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    status: null,\r\n  } as const;\r\n\r\n  export const path = (\r\n    section: string,\r\n    id: string & Format<\"uuid\">,\r\n  ): string => {\r\n    return `/bbs/${encodeURIComponent(\r\n      section ?? \"null\",\r\n    )}/articles/${encodeURIComponent(id ?? \"null\")}`;\r\n  };\r\n\r\n  export const random = (g?: Partial<typia.IRandomGenerator>): Output =>\r\n    typia.random<Output>(g);\r\n\r\n  export const simulate = async (\r\n    connection: IConnection,\r\n    section: string,\r\n    id: string & Format<\"uuid\">,\r\n    input: update.Input,\r\n  ): Promise<Output> => {\r\n    const assert = NestiaSimulator.assert({\r\n      method: METHOD,\r\n      host: connection.host,\r\n      path: path(section, id),\r\n    });\r\n    assert.param(\"section\")(\"string\")(() => typia.assert(section));\r\n    assert.param(\"id\")(\"uuid\")(() => typia.assert(id));\r\n    assert.body(() => typia.assert(input));\r\n    return random(\r\n      typeof connection.simulate === \"object\" && connection.simulate !== null\r\n        ? connection.simulate\r\n        : undefined,\r\n    );\r\n  };\r\n}\nNestia SDK library supports Mockup simulator.When generating SDK library, if you configure simulate property of nestia.config.file to be true, newly generated SDK library will support mockup simulation mode for frontend developers. With the mockup simulator, frontend developers can simulate NestJS backend server with internal mock functions, instead of connecting to the real backend server.Therefore, with the mockup simulator, frontend development can be started even when the backend server is not ready yet. Mockup simulator of Nestia SDK will replace the real backend server, validating request data, and returning mockup data as response.Within framework of backend developers, they also do not need to be suffered from the mock-up data composition. Also, as nestia can automatically generate e2e test functions, backend developers can concentrated only on the business logic.","confguration#Confguration":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdaptor } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdaptor());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  simulate: true, // supports simulation mode\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport type { INestApplication } from \"@nestjs/common\";\r\n\r\nimport type { ISwagger } from \"./structures/ISwagger\";\r\nimport type { ISwaggerInfo } from \"./structures/ISwaggerInfo\";\r\nimport type { ISwaggerSecurityScheme } from \"./structures/ISwaggerSecurityScheme\";\r\n\r\n/**\r\n * Definition for the `nestia.config.ts` file.\r\n *\r\n * @author Jeongho Nam - https://github.com/samchon\r\n */\r\nexport interface INestiaConfig {\r\n  /**\r\n   * Accessor of controller classes.\r\n   *\r\n   * You can specify it within two ways\r\n   *\r\n   *   - Asynchronous function returning `INestApplication` instance\r\n   *   - Specify the path or directory of controller class files\r\n   */\r\n  input:\r\n    | (() => Promise<INestApplication>)\r\n    | INestiaConfig.IInput\r\n    | string[]\r\n    | string;\r\n\r\n  /**\r\n   * Output directory that SDK would be placed in.\r\n   *\r\n   * If not configured, you can't build the SDK library.\r\n   */\r\n  output?: string;\r\n\r\n  /**\r\n   * Building `swagger.json` is also possible.\r\n   *\r\n   * If not specified, you can't build the `swagger.json`.\r\n   */\r\n  swagger?: INestiaConfig.ISwaggerConfig;\r\n\r\n  /**\r\n   * Target directory that SDK distribution files would be placed in.\r\n   *\r\n   * If you configure this property and runs `npx nestia sdk` command,\r\n   * distribution environments for the SDK library would be generated.\r\n   *\r\n   * After the SDK library generation, move to the `distribute` directory,\r\n   * and runs `npm publish` command, then you can share SDK library with\r\n   * other client (frontend) developers.\r\n   *\r\n   * Recommend to use `\"packages/api\"` value.\r\n   */\r\n  distribute?: string;\r\n\r\n  /**\r\n   * Allow simulation mode.\r\n   *\r\n   * If you configure this property to be `true`, the SDK library would be contain\r\n   * simulation mode. In the simulation mode, the SDK library would not communicate\r\n   * with the real backend server, but just returns random mock-up data\r\n   * with requestion data validation.\r\n   *\r\n   * For reference, random mock-up data would be generated by `typia.random<T>()`\r\n   * function.\r\n   *\r\n   * @default false\r\n   */\r\n  simulate?: boolean;\r\n\r\n  /**\r\n   * Target directory that e2e test functions would be placed in.\r\n   *\r\n   * If you configure this property and runs `npx nestia e2e` command,\r\n   * `@nestia/sdk` will analyze your NestJS backend server code, and\r\n   * generates e2e test functions for every API endpoints.\r\n   *\r\n   * If not configured, you can't run `npx nestia e2e` command.\r\n   */\r\n  e2e?: string;\r\n\r\n  /**\r\n   * Whether to use propagation mode or not.\r\n   *\r\n   * If being configured, interaction functions of the SDK library would\r\n   * perform the propagation mode. The propagation mode means that never\r\n   * throwing exception even when status code is not 200 (or 201), but just\r\n   * returning the {@link IPropagation} typed instance, which can specify its body\r\n   * type through discriminated union determined by status code.\r\n   *\r\n   * @default false\r\n   */\r\n  propagate?: boolean;\r\n\r\n  /**\r\n   * Whether to clone DTO structures or not.\r\n   *\r\n   * If being configured, all of DTOs used in the backend server would be cloned\r\n   * into the `structures` directory, and the SDK library would be refer to the\r\n   * cloned DTOs instead of the original.\r\n   *\r\n   * @default false\r\n   */\r\n  clone?: boolean;\r\n\r\n  /**\r\n   * Whether to wrap DTO by primitive type.\r\n   *\r\n   * If you don't configure this property as `false`, all of DTOs in the\r\n   * SDK library would be automatically wrapped by {@link Primitive} type.\r\n   *\r\n   * For refenrece, if a DTO type be capsuled by the {@link Primitive} type,\r\n   * all of methods in the DTO type would be automatically erased. Also, if\r\n   * the DTO has a `toJSON()` method, the DTO type would be automatically\r\n   * converted to return type of the `toJSON()` method.\r\n   *\r\n   * @default true\r\n   */\r\n  primitive?: boolean;\r\n\r\n  /**\r\n   * Whether to assert parameter types or not.\r\n   *\r\n   * If you configure this property to be `true`, all of the function\r\n   * parameters of SDK library would be checked through\r\n   * [`typia.assert<T>()` function](https://typia.io/docs/validators/assert/).\r\n   *\r\n   * This option would make your SDK library compilation time a little bit slower,\r\n   * but would enahcne the type safety even in the runtime level.\r\n   *\r\n   * @default false\r\n   */\r\n  assert?: boolean;\r\n\r\n  /**\r\n   * Whether to optimize JSON string conversion 10x faster or not.\r\n   *\r\n   * If you configure this property to be `true`, the SDK library would utilize the\r\n   * [`typia.assertStringify<T>() function`](https://github.com/samchon/typia#enhanced-json)\r\n   * to boost up JSON serialization speed and ensure type safety.\r\n   *\r\n   * This option would make your SDK library compilation time a little bit slower,\r\n   * but would enhance JSON serialization speed 10x faster. Also, it can ensure type\r\n   * safety even in the rumtime level.\r\n   *\r\n   * @default false\r\n   */\r\n  json?: boolean;\r\n}\r\nexport namespace INestiaConfig {\r\n  /**\r\n   * List of files or directories to include or exclude to specifying the NestJS\r\n   * controllers.\r\n   */\r\n  export interface IInput {\r\n    /**\r\n     * List of files or directories containing the NestJS controller classes.\r\n     */\r\n    include: string[];\r\n\r\n    /**\r\n     * List of files or directories to be excluded.\r\n     */\r\n    exclude?: string[];\r\n  }\r\n\r\n  /**\r\n   * Building `swagger.json` is also possible.\r\n   */\r\n  export interface ISwaggerConfig {\r\n    /**\r\n     * Output path of the `swagger.json`.\r\n     *\r\n     * If you've configured only directory, the file name would be the `swagger.json`.\r\n     * Otherwise you've configured the full path with file name and extension, the\r\n     * `swagger.json` file would be renamed to it.\r\n     */\r\n    output: string;\r\n\r\n    /**\r\n     * API information.\r\n     *\r\n     * If omitted, `package.json` content would be used instead.\r\n     */\r\n    info?: Partial<ISwaggerInfo>;\r\n\r\n    /**\r\n     * List of server addresses.\r\n     */\r\n    servers?: ISwagger.IServer[];\r\n\r\n    /**\r\n     * Security schemes.\r\n     *\r\n     * When generating `swagger.json` file through `nestia`, if your controllers or\r\n     * theirs methods have a security key which is not enrolled in here property,\r\n     * it would be an error.\r\n     */\r\n    security?: Record<string, ISwaggerSecurityScheme>;\r\n\r\n    /**\r\n     * Decompose query DTO.\r\n     *\r\n     * If you configure this property to be `true`, the query DTO would be decomposed\r\n     * into individual query parameters per each property.\r\n     *\r\n     * @default false\r\n     */\r\n    decompose?: boolean;\r\n\r\n    operationId?(props: {\r\n      class: string;\r\n      function: string;\r\n      method: \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\r\n      path: string;\r\n    }): string;\r\n  }\r\n}\nMake nestia.config.ts file and run npx nestia sdk command.At first, create nestia.config.ts file through npx nestia init command. It would be placed on the top level directory of your NestJS backend project. For reference, tsconfig.json file also must be placed in the top level directory, too. After creation, configure the nestia.config.ts file referencing above example code and type definition.At least, you've to configure those three properties. Also, if you've decided to support mockup simulator for frontend developers, I recommend you to configure two properties more, for automatic e2e functions generation and SDK library distribution.\nEssential\ninput: Accessor of controller classes\noutput: Path of output directory for SDK library\nsimulate: Whether to support simulator or not\nRecommended\ne2e: Path of output directory for E2E test functions\ndistribute: Target directory for SDK library distribution\nWhen you've completed above configuration, just run npx nestia sdk command. Then, SDK library would be generated into the $config.output directory, with simulation mode supporting. If you want to generate e2e functions automatically, run npx nestia e2e command after.By the way, nestia.config.ts supports alternative options specifying the target controller classes instead of using the Module instance. If your backend application server does not have special configuration like setGlobalPrefix, enableVersioning and RouterModule, it is okay to specifying the target controller classes just by writing their file path like below.\nimport { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  simulate: true,\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\nimport { FastifyAdaptor } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule, new FastifyAdpator());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  simulate: true,\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: [\"src/controllers\", \"src/fake/controllers\", \"src/test/controllers\"],\r\n  output: \"src/api\",\r\n  simulate: true,\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: \"src/**/*.controller.ts\",\r\n  output: \"src/api\",\r\n  simulate: true,\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: {\r\n    include: [\"src/controllers\"],\r\n    exclude: [\"src/**/*.fake.ts\"],\r\n  },\r\n  output: \"src/api\",\r\n  simulate: true,\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;","code-analysis#Code Analysis":"/**\r\n * Update an article.\r\n *\r\n * @param section Section code\r\n * @param id Target article ID\r\n * @param input Content to update\r\n * @returns Updated content\r\n *\r\n * @controller BbsArticlesController.update()\r\n * @path PUT /bbs/:section/articles/:id\r\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\r\n */\r\nexport async function update(\r\n  connection: IConnection,\r\n  section: string,\r\n  id: string & Format<\"uuid\">,\r\n  input: update.Input,\r\n): Promise<update.Output> {\r\n  return !!connection.simulate\r\n    ? update.simulate(connection, section, id, input)\r\n    : PlainFetcher.fetch(\r\n        {\r\n          ...connection,\r\n          headers: {\r\n            ...connection.headers,\r\n            \"Content-Type\": \"application/json\",\r\n          },\r\n        },\r\n        {\r\n          ...update.METADATA,\r\n          path: update.path(section, id),\r\n        } as const,\r\n        input,\r\n      );\r\n}\r\nexport namespace update {\r\n  export type Input = Primitive<IBbsArticle.IStore>;\r\n  export type Output = Primitive<IBbsArticle>;\r\n\r\n  export const METADATA = {\r\n    method: \"PUT\",\r\n    path: \"/bbs/articles/:section/:id\",\r\n    request: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    response: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    status: null,\r\n  } as const;\r\n\r\n  export const path = (\r\n    section: string,\r\n    id: string & Format<\"uuid\">,\r\n  ): string => {\r\n    return `/bbs/${encodeURIComponent(\r\n      section ?? \"null\",\r\n    )}/articles/${encodeURIComponent(id ?? \"null\")}`;\r\n  };\r\n\r\n  export const random = (g?: Partial<typia.IRandomGenerator>): Output =>\r\n    typia.random<Output>(g);\r\n\r\n  export const simulate = async (\r\n    connection: IConnection,\r\n    section: string,\r\n    id: string & Format<\"uuid\">,\r\n    input: update.Input,\r\n  ): Promise<Output> => {\r\n    const assert = NestiaSimulator.assert({\r\n      method: METHOD,\r\n      host: connection.host,\r\n      path: path(section, id),\r\n    });\r\n    assert.param(\"section\")(() => typia.assert(section));\r\n    assert.param(\"id\")(() => typia.assert(id));\r\n    assert.body(() => typia.assert(input));\r\n    return random(\r\n      typeof connection.simulate === \"object\" && connection.simulate !== null\r\n        ? connection.simulate\r\n        : undefined,\r\n    );\r\n  };\r\n}\nimport { HttpError } from \"@nestia/fetcher\";\r\n\r\nimport typia from \"typia\";\r\n\r\nexport namespace NestiaSimulator {\r\n  export interface IProps {\r\n    host: string;\r\n    path: string;\r\n    method: \"GET\" | \"POST\" | \"PATCH\" | \"PUT\" | \"DELETE\";\r\n    contentType: string;\r\n  }\r\n\r\n  export const assert = (props: IProps) => {\r\n    return {\r\n      param: param(props),\r\n      query: query(props),\r\n      body: body(props),\r\n    };\r\n  };\r\n  const param =\r\n    (props: IProps) =>\r\n    (name: string) =>\r\n    <T>(task: () => T): void => {\r\n      validate((exp) => `URL parameter \"${name}\" is not ${exp.expected} type.`)(\r\n        props,\r\n      )(task);\r\n    };\r\n\r\n  const query =\r\n    (props: IProps) =>\r\n    <T>(task: () => T): void =>\r\n      validate(\r\n        () => \"Request query parameters are not following the promised type.\",\r\n      )(props)(task);\r\n\r\n  const body =\r\n    (props: IProps) =>\r\n    <T>(task: () => T): void =>\r\n      validate(() => \"Request body is not following the promised type.\")(props)(\r\n        task,\r\n      );\r\n\r\n  const validate =\r\n    (message: (exp: typia.TypeGuardError) => string, path?: string) =>\r\n    (props: IProps) =>\r\n    <T>(task: () => T): void => {\r\n      try {\r\n        task();\r\n      } catch (exp) {\r\n        if (typia.is<typia.TypeGuardError>(exp))\r\n          throw new HttpError(\r\n            props.method,\r\n            props.host + props.path,\r\n            400,\r\n            {\r\n              \"Content-Type\": props.contentType,\r\n            },\r\n            JSON.stringify({\r\n              method: exp.method,\r\n              path: path ?? exp.path,\r\n              expected: exp.expected,\r\n              value: exp.value,\r\n              message: message(exp),\r\n            }),\r\n          );\r\n        throw exp;\r\n      }\r\n    };\r\n}\nLet's read generated SDK library code, and understand which features are supportedAt first, you can find that mock-up data is composed by typia.random<T>() function. Also, simulator function validates path parameters and request body data through typia.assert<T>() function. If the validation fails, 400 status error would be thrown.At last, if frontend developer turns off simulation mode by configuring IConnection.simulate value to be false, the SDK library stops NestJS backend server simulating, and just start communicating with the real backend server."}},"/docs/setup":{"title":"Setup","data":{"boilerplate#Boilerplate":"npx nestia start <directory>\nJust run above npx nestia start <directory> command.Boilerplate would be automatically constructed in the <directory>. For reference, this is a minimal boilerplate project concentrating only on the SDK generation from the NestJS server. It does not contain the database connection.If you want to construct much detailed boilerplate project, visit @samchon/backend or run below command. Below boilerplate project is using Prisma ORM and PostgresSQL database. Also, it guides how to utilize FP (Functional Programming) and TDD (Test Driven Development) in the NestJS backend development.\nnpx nestia template <directory>","setup-wizard#Setup Wizard":"npm install --save-dev nestia\r\nnpx nestia setup\npnpm install --save-dev nestia\r\npnpm nestia setup --manager pnpm\n# YARN BERRY IS NOT SUPPORTED\r\nyarn add -D nestia\r\nyarn nestia setup --manager yarn\nWhen you want to setup nestia in existing project, just run above npx nestia setup command.Setup Wizard will install and configure everything automatically.","webpack#Webpack":"","with-node_modules#With node_modules":"# SETUP NESTIA\r\nnpm install --save-dev nestia\r\nnpx nestia setup\r\n\r\n# INSTALL TS-LOADER & WEBPACK\r\nnpm install --save-dev ts-loader\r\nnpm install --save-dev webpack webpack-cli webpack-node-externals \n# SETUP NESTIA\r\npnpm install --save-dev nestia\r\npnpm nestia setup --manager pnpm\r\n\r\n# INSTALL TS-LOADER & WEBPACK\r\npnpm install --save-dev ts-loader\r\npnpm install --save-dev webpack webpack-cli webpack-node-externals \n# SETUP NESTIA (YARN BERY IS NOT SUPPORTED)\r\nyarn add -D nestia\r\nyarn nestia setup --manager yarn\r\n\r\n# INSTALL TS-LOADER & WEBPACK\r\nyarn add -D ts-loader\r\nyarn add -D webpack webpack-cli webpack-node-externals \nWhen you want to bundle your NestJS project into a single file, you have to install webpack manually.Never run nest build --webpack command of @nestjs/cli, because it is not compatible with nestia.\nconst path = require(\"path\");\r\nconst nodeExternals = require(\"webpack-node-externals\");\r\n\r\nmodule.exports = {\r\n  // CUSTOMIZE HERE\r\n  entry: {\r\n    server: \"./src/executable/server.ts\",\r\n  },\r\n  output: {\r\n    path: path.join(__dirname, \"dist\"),\r\n    filename: \"[name].js\",\r\n  },\r\n  optimization: {\r\n    minimize: false,\r\n  },\r\n\r\n  // JUST KEEP THEM\r\n  externals: [nodeExternals()],\r\n  mode: \"development\",\r\n  target: \"node\",\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.ts$/,\r\n        exclude: /node_modules/,\r\n        loader: \"ts-loader\",\r\n      },\r\n    ],\r\n  },\r\n  resolve: {\r\n    extensions: [\".tsx\", \".ts\", \".js\"],\r\n  },\r\n};\nAfter installing both nestia and webpack, configure webpack.config.js file like above.From now on, you can build the single JS file just by running the npx webpack command. By the way, when removing devDependencies for --production install, never forget to add the --ignore-scripts option to prevent the prepare script.\nnpx webpack\r\nnpm ci --omit=dev --ignore-scripts\npnpm webpack\r\npnpm install --production --ignore-scripts\nyarn webpack\r\nrm -rf node_modules\r\nyarn install --production --ignore-scripts --immutable","single-js-file-only#Single JS file only":"If you can build your NestJS project into a singile JS file, and that JS file even does not require the node_modules directory, it would be useful for building a serverless environment. Also, as it does not need to perform the pruning process (represented by pnpm install --production --ignore-scripts command), it would be much convenient and faster than the above method.To accomplish the light JS bundling, install special dependencies like below.\n# SETUP NESTIA\r\nnpm install --save-dev nestia\r\nnpx nestia setup\r\n\r\n# INSTALL SPECIAL DEPENDENCIES\r\nnpm install --save-dev ts-loader\r\nnpm install --save-dev webpack webpack-cli\r\nnpm install --save-dev copy-webpack-plugin write-file-webpack-plugin\n# SETUP NESTIA\r\npnpm install --save-dev nestia\r\npnpm nestia setup --manager pnpm\r\n\r\n# INSTALL SPECIAL DEPENDENCIES\r\npnpm install --save-dev ts-loader\r\npnpm install --save-dev webpack webpack-cli\r\npnpm install --save-dev copy-webpack-plugin write-file-webpack-plugin\n# SETUP NESTIA (YARN BERY IS NOT SUPPORTED)\r\nyarn add -D nestia\r\nyarn nestia setup --manager yarn\r\n\r\n# INSTALL SPECIAL DEPENDENCIES\r\nyarn add -D ts-loader\r\nyarn add -D webpack webpack-cli\r\nyarn add -D copy-webpack-plugin write-file-webpack-plugin\nAlso, configure webpack.config.js file like below, considering options.For example, if your NestJS backend server is utilizing the Prisma ORM, uncomment the CopyWebpackPlugin.patterns block to copy the Prisma engine files (node_modules/**/.prisma/client/*.node) into the output dist directory.After that, just run npx webpack command. Then the light JS file(s) would be bundled into the dist directory, and you don't need to perform the pruning process (represented by pnpm install --production --ignore-scripts command) for the distribution. Just deploy the dist directory to the target server.\nconst path = require(\"path\");\r\n\r\nconst CopyWebpackPlugin = require(\"copy-webpack-plugin\");\r\nconst WriteFilePlugin = require(\"write-file-webpack-plugin\");\r\nconst { IgnorePlugin } = require(\"webpack\");\r\n\r\nconst lazyImports = [\r\n  \"@fastify/static\",\r\n  \"@fastify/view\",\r\n  \"@nestjs/microservices\",\r\n  \"@nestjs/websockets\",\r\n  \"class-transformer\",\r\n  \"class-validator\",\r\n];\r\n\r\n// @reference https://tech-blog.s-yoshiki.com/entry/297\r\nmodule.exports = {\r\n  // CUSTOMIZE HERE\r\n  entry: {\r\n    server: \"./src/executable/server.ts\",\r\n  },\r\n  output: {\r\n    path: path.join(__dirname, \"dist\"),\r\n    filename: \"[name].js\",\r\n  },\r\n  optimization: {\r\n    minimize: true,\r\n  },\r\n\r\n  // JUST KEEP THEM\r\n  mode: \"production\",\r\n  target: \"node\",\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.ts$/,\r\n        exclude: /node_modules/,\r\n        loader: \"ts-loader\",\r\n      },\r\n    ],\r\n  },\r\n  resolve: {\r\n    extensions: [\".tsx\", \".ts\", \".js\"],\r\n  },\r\n  plugins: [\r\n    new CopyWebpackPlugin({\r\n      patterns: [\r\n        {\r\n          from: \".env\",\r\n          to: \"[name][ext]\",\r\n        },\r\n        {\r\n          from: \"package.json\",\r\n          to: \"[name][ext]\",\r\n        },\r\n        // {\r\n        //   from: \"node_modules/**/.prisma/client/*.node\",\r\n        //   to: () => Promise.resolve(\"[path][name][ext]\"),\r\n        //   globOptions: {\r\n        //     dot: true,\r\n        // },\r\n      ],\r\n    }),\r\n    new WriteFilePlugin(),\r\n    new IgnorePlugin({\r\n      checkResource: (resource) => {\r\n        if (lazyImports.some((modulo) => resource.startsWith(modulo))) {\r\n          try {\r\n            require.resolve(resource);\r\n          } catch (err) {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      },\r\n    }),\r\n  ],\r\n};","nx#NX":"npm install --save-dev nestia\r\nnpx nestia setup\npnpm install --save-dev nestia\r\npnpm nestia setup --manager pnpm\nyarn add -D nestia\r\nyarn nestia setup --manager yarn\nAfter install nestia like above, you have to modify project.json on each app you use typia like below.\n \"targets\": {\r\n    \"build\": {\r\n      ...\r\n      \"options\": {\r\n        ...\r\n        \"target\": \"node\",\r\n        \"compiler\": \"tsc\",\r\n        \"transformers\": [\r\n          \"typia/lib/transform\",\r\n          {\r\n            \"name\": \"@nestia/core/lib/transform\",\r\n            \"options\": {\r\n              \"validate\": \"assert\",\r\n              \"stringify\": \"assert\"\r\n            }\r\n          }\r\n        ]\r\n      }\r\n    },\r\n    ...\r\n }","manual-setup#Manual Setup":"# COMPILERS\r\nnpm install --save-dev typescript\r\nnpm install --save-dev ts-node\r\nnpm install --save-dev ts-patch\r\n\r\n# NESTIA\r\nnpm install --save-dev nestia\r\nnpm install --save-dev @nestia/sdk\r\nnpm install --save @nestia/core\r\nnpm install --save @nestia/e2e\r\nnpm install --save typia\n# COMPILERS\r\npnpm install --save-dev typescript\r\npnpm install --save-dev ts-node\r\npnpm install --save-dev ts-patch\r\n\r\n# NESTIA\r\npnpm install --save-dev nestia\r\npnpm install --save-dev @nestia/sdk\r\npnpm install --save @nestia/core\r\npnpm install --save @nestia/e2e\r\npnpm install --save typia\n# COMPILERS\r\nyarn add -D typescript\r\nyarn add -D ts-node\r\nyarn add -D ts-patch\r\n\r\n# NESTIA\r\nyarn add -D nestia\r\nyarn add -D @nestia/sdk\r\nyarn add @nestia/core\r\nyarn add @nestia/e2e\r\nyarn add typia\nIf you want to install nestia manually, you have to install ts-node and ts-patch modules as well as typescript. After installing those compilers, install nestia libraries like above.\n{\r\n  \"strict\": true,\r\n  \"strictNullChecks\": true,\r\n  \"compilerOptions\": {\r\n    \"plugins\": [\r\n      { \"transform\": \"typia/lib/transform\" },\r\n      { \r\n        \"transform\": \"@nestia/core/lib/transform\",\r\n        \"validate\": \"assert\",\r\n        \"stringify\": \"assert\", \r\n      },\r\n    ],\r\n  },\r\n}\nAfter that, configure tsconfig.json file like above.As @nestia/core and typia are generating optimal validation and JSON serialization code through transformation, you've to configure them as plugins. For reference, you can choose which typia functions to be used in validation and JSON serialization.\nConfigurable values both on validate and stringify\nis: check validation only, and do not reveal the reason why\nassert: find the 1st type error with reason\nvalidate: find every type errors with detailed reasons\nOnly for validate\nequals: do not allow extra properties\nassertEquals\nvalidateEquals\nassertPrune or validatePrune: prune extra properties with type checking\nassertClone or validateClone: deep clone with type checking for faster pruning\nAlso, never forget to configure strict (or strictNullChecks) as true. It is essential option for modern TypeScript development.\n{\r\n  \"scripts\": {\r\n    \"prepare\": \"ts-patch install && typia patch\"\r\n  }\r\n}\nnpm run prepare\npnpm run prepare\nyarn run prepare\nAt last, configure npm run prepare command like above.Of course, you've to run the npm run prepare command after configuration.For reference, ts-patch is an helper library of TypeScript compiler that supporting custom transformations by plugins. With the ts-patch setup and plugin configurations, whenever you run tsc command, your @nestia/core decorator function call statements would be transformed to the optimal operation codes in the compiled JavaScript files.\nnpx typia patch\nSince TypeScript v5.3 update, tsc no more parses JSDocComments. Therefore, (@nestia/core) typia also cannot utilize those JSDocComment related features too, especially \"Comment Tags\" and \"JSON schema generator\".The npx typia patch command has been developed to revive the JSDocComment parsing feature of tsc. It is temporary solution for the TypeScript v5.3 update instead of ts-patch, and will be disabled after ts-patch starts supporting such TypeScript v5.3 update.Of course, if you don't use any \"Comment Tags\" and \"JSON schema generator\", you don't need to run npx typia patch command. This is not mandatory command, but just optional command.","standard-typescript-only#Standard TypeScript Only":"If you're using @nestia/core module, you've to use only standard TypeScript compiler.Do you remember? @nestia/core boosts up runtime validation and JSON serialization through AOT compilation. By the way, @nestia/core performs the AOT compilation through standard TypeScript compiler API. Therefore, if you want to utilize those superfast decorators of @nestia/core module, you have to use only standard TypeScript compiler.I also know that non-standard compilers are faster than standard. However, all of them are erasing type information, and skipping type checking for rapid compilation. By the way, without type information, @nestia/core can't do anything. It is the reason why @nestia/core does not support them.\nStandard TypeScript Compiler (keep type info)\nMicrosoft/TypeScript\nNon-standard TypeScript Compilers (erase type info)\nSWC\nESBuild\nBabel\nSWC author is preparing a new project STC, and it does not erase type info.Therefore, nestia will support it."}},"/docs/sdk/swagger":{"title":"Swagger","data":{"outline#Outline":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdaptor } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdaptor());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  swagger: {\r\n    output: \"dist/swagger.json\",\r\n    beautify: true,\r\n    security: {\r\n      bearer: {\r\n        type: \"apiKey\",\r\n        name: \"Authorization\",\r\n        in: \"header\",\r\n      },\r\n    },\r\n    servers: [\r\n      {\r\n        url: \"http://localhost:3000\",\r\n        description: \"Local Server\",\r\n      },\r\n    ],\r\n  },\r\n};\r\nexport default NESTIA_CONFIG;\nnpx nestia swagger\r\nnpx nestia swagger --config nestia.config.ts --project tsconfig.json\nConfigure nestia.config.ts file and run npx nestia swagger command.Then, @nestia/sdk will analyze your NestJS backend server code, and generate swagger.json file.If you have a special configuration file that its file name is not nestia.config.ts, you can specify it with --config option like npx nestia swagger --config another.config.ts. Also, if you have a special tsconfig.json file, you can specify it with --project option like npx nestia swagger --project another.tsconfig.json, too.","configuration#Configuration":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdaptor } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdaptor());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  swagger: {\r\n    output: \"dist/swagger.json\",\r\n    security: {\r\n      bearer: {\r\n        type: \"apiKey\",\r\n        name: \"Authorization\",\r\n        in: \"header\",\r\n      },\r\n    },\r\n    servers: [\r\n      {\r\n        url: \"http://localhost:3000\",\r\n        description: \"Local Server\",\r\n      },\r\n    ],\r\n    beautify: true,\r\n  },\r\n};\r\nexport default NESTIA_CONFIG;\nimport type { INestApplication } from \"@nestjs/common\";\r\n\r\nimport type { ISwagger } from \"./structures/ISwagger\";\r\nimport type { ISwaggerInfo } from \"./structures/ISwaggerInfo\";\r\nimport type { ISwaggerSecurityScheme } from \"./structures/ISwaggerSecurityScheme\";\r\n\r\n/**\r\n * Definition for the `nestia.config.ts` file.\r\n *\r\n * @author Jeongho Nam - https://github.com/samchon\r\n */\r\nexport interface INestiaConfig {\r\n  /**\r\n   * Building `swagger.json` is also possible.\r\n   *\r\n   * If not specified, you can't build the `swagger.json`.\r\n   */\r\n  swagger?: INestiaConfig.ISwaggerConfig;\r\n\r\n  /**\r\n   * Accessor of controller classes.\r\n   *\r\n   * You can specify it within two ways\r\n   *\r\n   *   - Asynchronous function returning `INestApplication` instance\r\n   *   - Specify the path or directory of controller class files\r\n   */\r\n  input:\r\n    | (() => Promise<INestApplication>)\r\n    | INestiaConfig.IInput\r\n    | string[]\r\n    | string;\r\n\r\n  /**\r\n   * Output directory that SDK would be placed in.\r\n   *\r\n   * If not configured, you can't build the SDK library.\r\n   */\r\n  output?: string;\r\n\r\n  /**\r\n   * Target directory that SDK distribution files would be placed in.\r\n   *\r\n   * If you configure this property and runs `npx nestia sdk` command,\r\n   * distribution environments for the SDK library would be generated.\r\n   *\r\n   * After the SDK library generation, move to the `distribute` directory,\r\n   * and runs `npm publish` command, then you can share SDK library with\r\n   * other client (frontend) developers.\r\n   *\r\n   * Recommend to use `\"packages/api\"` value.\r\n   */\r\n  distribute?: string;\r\n\r\n  /**\r\n   * Allow simulation mode.\r\n   *\r\n   * If you configure this property to be `true`, the SDK library would be contain\r\n   * simulation mode. In the simulation mode, the SDK library would not communicate\r\n   * with the real backend server, but just returns random mock-up data\r\n   * with requestion data validation.\r\n   *\r\n   * For reference, random mock-up data would be generated by `typia.random<T>()`\r\n   * function.\r\n   *\r\n   * @default false\r\n   */\r\n  simulate?: boolean;\r\n\r\n  /**\r\n   * Target directory that e2e test functions would be placed in.\r\n   *\r\n   * If you configure this property and runs `npx nestia e2e` command,\r\n   * `@nestia/sdk` will analyze your NestJS backend server code, and\r\n   * generates e2e test functions for every API endpoints.\r\n   *\r\n   * If not configured, you can't run `npx nestia e2e` command.\r\n   */\r\n  e2e?: string;\r\n\r\n  /**\r\n   * Whether to use propagation mode or not.\r\n   *\r\n   * If being configured, interaction functions of the SDK library would\r\n   * perform the propagation mode. The propagation mode means that never\r\n   * throwing exception even when status code is not 200 (or 201), but just\r\n   * returning the {@link IPropagation} typed instance, which can specify its body\r\n   * type through discriminated union determined by status code.\r\n   *\r\n   * @default false\r\n   */\r\n  propagate?: boolean;\r\n\r\n  /**\r\n   * Whether to clone DTO structures or not.\r\n   *\r\n   * If being configured, all of DTOs used in the backend server would be cloned\r\n   * into the `structures` directory, and the SDK library would be refer to the\r\n   * cloned DTOs instead of the original.\r\n   *\r\n   * @default false\r\n   */\r\n  clone?: boolean;\r\n\r\n  /**\r\n   * Whether to wrap DTO by primitive type.\r\n   *\r\n   * If you don't configure this property as `false`, all of DTOs in the\r\n   * SDK library would be automatically wrapped by {@link Primitive} type.\r\n   *\r\n   * For refenrece, if a DTO type be capsuled by the {@link Primitive} type,\r\n   * all of methods in the DTO type would be automatically erased. Also, if\r\n   * the DTO has a `toJSON()` method, the DTO type would be automatically\r\n   * converted to return type of the `toJSON()` method.\r\n   *\r\n   * @default true\r\n   */\r\n  primitive?: boolean;\r\n\r\n  /**\r\n   * Whether to assert parameter types or not.\r\n   *\r\n   * If you configure this property to be `true`, all of the function\r\n   * parameters of SDK library would be checked through\r\n   * [`typia.assert<T>()` function](https://typia.io/docs/validators/assert/).\r\n   *\r\n   * This option would make your SDK library compilation time a little bit slower,\r\n   * but would enahcne the type safety even in the runtime level.\r\n   *\r\n   * @default false\r\n   */\r\n  assert?: boolean;\r\n\r\n  /**\r\n   * Whether to optimize JSON string conversion 10x faster or not.\r\n   *\r\n   * If you configure this property to be `true`, the SDK library would utilize the\r\n   * [`typia.assertStringify<T>() function`](https://github.com/samchon/typia#enhanced-json)\r\n   * to boost up JSON serialization speed and ensure type safety.\r\n   *\r\n   * This option would make your SDK library compilation time a little bit slower,\r\n   * but would enhance JSON serialization speed 10x faster. Also, it can ensure type\r\n   * safety even in the rumtime level.\r\n   *\r\n   * @default false\r\n   */\r\n  json?: boolean;\r\n}\r\nexport namespace INestiaConfig {\r\n  /**\r\n   * List of files or directories to include or exclude to specifying the NestJS\r\n   * controllers.\r\n   */\r\n  export interface IInput {\r\n    /**\r\n     * List of files or directories containing the NestJS controller classes.\r\n     */\r\n    include: string[];\r\n\r\n    /**\r\n     * List of files or directories to be excluded.\r\n     */\r\n    exclude?: string[];\r\n  }\r\n\r\n  /**\r\n   * Building `swagger.json` is also possible.\r\n   */\r\n  export interface ISwaggerConfig {\r\n    /**\r\n     * Output path of the `swagger.json`.\r\n     *\r\n     * If you've configured only directory, the file name would be the `swagger.json`.\r\n     * Otherwise you've configured the full path with file name and extension, the\r\n     * `swagger.json` file would be renamed to it.\r\n     */\r\n    output: string;\r\n\r\n    /**\r\n     * Whether to beautify JSON content or not.\r\n     *\r\n     * If you configure this property to be `true`, the `swagger.json` file would\r\n     * be beautified with indentation (2 spaces) and line breaks. If you configure\r\n     * numeric value instead, the indentation would be specified by the number.\r\n     *\r\n     * @default false\r\n     */\r\n    beautify?: boolean | number;\r\n\r\n    /**\r\n     * API information.\r\n     *\r\n     * If omitted, `package.json` content would be used instead.\r\n     */\r\n    info?: Partial<ISwaggerInfo>;\r\n\r\n    /**\r\n     * List of server addresses.\r\n     */\r\n    servers?: ISwagger.IServer[];\r\n\r\n    /**\r\n     * Security schemes.\r\n     *\r\n     * When generating `swagger.json` file through `nestia`, if your controllers or\r\n     * theirs methods have a security key which is not enrolled in here property,\r\n     * it would be an error.\r\n     */\r\n    security?: Record<string, ISwaggerSecurityScheme>;\r\n\r\n    /**\r\n     * Decompose query DTO.\r\n     *\r\n     * If you configure this property to be `true`, the query DTO would be decomposed\r\n     * into individual query parameters per each property.\r\n     *\r\n     * @default false\r\n     */\r\n    decompose?: boolean;\r\n\r\n    operationId?(props: {\r\n      class: string;\r\n      function: string;\r\n      method: \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\r\n      path: string;\r\n    }): string;\r\n  }\r\n}\n/**\r\n * Security scheme of Swagger Documents.\r\n *\r\n * `ISwaggerSecurityScheme` is a data structure representing content of\r\n * `securitySchemes` in `swagger.json` file. It is composed with 5 types of security\r\n * schemes as an union type like below.\r\n *\r\n * @reference https://swagger.io/specification/#security-scheme-object\r\n * @author Jeongho Nam - https://github.com/samchon\r\n */\r\nexport type ISwaggerSecurityScheme =\r\n  | ISwaggerSecurityScheme.IHttpBasic\r\n  | ISwaggerSecurityScheme.IHttpBearer\r\n  | ISwaggerSecurityScheme.IApiKey\r\n  | ISwaggerSecurityScheme.IOpenId\r\n  | ISwaggerSecurityScheme.IOAuth2;\r\nexport namespace ISwaggerSecurityScheme {\r\n  export interface IHttpBasic {\r\n    type: \"http\";\r\n    scheme: \"basic\";\r\n  }\r\n  export interface IHttpBearer {\r\n    type: \"http\";\r\n    scheme: \"bearer\";\r\n    bearerFormat?: string;\r\n  }\r\n  export interface IApiKey {\r\n    type: \"apiKey\";\r\n\r\n    /**\r\n     * @default header\r\n     */\r\n    in?: \"header\" | \"query\" | \"cookie\";\r\n\r\n    /**\r\n     * @default Authorization\r\n     */\r\n    name?: string;\r\n  }\r\n\r\n  export interface IOpenId {\r\n    type: \"openIdConnect\";\r\n    openIdConnectUrl: string;\r\n  }\r\n\r\n  export interface IOAuth2 {\r\n    type: \"oauth2\";\r\n    flows: IOAuth2.IFlowSet;\r\n    description?: string;\r\n  }\r\n  export namespace IOAuth2 {\r\n    export interface IFlowSet {\r\n      authorizationCode?: IFlow;\r\n      implicit?: Omit<IFlow, \"tokenUrl\">;\r\n      password?: Omit<IFlow, \"authorizationUrl\">;\r\n      clientCredentials?: Omit<IFlow, \"authorizationUrl\">;\r\n    }\r\n    export interface IFlow {\r\n      authorizationUrl: string;\r\n      tokenUrl: string;\r\n      refreshUrl: string;\r\n      scopes?: Record<string, string>;\r\n    }\r\n  }\r\n}\nMake nestia.config.ts file and run npx nestia swagger command.At first, create nestia.config.ts file through npx nestia init command. It would be placed on the top level directory of your NestJS backend project. For reference, tsconfig.json file also must be placed in the top level directory, too. After creation, configure the nestia.config.ts file referencing above example code and type definition.At least, you've to configure those two properties:\ninput: Accessor of controller classes\nswagger.output: Path of swagger.json file\nWhen you've completed above configuration, just run npx nestia swagger command. Then, swagger.json file would be newly generated, and placed into the $config.swagger.output directory following your nestia.config.ts configuration.By the way, nestia.config.ts supports alternative options specifying the target controller classes instead of using the Module instance. If your backend application server does not have special configuration like setGlobalPrefix, enableVersioning and RouterModule, it is okay to specifying the target controller classes just by writing their file path like below.\nimport { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  swagger: {\r\n    output: \"dist/swagger.json\",\r\n    beautify: true,\r\n    security: {\r\n      bearer: {\r\n        type: \"apiKey\",\r\n        name: \"Authorization\",\r\n        in: \"header\",\r\n      },\r\n    },\r\n    servers: [\r\n      {\r\n        url: \"http://localhost:3000\",\r\n        description: \"Local Server\",\r\n      },\r\n    ],\r\n  },\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\nimport { FastifyAdaptor } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule, new FastifyAdaptor());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  swagger: {\r\n    output: \"dist/swagger.json\",\r\n    beautify: true,\r\n    security: {\r\n      bearer: {\r\n        type: \"apiKey\",\r\n        name: \"Authorization\",\r\n        in: \"header\",\r\n      },\r\n    },\r\n    servers: [\r\n      {\r\n        url: \"http://localhost:3000\",\r\n        description: \"Local Server\",\r\n      },\r\n    ],\r\n  },\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: [\r\n    \"src/controllers\", \r\n    \"src/fake/controllers\", \r\n    \"src/test/controllers\"\r\n  ],\r\n  swagger: {\r\n    output: \"dist/swagger.json\",\r\n    beautify: true,\r\n    security: {\r\n      bearer: {\r\n        type: \"apiKey\",\r\n        name: \"Authorization\",\r\n        in: \"header\",\r\n      },\r\n    },\r\n    servers: [\r\n      {\r\n        url: \"http://localhost:3000\",\r\n        description: \"Local Server\",\r\n      },\r\n    ],\r\n  },\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: \"src/**/*.controller.ts\",\r\n  swagger: {\r\n    output: \"dist/swagger.json\",\r\n    beautify: true,\r\n    security: {\r\n      bearer: {\r\n        type: \"apiKey\",\r\n        name: \"Authorization\",\r\n        in: \"header\",\r\n      },\r\n    },\r\n    servers: [\r\n      {\r\n        url: \"http://localhost:3000\",\r\n        description: \"Local Server\",\r\n      },\r\n    ],\r\n  },\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: {\r\n    include: [\"src/controllers\"],\r\n    exclude: [\"src/**/*.fake.ts\"],\r\n  },\r\n  swagger: {\r\n    output: \"dist/swagger.json\",\r\n    beautify: true,\r\n    security: {\r\n      bearer: {\r\n        type: \"apiKey\",\r\n        name: \"Authorization\",\r\n        in: \"header\",\r\n      },\r\n    },\r\n    servers: [\r\n      {\r\n        url: \"http://localhost:3000\",\r\n        description: \"Local Server\",\r\n      },\r\n    ],\r\n  },\r\n};\r\nexport default NESTIA_CONFIG;","special-tags#Special Tags":"","controller-methods#Controller Methods":"Swagger generator @nestia/sdk supports three type of comment tags for controller methods:\nHiding\n@deprecated: mark as deprecated\n@internal: hide, never be shown\n@ignore: hide, never be shown, even in the SDK side\nLabeling\n@summary : short description of endpoint\n@tag {name}: grouppig\n@operationId {value}: manual operation ID\nSecurity\n@security {key}: security scheme key\n@security {key} {...scopes}: +scopes for OAuth2 type\nAt first, @internal and @ignore tags are used to hide the controller method from the Swagger Documents. When you use one of them, the controller method would not be written in the swagger.json file. Otherwise, the @deprecated tag is used to mark the controller method as deprecated. When you use it, Swagger Editor will show the deprecated message about the route method like below.Also, the @summary tag is used to write short description of the endpoint. By the way, the @summary tag can be replaced by writing top sentence ends with . symbol. The other one, @tag {name} tag is used for only groupping.The last one, @security is a tag for security scheme. It specifies target security scheme by writing its key like @security {key}. If target scheme type is OAuth2, and it has configured scopes, you can specify the scopes by writing scopes at the backward like @security {key} read write.For reference, target security schemes must be configured in the nestia.config.ts file. If you use @security tag that is not configured in the nestia.config.ts file, it would be an error. Also, if you've configured @nestia/swagger security decorator like @ApiSecurity, @nestia/sdk also can recognize it too.\nimport { TypedBody, TypedParam, TypedRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport { ApiSecurity } from \"@nestjs/swagger\";\r\nimport typia, { tags } from \"typia\";\r\n\r\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\r\n\r\n@Controller(\"bbs/articles/:section\")\r\nexport class BbsArticlesController {\r\n  /**\r\n   * Would be shown without any mark.\r\n   *\r\n   * @param section Section code\r\n   * @param input Content to store\r\n   * @returns Newly archived article\r\n   *\r\n   * @tag public\r\n   * @summary Public API\r\n   * @security bearer\r\n   * @security oauth2 read write\r\n   */\r\n  @TypedRoute.Post()\r\n  public async store(\r\n    @TypedParam(\"section\") section: string,\r\n    @TypedBody() input: IBbsArticle.IStore,\r\n  ): Promise<IBbsArticle> {\r\n    return {\r\n      ...typia.random<IBbsArticle>(),\r\n      ...input,\r\n      section,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Deprecated API.\r\n   *\r\n   * Would be marked as \"deprecated\".\r\n   *\r\n   * For reference, top sentence \"Deprecated API.\" can replace the `@summary` tag.\r\n   *\r\n   * @param section Section code\r\n   * @param id Target article ID\r\n   * @param input Content to update\r\n   * @returns Updated content\r\n   *\r\n   * @deprecated\r\n   * @operationId updateArticle\r\n   * @security basic\r\n   * @security bearer\r\n   */\r\n  @TypedRoute.Put(\":id\")\r\n  public async update(\r\n    @TypedParam(\"section\") section: string,\r\n    @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\r\n    @TypedBody() input: IBbsArticle.IStore,\r\n  ): Promise<IBbsArticle> {\r\n    return {\r\n      ...typia.random<IBbsArticle>(),\r\n      ...input,\r\n      id,\r\n      section,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Would not be shown.\r\n   *\r\n   * @internal\r\n   */\r\n  @ApiSecurity(\"custom\") // LEGACY DECORATOR ALSO CAN BE USED\r\n  @TypedRoute.Delete(\":id\")\r\n  public erase(\r\n    @TypedParam(\"section\") section: string,\r\n    @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\r\n  ): void {\r\n    section;\r\n    id;\r\n  }\r\n}\n{\r\n  \"openapi\": \"3.0.1\",\r\n  \"servers\": [\r\n    {\r\n      \"url\": \"https://github.com/samchon/nestia\",\r\n      \"description\": \"insert your server url\"\r\n    }\r\n  ],\r\n  \"info\": {\r\n    \"version\": \"1.0.0\",\r\n    \"title\": \"test\",\r\n    \"description\": \"\",\r\n    \"license\": {\r\n      \"name\": \"ISC\"\r\n    }\r\n  },\r\n  \"paths\": {\r\n    \"/bbs/articles/{section}\": {\r\n      \"post\": {\r\n        \"tags\": [\r\n          \"public\"\r\n        ],\r\n        \"operationId\": \"BbsArticlesController.store\",\r\n        \"parameters\": [\r\n          {\r\n            \"name\": \"section\",\r\n            \"in\": \"path\",\r\n            \"schema\": {\r\n              \"type\": \"string\"\r\n            },\r\n            \"description\": \"Section code\",\r\n            \"required\": true\r\n          }\r\n        ],\r\n        \"requestBody\": {\r\n          \"description\": \"Content to store\",\r\n          \"content\": {\r\n            \"application/json\": {\r\n              \"schema\": {\r\n                \"$ref\": \"#/components/schemas/IBbsArticle.IStore\"\r\n              }\r\n            }\r\n          },\r\n          \"required\": true\r\n        },\r\n        \"responses\": {\r\n          \"201\": {\r\n            \"description\": \"Newly archived article\",\r\n            \"content\": {\r\n              \"application/json\": {\r\n                \"schema\": {\r\n                  \"$ref\": \"#/components/schemas/IBbsArticle\"\r\n                }\r\n              }\r\n            }\r\n          }\r\n        },\r\n        \"summary\": \"Public API\",\r\n        \"description\": \"Would be shown without any mark.\",\r\n        \"security\": [\r\n          {\r\n            \"bearer\": []\r\n          },\r\n          {\r\n            \"oauth2\": [\r\n              \"read\",\r\n              \"write\"\r\n            ]\r\n          }\r\n        ]\r\n      }\r\n    },\r\n    \"/bbs/articles/{section}/{id}\": {\r\n      \"put\": {\r\n        \"deprecated\": true,\r\n        \"tags\": [],\r\n        \"operationId\": \"BbsArticlesController.update\",\r\n        \"parameters\": [\r\n          {\r\n            \"name\": \"section\",\r\n            \"in\": \"path\",\r\n            \"schema\": {\r\n              \"type\": \"string\"\r\n            },\r\n            \"description\": \"Section code\",\r\n            \"required\": true\r\n          },\r\n          {\r\n            \"name\": \"id\",\r\n            \"in\": \"path\",\r\n            \"schema\": {\r\n              \"type\": \"string\",\r\n              \"format\": \"uuid\"\r\n            },\r\n            \"description\": \"Target article ID\",\r\n            \"required\": true\r\n          }\r\n        ],\r\n        \"requestBody\": {\r\n          \"description\": \"Content to update\",\r\n          \"content\": {\r\n            \"application/json\": {\r\n              \"schema\": {\r\n                \"$ref\": \"#/components/schemas/IBbsArticle.IStore\"\r\n              }\r\n            }\r\n          },\r\n          \"required\": true\r\n        },\r\n        \"responses\": {\r\n          \"201\": {\r\n            \"description\": \"Updated content\",\r\n            \"content\": {\r\n              \"application/json\": {\r\n                \"schema\": {\r\n                  \"$ref\": \"#/components/schemas/IBbsArticle\"\r\n                }\r\n              }\r\n            }\r\n          }\r\n        },\r\n        \"summary\": \"Deprecated API\",\r\n        \"description\": \"Deprecated API.\\n\\nWould be marked as \\\"deprecated\\\".\\n\\nFor reference, top sentence \\\"Deprecated API.\\\" can replace the `@summary` tag.\",\r\n        \"security\": [\r\n          {\r\n            \"basic\": []\r\n          },\r\n          {\r\n            \"bearer\": []\r\n          }\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"components\": {\r\n    \"schemas\": {\r\n      \"IBbsArticle.IStore\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"title\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 50,\r\n            \"minLength\": 3\r\n          },\r\n          \"body\": {\r\n            \"type\": \"string\"\r\n          },\r\n          \"files\": {\r\n            \"type\": \"array\",\r\n            \"items\": {\r\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\r\n            }\r\n          }\r\n        },\r\n        \"nullable\": false,\r\n        \"required\": [\r\n          \"title\",\r\n          \"body\",\r\n          \"files\"\r\n        ]\r\n      },\r\n      \"IAttachmentFile\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"name\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 255,\r\n            \"minLength\": 1,\r\n            \"nullable\": true\r\n          },\r\n          \"extension\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 8,\r\n            \"minLength\": 1,\r\n            \"nullable\": true\r\n          },\r\n          \"url\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"url\"\r\n          }\r\n        },\r\n        \"nullable\": false,\r\n        \"required\": [\r\n          \"name\",\r\n          \"extension\",\r\n          \"url\"\r\n        ]\r\n      },\r\n      \"IBbsArticle\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"id\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"uuid\"\r\n          },\r\n          \"section\": {\r\n            \"type\": \"string\"\r\n          },\r\n          \"created_at\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"date-time\"\r\n          },\r\n          \"title\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 50,\r\n            \"minLength\": 3\r\n          },\r\n          \"body\": {\r\n            \"type\": \"string\"\r\n          },\r\n          \"files\": {\r\n            \"type\": \"array\",\r\n            \"items\": {\r\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\r\n            }\r\n          }\r\n        },\r\n        \"nullable\": false,\r\n        \"required\": [\r\n          \"id\",\r\n          \"section\",\r\n          \"created_at\",\r\n          \"title\",\r\n          \"body\",\r\n          \"files\"\r\n        ]\r\n      }\r\n    },\r\n    \"securitySchemes\": {\r\n      \"basic\": {\r\n        \"type\": \"http\",\r\n        \"scheme\": \"basic\"\r\n      },\r\n      \"bearer\": {\r\n        \"type\": \"http\",\r\n        \"scheme\": \"bearer\"\r\n      },\r\n      \"oauth2\": {\r\n        \"type\": \"oauth2\",\r\n        \"flows\": {\r\n          \"implicit\": {\r\n            \"authorizationUrl\": \"https://example.com/api/oauth/dialog\",\r\n            \"refreshUrl\": \"https://example.com/api/oauth/refresh\",\r\n            \"scopes\": {\r\n              \"read\": \"read authority\",\r\n              \"write\": \"write authority\"\r\n            }\r\n          }\r\n        }\r\n      },\r\n      \"custom\": {\r\n        \"type\": \"apiKey\",\r\n        \"in\": \"header\",\r\n        \"name\": \"Authorization\"\r\n      }\r\n    }\r\n  }\r\n}\nimport type { INestiaConfig } from \"@nestia/sdk\";\r\n\r\nexport const NESTIA_CONFIG: INestiaConfig = {\r\n  input: [\"src/controllers\"],\r\n  output: \"src/api\",\r\n  swagger: {\r\n    output: \"swagger.json\",\r\n    beautify: true,\r\n    operationId: (props) => `${props.class}.${props.function}`,\r\n    security: {\r\n      //----\r\n      // YOU CAN CHOOSE ANY SECURITY SCHEMES LIKE\r\n      //----\r\n      // @security basic\r\n      // @security bearer\r\n      // @security oauth2 read write\r\n      // @security custom\r\n      basic: {\r\n        type: \"http\",\r\n        scheme: \"basic\",\r\n      },\r\n      bearer: {\r\n        type: \"http\",\r\n        scheme: \"bearer\",\r\n      },\r\n      oauth2: {\r\n        type: \"oauth2\",\r\n        flows: {\r\n          implicit: {\r\n            authorizationUrl: \"https://example.com/api/oauth/dialog\",\r\n            refreshUrl: \"https://example.com/api/oauth/refresh\",\r\n            scopes: {\r\n              //----\r\n              // YOU CAN CHOOSE ANY SCOPES\r\n              //----\r\n              // (@security oauth2 read write) -> BOTH OF THEM\r\n              // (@security oauth2 read) -> ONE OF THEM\r\n              // (@security oauth) -> NOTHING\r\n              read: \"read authority\",\r\n              write: \"write authority\",\r\n            },\r\n          },\r\n        },\r\n      },\r\n      custom: {\r\n        type: \"apiKey\",\r\n        in: \"header\",\r\n        name: \"Authorization\",\r\n      },\r\n    },\r\n  },\r\n};\r\nexport default NESTIA_CONFIG;\n/**\r\n * Security scheme of Swagger Documents.\r\n *\r\n * `ISwaggerSecurityScheme` is a data structure representing content of\r\n * `securitySchemes` in `swagger.json` file. It is composed with 5 types of security\r\n * schemes as an union type like below.\r\n *\r\n * @reference https://swagger.io/specification/#security-scheme-object\r\n * @author Jeongho Nam - https://github.com/samchon\r\n */\r\nexport type ISwaggerSecurityScheme =\r\n  | ISwaggerSecurityScheme.IHttpBasic\r\n  | ISwaggerSecurityScheme.IHttpBearer\r\n  | ISwaggerSecurityScheme.IApiKey\r\n  | ISwaggerSecurityScheme.IOpenId\r\n  | ISwaggerSecurityScheme.IOAuth2;\r\nexport namespace ISwaggerSecurityScheme {\r\n  export interface IHttpBasic {\r\n    type: \"http\";\r\n    scheme: \"basic\";\r\n  }\r\n  export interface IHttpBearer {\r\n    type: \"http\";\r\n    scheme: \"bearer\";\r\n    bearerFormat?: string;\r\n  }\r\n  export interface IApiKey {\r\n    type: \"apiKey\";\r\n\r\n    /**\r\n     * @default header\r\n     */\r\n    in?: \"header\" | \"query\" | \"cookie\";\r\n\r\n    /**\r\n     * @default Authorization\r\n     */\r\n    name?: string;\r\n  }\r\n\r\n  export interface IOpenId {\r\n    type: \"openIdConnect\";\r\n    openIdConnectUrl: string;\r\n  }\r\n\r\n  export interface IOAuth2 {\r\n    type: \"oauth2\";\r\n    flows: IOAuth2.IFlowSet;\r\n    description?: string;\r\n  }\r\n  export namespace IOAuth2 {\r\n    export interface IFlowSet {\r\n      authorizationCode?: IFlow;\r\n      implicit?: Omit<IFlow, \"tokenUrl\">;\r\n      password?: Omit<IFlow, \"authorizationUrl\">;\r\n      clientCredentials?: Omit<IFlow, \"authorizationUrl\">;\r\n    }\r\n    export interface IFlow {\r\n      authorizationUrl: string;\r\n      tokenUrl: string;\r\n      refreshUrl: string;\r\n      scopes?: Record<string, string>;\r\n    }\r\n  }\r\n}","dto-properties#DTO Properties":"https://swagger.io/docs/specification/data-models/data-types/You can utilize comments and tags to construct special fields of JSON schema.If you write any comment on a property, it would fill the IJsonSchema.description value. When you utilize Special tags of typia, they would be placed into the proper properties of IJsonSchema. Below is the list of supported type and comment tags in the @nestia/sdk.Also, such type and comment tags of DTO properties can be used to enhance validation logic of @nestia/core library. Especially, @TypedBody.${method}(), @TypedParam(), @TypedRoute() and @TypedQuery() functions can use those tags for additional validation.Let's see how those type and comment tags work with example code.\nnumber\nnumber & Type<{keyword}>\nint32\nuint32\nuint64\nint64\nfloat\ndouble\nnumber & Minimum<{number}>\nnumber & Maximum<{number}>\nnumber & ExclusiveMaximum<{number}>\nnumber & ExclusiveMinimum<{number}>\nnumber & MultipleOf<{number}>\nbigint\nbigint & Type<{keyword}>\nint64\nuint64\nbigint & Minimum<{bigint}>\nbigint & Maximum<{bigint}>\nbigint & ExclusiveMaximum<{bigint}>\nbigint & ExclusiveMinimum<{bigint}>\nbigint & MultipleOf<{bigint}>\nstring\nstring & MinLength<{number}>\nstring & MaxLength<{number}>\nstring & Pattern<{regex}>\nstring & Format<{keyword}>\nemail\nuuid\nipv4\nipv6\nurl\ndate: YYYY-MM-DD\ndate-time: Date.toISOString()\nexport interface SpecialTag {\r\n  /**\r\n   * Deprecated tags are just used for marking.\r\n   *\r\n   * @title Unsigned integer\r\n   * @deprecated\r\n   */\r\n  type: number & tags.Type<\"uint32\">;\r\n\r\n  /**\r\n   * Internal tagged property never be shown in JSON schema.\r\n   *\r\n   * It even doesn't be shown in other `typia` functions like `assert<T>()`.\r\n   *\r\n   * @internal\r\n   */\r\n  internal: number[];\r\n\r\n  /**\r\n   * Hidden tagged property never be shown in JSON schema.\r\n   *\r\n   * However, it would be shown in other `typia` functions like `stringify<T>()`.\r\n   *\r\n   * @hidden\r\n   */\r\n  hidden: boolean;\r\n\r\n  /**\r\n   * You can limit the range of number.\r\n   *\r\n   * Also, you can configure `default` property by comment tag.\r\n   *\r\n   * @default 30\r\n   */\r\n  number?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\r\n\r\n  /**\r\n   * You can limit the length of string.\r\n   */\r\n  string: string & tags.MinLength<3>;\r\n\r\n  /**\r\n   * You can limit the pattern of string.\r\n   */\r\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\r\n\r\n  /**\r\n   * You can limit the format of string.\r\n   */\r\n  format: null | (string & tags.Format<\"date-time\">);\r\n\r\n  /**\r\n   * You also can perform union type in type tags.\r\n   */\r\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\r\n\r\n  /**\r\n   * In the Array case, only type tags can limit elements' type.\r\n   */\r\n  array: Array<string & tags.Format<\"uuid\">> &\r\n    tags.MinItems<3> &\r\n    tags.MaxItems<100>;\r\n}\n{\r\n  \"SpecialTag\": {\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n      \"type\": {\r\n        \"deprecated\": true,\r\n        \"title\": \"Unsigned integer\",\r\n        \"description\": \"Deprecated tags are just used for marking.\",\r\n        \"type\": \"integer\"\r\n      },\r\n      \"number\": {\r\n        \"description\": \"You can limit the range of number.\\n\\nAlso, you can configure `default` property by comment tag.\",\r\n        \"type\": \"number\",\r\n        \"minimum\": 19,\r\n        \"exclusiveMinimum\": true,\r\n        \"maximum\": 100,\r\n        \"default\": 30\r\n      },\r\n      \"string\": {\r\n        \"description\": \"You can limit the length of string.\",\r\n        \"type\": \"string\",\r\n        \"minLength\": 3\r\n      },\r\n      \"pattern\": {\r\n        \"description\": \"You can limit the pattern of string.\",\r\n        \"type\": \"string\",\r\n        \"pattern\": \"^[a-z]+$\"\r\n      },\r\n      \"format\": {\r\n        \"description\": \"You can limit the format of string.\",\r\n        \"type\": \"string\",\r\n        \"format\": \"date-time\",\r\n        \"nullable\": true\r\n      },\r\n      \"ip\": {\r\n        \"oneOf\": [\r\n          {\r\n            \"description\": \"You also can perform union type in type tags.\",\r\n            \"type\": \"string\",\r\n            \"format\": \"ipv4\"\r\n          },\r\n          {\r\n            \"description\": \"You also can perform union type in type tags.\",\r\n            \"type\": \"string\",\r\n            \"format\": \"ipv6\"\r\n          }\r\n        ],\r\n        \"description\": \"You also can perform union type in type tags.\"\r\n      },\r\n      \"array\": {\r\n        \"description\": \"In the Array case, only type tags can limit elements' type.\",\r\n        \"type\": \"array\",\r\n        \"items\": {\r\n          \"description\": \"In the Array case, only type tags can limit elements' type.\",\r\n          \"type\": \"string\",\r\n          \"format\": \"uuid\"\r\n        },\r\n        \"maxItems\": 100,\r\n        \"minItems\": 3\r\n      }\r\n    },\r\n    \"nullable\": false,\r\n    \"required\": [\r\n      \"type\",\r\n      \"string\",\r\n      \"pattern\",\r\n      \"format\",\r\n      \"ip\",\r\n      \"array\"\r\n    ]\r\n  }\r\n}\n/**\r\n * Security schema of Swagger Documents.\r\n *\r\n * `ISwaggerSecurityScheme` is a data structure representing content of\r\n * `securitySchemes` in `swagger.json` file. It is composed with 5 types of security\r\n * schemes as an union type like below.\r\n *\r\n * @reference https://swagger.io/specification/#security-scheme-object\r\n * @author Jeongho Nam - https://github.com/samchon\r\n */\r\nexport type ISwaggerSecurityScheme =\r\n  | ISwaggerSecurityScheme.IHttpBasic\r\n  | ISwaggerSecurityScheme.IHttpBearer\r\n  | ISwaggerSecurityScheme.IApiKey\r\n  | ISwaggerSecurityScheme.IOpenId\r\n  | ISwaggerSecurityScheme.IOAuth2;\r\nexport namespace ISwaggerSecurityScheme {\r\n  export interface IHttpBasic {\r\n    type: \"http\";\r\n    scheme: \"basic\";\r\n  }\r\n  export interface IHttpBearer {\r\n    type: \"http\";\r\n    scheme: \"bearer\";\r\n    bearerFormat?: string;\r\n  }\r\n  export interface IApiKey {\r\n    type: \"apiKey\";\r\n\r\n    /**\r\n     * @default header\r\n     */\r\n    in?: \"header\" | \"query\" | \"cookie\";\r\n\r\n    /**\r\n     * @default Authorization\r\n     */\r\n    name?: string;\r\n  }\r\n\r\n  export interface IOpenId {\r\n    type: \"openIdConnect\";\r\n    openIdConnectUrl: string;\r\n  }\r\n\r\n  export interface IOAuth2 {\r\n    type: \"oauth2\";\r\n    flows: IOAuth2.IFlowSet;\r\n    description?: string;\r\n  }\r\n  export namespace IOAuth2 {\r\n    export interface IFlowSet {\r\n      authorizationCode?: IFlow;\r\n      implicit?: Omit<IFlow, \"tokenUrl\">;\r\n      password?: Omit<IFlow, \"authorizationUrl\">;\r\n      clientCredentials?: Omit<IFlow, \"authorizationUrl\">;\r\n    }\r\n    export interface IFlow {\r\n      authorizationUrl: string;\r\n      tokenUrl: string;\r\n      refreshUrl: string;\r\n      scopes?: Record<string, string>;\r\n    }\r\n  }\r\n}","distribution#Distribution":"You can choose two options for swagger.json file distribution.The 1st is publishing the swagger.json file in a public repo, and showing it through Swagger Editor like below:\nsamchon/bbs-backend: Swagger Editor\nsamchon/fake-iamport-server: Swagger Editor\nsamchon/fake-toss-payments-server: Swagger Editor\nThe 2nd way is to hosting the swagger.json file in the NestJS backend server.Read below example code, and follow it on yours:\nimport { NestFactory } from \"@nestjs/core\";\r\nimport { SwaggerModule } from \"@nestjs/swagger\";\r\nimport fs from \"fs\";\r\n\r\nasync function open(): Promise<void> {\r\n  const app = await NestFactory.create({...});\r\n\r\n  const docs = require(\"...write swagger.json path\");\r\n  docs.servers = [{ url: \"write your server URL\" }];\r\n  SwaggerModule.setup(\"swagger\", app, docs);\r\n\r\n  await app.listen(8080);\r\n}"}}}