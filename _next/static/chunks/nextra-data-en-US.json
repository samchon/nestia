{"/docs/core/TypedException":{"title":"Guide Documents > Core Library > TypedException","data":{"outline#Outline":"export function TypedException<T extends object>(\r\n  status: number | \"2XX\" | \"3XX\" | \"4XX\" | \"5XX\",\r\n  description?: string,\r\n): MethodDecorator;\r\nexport function TypedException<T extends object>(props: {\r\n  status: : number | \"2XX\" | \"3XX\" | \"4XX\" | \"5XX\";\r\n  description?: string;\r\n  example?: T;\r\n  examples?: Record<string, T>;\r\n}): MethodDecorator;\nException decorator of HTTP responses.TypedException is a decorator function describing HTTP exception and its type which could be occurred in a controller method. For reference, this decorator function does not affect to the method's behavior, but affects to the swagger documents generation, or SDK functions when propagation mode being used.","how-to-use#How to use":"import { Controller } from \"@nestjs/common\";\r\nimport typia, { TypeGuardError } from \"typia\";\r\n\r\nimport {\r\n  TypedBody,\r\n  TypedException,\r\n  TypedParam,\r\n  TypedRoute,\r\n} from \"@nestia/core\";\r\n\r\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\r\nimport { IInternalServerError } from \"@api/lib/structures/IInternalServerError\";\r\nimport { INotFound } from \"@api/lib/structures/INotFound\";\r\nimport { IUnprocessibleEntity } from \"@api/lib/structures/IUnprocessibleEntity\";\r\n\r\n@Controller(\"exception\")\r\nexport class ExceptionController {\r\n  @TypedRoute.Post(\":section/typed\")\r\n  @TypedException<TypeGuardError>({\r\n    status: 400, \r\n    description: \"invalid request\",\r\n    example: {\r\n      name: \"BadRequestException\",\r\n      method: \"TypedBody\",\r\n      path: \"$input.title\",\r\n      expected: \"string\",\r\n      value: 123,\r\n      message: \"invalid type\",\r\n    },\r\n  })\r\n  @TypedException<INotFound>(404, \"unable to find the matched section\")\r\n  @TypedException<IUnprocessibleEntity>(428)\r\n  @TypedException<IInternalServerError>(\"5XX\", \"internal server error\")\r\n  public async typed(\r\n    @TypedParam(\"section\") section: string,\r\n    @TypedBody() input: IBbsArticle.IStore,\r\n  ): Promise<IBbsArticle> {\r\n    section;\r\n    input;\r\n    return typia.random<IBbsArticle>();\r\n  }\r\n}\nJust call TypedException() function with target type and status code.If you want to add description or example value, you also can add it as a property.For reference, swagger allows to special pattern like 2XX, 3XX, 4XX, 5XX for status code.","swagger-example#Swagger Example":"Here is an example of swagger documents utilizing the @TypedException() decorator.\n{\r\n  \"openapi\": \"3.1.0\",\r\n  \"servers\": [\r\n    {\r\n      \"url\": \"https://github.com/samchon/nestia\",\r\n      \"description\": \"insert your server url\"\r\n    }\r\n  ],\r\n  \"info\": {\r\n    \"version\": \"3.11.1\",\r\n    \"title\": \"@samchon/nestia-test\",\r\n    \"description\": \"Test program of Nestia\",\r\n    \"license\": {\r\n      \"name\": \"MIT\"\r\n    }\r\n  },\r\n  \"paths\": {\r\n    \"/exception/{section}/typed\": {\r\n      \"post\": {\r\n        \"tags\": [],\r\n        \"parameters\": [\r\n          {\r\n            \"name\": \"section\",\r\n            \"in\": \"path\",\r\n            \"schema\": {\r\n              \"type\": \"string\"\r\n            },\r\n            \"required\": true\r\n          }\r\n        ],\r\n        \"requestBody\": {\r\n          \"content\": {\r\n            \"application/json\": {\r\n              \"schema\": {\r\n                \"$ref\": \"#/components/schemas/IBbsArticle.IStore\"\r\n              }\r\n            }\r\n          },\r\n          \"required\": true\r\n        },\r\n        \"responses\": {\r\n          \"201\": {\r\n            \"content\": {\r\n              \"application/json\": {\r\n                \"schema\": {\r\n                  \"$ref\": \"#/components/schemas/IBbsArticle\"\r\n                }\r\n              }\r\n            }\r\n          },\r\n          \"400\": {\r\n            \"description\": \"invalid request\",\r\n            \"content\": {\r\n              \"application/json\": {\r\n                \"schema\": {\r\n                  \"$ref\": \"#/components/schemas/TypeGuardErrorany\"\r\n                },\r\n                \"example\": {\r\n                  \"name\": \"BadRequestException\",\r\n                  \"method\": \"TypedBody\",\r\n                  \"path\": \"$input.title\",\r\n                  \"expected\": \"string\",\r\n                  \"value\": 123,\r\n                  \"message\": \"invalid type\"\r\n                }\r\n              }\r\n            }\r\n          },\r\n          \"404\": {\r\n            \"description\": \"unable to find the matched section\",\r\n            \"content\": {\r\n              \"application/json\": {\r\n                \"schema\": {\r\n                  \"$ref\": \"#/components/schemas/INotFound\"\r\n                }\r\n              }\r\n            }\r\n          },\r\n          \"428\": {\r\n            \"content\": {\r\n              \"application/json\": {\r\n                \"schema\": {\r\n                  \"$ref\": \"#/components/schemas/IUnprocessibleEntity\"\r\n                }\r\n              }\r\n            }\r\n          },\r\n          \"5XX\": {\r\n            \"description\": \"internal server error\",\r\n            \"content\": {\r\n              \"application/json\": {\r\n                \"schema\": {\r\n                  \"$ref\": \"#/components/schemas/IInternalServerError\"\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n  \"components\": {\r\n    \"schemas\": {\r\n      \"IBbsArticle\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"id\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"uuid\"\r\n          },\r\n          \"created_at\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"date-time\"\r\n          },\r\n          \"title\": {\r\n            \"type\": \"string\",\r\n            \"minLength\": 3,\r\n            \"maxLength\": 50\r\n          },\r\n          \"body\": {\r\n            \"type\": \"string\"\r\n          },\r\n          \"files\": {\r\n            \"type\": \"array\",\r\n            \"items\": {\r\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\r\n            }\r\n          }\r\n        },\r\n        \"required\": [\r\n          \"id\",\r\n          \"created_at\",\r\n          \"title\",\r\n          \"body\",\r\n          \"files\"\r\n        ]\r\n      },\r\n      \"IAttachmentFile\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"name\": {\r\n            \"oneOf\": [\r\n              {\r\n                \"type\": \"null\"\r\n              },\r\n              {\r\n                \"type\": \"string\",\r\n                \"maxLength\": 255\r\n              }\r\n            ]\r\n          },\r\n          \"extension\": {\r\n            \"oneOf\": [\r\n              {\r\n                \"type\": \"null\"\r\n              },\r\n              {\r\n                \"type\": \"string\",\r\n                \"minLength\": 1,\r\n                \"maxLength\": 8\r\n              }\r\n            ]\r\n          },\r\n          \"url\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"uri\"\r\n          }\r\n        },\r\n        \"required\": [\r\n          \"name\",\r\n          \"extension\",\r\n          \"url\"\r\n        ]\r\n      },\r\n      \"IBbsArticle.IStore\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"title\": {\r\n            \"type\": \"string\",\r\n            \"minLength\": 3,\r\n            \"maxLength\": 50\r\n          },\r\n          \"body\": {\r\n            \"type\": \"string\"\r\n          },\r\n          \"files\": {\r\n            \"type\": \"array\",\r\n            \"items\": {\r\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\r\n            }\r\n          }\r\n        },\r\n        \"required\": [\r\n          \"title\",\r\n          \"body\",\r\n          \"files\"\r\n        ]\r\n      },\r\n      \"TypeGuardErrorany\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"method\": {\r\n            \"type\": \"string\"\r\n          },\r\n          \"path\": {\r\n            \"type\": \"string\"\r\n          },\r\n          \"expected\": {\r\n            \"type\": \"string\"\r\n          },\r\n          \"value\": {},\r\n          \"fake_expected_typed_value_\": {},\r\n          \"name\": {\r\n            \"type\": \"string\"\r\n          },\r\n          \"message\": {\r\n            \"type\": \"string\"\r\n          },\r\n          \"stack\": {\r\n            \"type\": \"string\"\r\n          }\r\n        },\r\n        \"required\": [\r\n          \"method\",\r\n          \"expected\",\r\n          \"value\",\r\n          \"name\",\r\n          \"message\"\r\n        ]\r\n      },\r\n      \"INotFound\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"schema\": {\r\n            \"type\": \"string\"\r\n          },\r\n          \"table\": {\r\n            \"type\": \"string\"\r\n          },\r\n          \"id\": {\r\n            \"type\": \"string\"\r\n          }\r\n        },\r\n        \"required\": [\r\n          \"schema\",\r\n          \"table\",\r\n          \"id\"\r\n        ]\r\n      },\r\n      \"IUnprocessibleEntity\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"reason\": {\r\n            \"type\": \"string\"\r\n          }\r\n        },\r\n        \"required\": [\r\n          \"reason\"\r\n        ]\r\n      },\r\n      \"IInternalServerError\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"name\": {\r\n            \"type\": \"string\"\r\n          },\r\n          \"message\": {\r\n            \"type\": \"string\"\r\n          },\r\n          \"stack\": {\r\n            \"type\": \"array\",\r\n            \"items\": {\r\n              \"type\": \"string\"\r\n            }\r\n          }\r\n        },\r\n        \"required\": [\r\n          \"name\",\r\n          \"message\",\r\n          \"stack\"\r\n        ]\r\n      }\r\n    },\r\n    \"securitySchemes\": {\r\n      \"bearer\": {\r\n        \"type\": \"apiKey\"\r\n      }\r\n    }\r\n  },\r\n  \"tags\": [],\r\n  \"x-samchon-emended\": true\r\n}"}},"/docs/core/TypedParam":{"title":"Guide Documents > Core Library > TypedParam","data":{"outline#Outline":"export function TypedParam(name: string): ParameterDecorator;\nType safe path parameter decorator.@TypedParam() is a decorator parsing path parameter.It's almost same with original @Param() function of NestJS, however, @TypedParam() is more type safe.As @TypedParam() can anlayze source code in the compilation level, it can specify parameter type by itself. Also, while NestJS cannot distinguish nullable type and consider every parameter value as a string type, @TypedParam() can do it. Furthermore, @TypedParam() can validate special types like \"uuid\" or \"date\".Let's read below example code, and see how @TypedParam() works.\n@TypedParam() is not essential for Swagger Documents or SDK Library building.Therefore, it is not a matter to use @TypedParam() or @Param() of the original NestJS.","how-to-use#How to use":"import { TypedParam } from \"@nestia/core\";\r\nimport { Controller, Get } from \"@nestjs/common\";\r\nimport { tags } from \"typia\";\r\n\r\n@Controller(\"parameters\")\r\nexport class ParametersController {\r\n  @Get(\"uint32/:value\")\r\n  public async uint32(\r\n    @TypedParam(\"value\") value: (number & tags.Type<\"uint32\">) | null,\r\n  ): Promise<(number & tags.Type<\"uint32\">) | null> {\r\n    return value;\r\n  }\r\n\r\n  @Get(\"string/:value\")\r\n  public async string(\r\n    @TypedParam(\"value\") value: string\r\n  ): Promise<string> {\r\n    return value;\r\n  }\r\n\r\n  @Get(\"uuid/:value\")\r\n  public async uuid(\r\n    @TypedParam(\"value\") value: string & tags.Format<\"uuid\">,\r\n  ): Promise<string> {\r\n    return value;\r\n  }\r\n}\n\"use strict\";\r\nvar __decorate =\r\n  (this && this.__decorate) ||\r\n  function (decorators, target, key, desc) {\r\n    var c = arguments.length,\r\n      r =\r\n        c < 3\r\n          ? target\r\n          : desc === null\r\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\r\n          : desc,\r\n      d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\r\n      r = Reflect.decorate(decorators, target, key, desc);\r\n    else\r\n      for (var i = decorators.length - 1; i >= 0; i--)\r\n        if ((d = decorators[i]))\r\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n  };\r\nvar __metadata =\r\n  (this && this.__metadata) ||\r\n  function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\r\n      return Reflect.metadata(k, v);\r\n  };\r\nvar __param =\r\n  (this && this.__param) ||\r\n  function (paramIndex, decorator) {\r\n    return function (target, key) {\r\n      decorator(target, key, paramIndex);\r\n    };\r\n  };\r\nvar __awaiter =\r\n  (this && this.__awaiter) ||\r\n  function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) {\r\n      return value instanceof P\r\n        ? value\r\n        : new P(function (resolve) {\r\n            resolve(value);\r\n          });\r\n    }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n      function fulfilled(value) {\r\n        try {\r\n          step(generator.next(value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function rejected(value) {\r\n        try {\r\n          step(generator[\"throw\"](value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function step(result) {\r\n        result.done\r\n          ? resolve(result.value)\r\n          : adopt(result.value).then(fulfilled, rejected);\r\n      }\r\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ParametersController = void 0;\r\nconst core_1 = require(\"@nestia/core\");\r\nconst common_1 = require(\"@nestjs/common\");\r\nlet ParametersController = class ParametersController {\r\n  uint32(value) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return value;\r\n    });\r\n  }\r\n  string(value) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return value;\r\n    });\r\n  }\r\n  uuid(value) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return value;\r\n    });\r\n  }\r\n};\r\nexports.ParametersController = ParametersController;\r\n__decorate(\r\n  [\r\n    (0, common_1.Get)(\"uint32/:value\"),\r\n    __param(\r\n      0,\r\n      (0, core_1.TypedParam)(\"value\", {\r\n        name: '((number & Type<\"uint32\">) | null)',\r\n        is: (input) => {\r\n          return (\r\n            null === input ||\r\n            (\"number\" === typeof input &&\r\n              Math.floor(input) === input &&\r\n              0 <= input &&\r\n              input <= 4294967295)\r\n          );\r\n        },\r\n        cast: (str) => (\"null\" === str ? null : Number(str)),\r\n      }),\r\n    ),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object]),\r\n    __metadata(\"design:returntype\", Promise),\r\n  ],\r\n  ParametersController.prototype,\r\n  \"uint32\",\r\n  null,\r\n);\r\n__decorate(\r\n  [\r\n    (0, common_1.Get)(\"string/:value\"),\r\n    __param(\r\n      0,\r\n      (0, core_1.TypedParam)(\"value\", {\r\n        name: \"string\",\r\n        is: (input) => {\r\n          return \"string\" === typeof input;\r\n        },\r\n        cast: (str) => str,\r\n      }),\r\n    ),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [String]),\r\n    __metadata(\"design:returntype\", Promise),\r\n  ],\r\n  ParametersController.prototype,\r\n  \"string\",\r\n  null,\r\n);\r\n__decorate(\r\n  [\r\n    (0, common_1.Get)(\"uuid/:value\"),\r\n    __param(\r\n      0,\r\n      (0, core_1.TypedParam)(\"value\", {\r\n        name: '(string & Format<\"uuid\">)',\r\n        is: (input) => {\r\n          return (\r\n            \"string\" === typeof input &&\r\n            /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n              input,\r\n            )\r\n          );\r\n        },\r\n        cast: (str) => str,\r\n      }),\r\n    ),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object]),\r\n    __metadata(\"design:returntype\", Promise),\r\n  ],\r\n  ParametersController.prototype,\r\n  \"uuid\",\r\n  null,\r\n);\r\nexports.ParametersController = ParametersController = __decorate(\r\n  [(0, common_1.Controller)(\"parameters\")],\r\n  ParametersController,\r\n);\nJust call @TypedParam() function on the path parameter, that's all.If you want to special parameter type like \"uint32\" or \"uuid\", utilize type tags of typia.When wrong typed value comes, 400 bad request error would be thrown.","restriction#Restriction":"@TypedParam() allows only atomic type.\nboolean\nnumber\nstring\nbigint\nAlso, @TypedParam() allows nullable like number | null, but undefindable type is not.\nnumber | null is allowed\nstring | undefined is prohibited\nIf you violate above condition, and try to declare object or union type, compilation error would be occurred:\nError on nestia.core.TypedParam(): only atomic type is allowed"}},"/docs/editor":{"title":"Guide Documents > TypeScript Swagger Editor","data":{"":"The path has been changed to /docs/swagger/editor/.Please wait for a moment while you are redirected to the new page."}},"/docs/e2e/development":{"title":"Guide Documents > E2E Testing > Test Program Development","data":{"outline#Outline":"Test your backend server with e2e test functions.If you've succeeded to generate SDK library by @nestia/sdk, you can utilize the SDK library to implement e2e test functions. As the SDK library ensures types safety for remote API calls, you can develop much more efficient and safer test program than unit testing case.If you want to pre-experience the test program utliizng the e2e test functions of @nestia/sdk, visit below playground website.💻 https://stackblitz.com/~/github.com/samchon/nestia-start\n- test_api_bbs_article_at: 149 ms\r\n- test_api_bbs_article_create: 30 ms\r\n- test_api_bbs_article_index_search: 1,312 ms\r\n- test_api_bbs_article_index_sort: 1,110 ms\r\n- test_api_bbs_article_update: 28 m","main-program#Main Program":"import { DynamicExecutor } from \"@nestia/e2e\";\r\n\r\nimport api from \"@ORGANIZATION/PROJECT-api\";\r\n\r\nimport { MyBackend } from \"../src/MyBackend\";\r\nimport { MyConfiguration } from \"../src/MyConfiguration\";\r\nimport { MyGlobal } from \"../src/MyGlobal\";\r\nimport { ArgumentParser } from \"./helpers/ArgumentParser\";\r\n\r\ninterface IOptions {\r\n  include?: string[];\r\n  exclude?: string[];\r\n}\r\n\r\nconst getOptions = () =>\r\n  ArgumentParser.parse<IOptions>(async (command, _prompt, action) => {\r\n    // command.option(\"--mode <string>\", \"target mode\");\r\n    // command.option(\"--reset <true|false>\", \"reset local DB or not\");\r\n    command.option(\"--include <string...>\", \"include feature files\");\r\n    command.option(\"--exclude <string...>\", \"exclude feature files\");\r\n\r\n    return action(async (options) => {\r\n      // if (typeof options.reset === \"string\")\r\n      //     options.reset = options.reset === \"true\";\r\n      // options.mode ??= await prompt.select(\"mode\")(\"Select mode\")([\r\n      //     \"LOCAL\",\r\n      //     \"DEV\",\r\n      //     \"REAL\",\r\n      // ]);\r\n      // options.reset ??= await prompt.boolean(\"reset\")(\"Reset local DB\");\r\n      return options as IOptions;\r\n    });\r\n  });\r\n\r\nasync function main(): Promise<void> {\r\n  // CONFIGURATIONS\r\n  const options: IOptions = await getOptions();\r\n  MyGlobal.testing = true;\r\n\r\n  // BACKEND SERVER\r\n  const backend: MyBackend = new MyBackend();\r\n  await backend.open();\r\n\r\n  //----\r\n  // CLIENT CONNECTOR\r\n  //----\r\n  // DO TEST\r\n  const connection: api.IConnection = {\r\n    host: `http://127.0.0.1:${MyConfiguration.API_PORT()}`,\r\n  };\r\n  const report: DynamicExecutor.IReport = await DynamicExecutor.validate({\r\n    prefix: \"test\",\r\n    parameters: () => [{ ...connection }],\r\n    filter: (func) =>\r\n      (!options.include?.length ||\r\n        (options.include ?? []).some((str) => func.includes(str))) &&\r\n      (!options.exclude?.length ||\r\n        (options.exclude ?? []).every((str) => !func.includes(str))),\r\n  })(__dirname + \"/features\");\r\n\r\n  await backend.close();\r\n\r\n  const failures: DynamicExecutor.IReport.IExecution[] =\r\n    report.executions.filter((exec) => exec.error !== null);\r\n  if (failures.length === 0) {\r\n    console.log(\"Success\");\r\n    console.log(\"Elapsed time\", report.time.toLocaleString(), `ms`);\r\n  } else {\r\n    for (const f of failures) console.log(f.error);\r\n    process.exit(-1);\r\n  }\r\n\r\n  console.log(\r\n    [\r\n      `All: #${report.executions.length}`,\r\n      `Success: #${report.executions.length - failures.length}`,\r\n      `Failed: #${failures.length}`,\r\n    ].join(\"\\n\"),\r\n  );\r\n}\r\nmain().catch((exp) => {\r\n  console.log(exp);\r\n  process.exit(-1);\r\n});\nTo compose the test program of @nestia/e2e on your backend application, you have to create one executable TypeScript program.The main program is executed by user (npm run benchmark command in the playground project), and it runs every (or some filtered) e2e test functions located in the target directory. In above case, test/features is the directory collecting e2e test functions.If you want to see more test program cases, visit below links:\nsamchon/nestia-start\nsamchon/backend","test-functions#Test Functions":"import { RandomGenerator, TestValidator } from \"@nestia/e2e\";\r\nimport { v4 } from \"uuid\";\r\n\r\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\r\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\r\n\r\nexport async function test_api_bbs_article_create(\r\n  connection: api.IConnection,\r\n): Promise<void> {\r\n  // STORE A NEW ARTICLE\r\n  const stored: IBbsArticle = await api.functional.bbs.articles.create(\r\n    connection,\r\n    \"general\",\r\n    {\r\n      writer: RandomGenerator.name(),\r\n      title: RandomGenerator.paragraph(3)(),\r\n      body: RandomGenerator.content(8)()(),\r\n      format: \"txt\",\r\n      files: [\r\n        {\r\n          name: \"logo\",\r\n          extension: \"png\",\r\n          url: \"https://somewhere.com/logo.png\",\r\n        },\r\n      ],\r\n      password: v4(),\r\n    },\r\n  );\r\n\r\n  // READ THE DATA AGAIN\r\n  const read: IBbsArticle = await api.functional.bbs.articles.at(\r\n    connection,\r\n    stored.section,\r\n    stored.id,\r\n  );\r\n  TestValidator.equals(\"created\")(stored)(read);\r\n}\nimport { RandomGenerator, TestValidator } from \"@nestia/e2e\";\r\nimport { v4 } from \"uuid\";\r\n\r\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\r\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\r\n\r\nexport async function test_api_bbs_article_update(\r\n  connection: api.IConnection,\r\n): Promise<void> {\r\n  // STORE A NEW ARTICLE\r\n  const password: string = v4();\r\n  const article: IBbsArticle = await api.functional.bbs.articles.create(\r\n    connection,\r\n    \"general\",\r\n    {\r\n      writer: RandomGenerator.name(),\r\n      title: RandomGenerator.paragraph(3)(),\r\n      body: RandomGenerator.content(8)()(),\r\n      format: \"txt\",\r\n      files: [\r\n        {\r\n          name: \"logo\",\r\n          extension: \"png\",\r\n          url: \"https://somewhere.com/logo.png\",\r\n        },\r\n      ],\r\n      password,\r\n    },\r\n  );\r\n\r\n  // UPDATE WITH EXACT PASSWORD\r\n  const content: IBbsArticle.ISnapshot =\r\n    await api.functional.bbs.articles.update(\r\n      connection,\r\n      article.section,\r\n      article.id,\r\n      {\r\n        title: RandomGenerator.paragraph(3)(),\r\n        body: RandomGenerator.content(8)()(),\r\n        format: \"txt\",\r\n        files: [],\r\n        password,\r\n      },\r\n    );\r\n  article.snapshots.push(content);\r\n\r\n  // TRY UPDATE WITH WRONG PASSWORD\r\n  await TestValidator.error(\"update with wrong password\")(() =>\r\n    api.functional.bbs.articles.update(\r\n      connection,\r\n      article.section,\r\n      article.id,\r\n      {\r\n        title: RandomGenerator.paragraph(5)(),\r\n        body: RandomGenerator.content(8)()(),\r\n        format: \"txt\",\r\n        files: [],\r\n        password: v4(),\r\n      },\r\n    ),\r\n  );\r\n}\nimport { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\r\n\r\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\r\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\r\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/common/IPage\";\r\n\r\nexport async function test_api_bbs_article_index_search(\r\n  connection: api.IConnection,\r\n): Promise<void> {\r\n  // GENERATE 100 ARTICLES\r\n  const section: string = \"general\";\r\n  const articles: IBbsArticle[] = await ArrayUtil.asyncRepeat(100)(() =>\r\n    api.functional.bbs.articles.create(connection, section, {\r\n      writer: RandomGenerator.name(),\r\n      title: RandomGenerator.paragraph(4)(),\r\n      body: RandomGenerator.content(3)()(),\r\n      format: \"txt\",\r\n      files: [],\r\n      password: RandomGenerator.alphabets(8),\r\n    }),\r\n  );\r\n\r\n  // GET ENTIRE DATA\r\n  const total: IPage<IBbsArticle.ISummary> =\r\n    await api.functional.bbs.articles.index(connection, section, {\r\n      limit: articles.length,\r\n      sort: [\"-created_at\"],\r\n    });\r\n\r\n  // PREPARE SEARCH FUNCTION\r\n  const search = TestValidator.search(\"BbsArticleProvider.index()\")(\r\n    async (input: IBbsArticle.IRequest.ISearch) => {\r\n      const page: IPage<IBbsArticle.ISummary> =\r\n        await api.functional.bbs.articles.index(connection, section, {\r\n          limit: articles.length,\r\n          search: input,\r\n          sort: [\"-created_at\"],\r\n        });\r\n      return page.data;\r\n    },\r\n  )(total.data, 10);\r\n\r\n  // SEARCH TITLE\r\n  await search({\r\n    fields: [\"title\"],\r\n    values: (article) => [article.title],\r\n    request: ([title]) => ({ title }),\r\n    filter: (article, [title]) => article.title.includes(title),\r\n  });\r\n\r\n  // SEARCH WRITER\r\n  await search({\r\n    fields: [\"writer\"],\r\n    values: (article) => [article.writer],\r\n    request: ([writer]) => ({ writer }),\r\n    filter: (article, [writer]) => article.writer.includes(writer),\r\n  });\r\n\r\n  // SEARCH BOTH OF THEM\r\n  await search({\r\n    fields: [\"title\", \"writer\"],\r\n    values: (article) => [article.title, article.writer],\r\n    request: ([title, writer]) => ({ title, writer }),\r\n    filter: (article, [title, writer]) =>\r\n      article.title.includes(title) && article.writer.includes(writer),\r\n  });\r\n}\nDeveloping e2e test functions are very easy. Just make e2e based test function utilizing @nestia/sdk generated SDK library, and exports the function with test_ prefixed name (If you've configured another prefix property in the test main program, just follow the configuration).Also, make the function to have parameter(s) configured in the servant program of the benchmark. As above test functions are examples of playground project that has configured to have only one connection parameter, All of them have the only one parameter connection.After composing these e2e test functions, just execute the test main program. In the playground project, it can be executed by npm run test command. The test program will run these e2e test functions, and report if some bugs be occurred.\ngit clone https://github.com/samchon/nestia-start\r\ncd nestia-start\r\nnpm install\r\nnpm run build:test\r\nnpm run test"}},"/docs/migrate":{"title":"Guide Documents > Migration from Swagger to NestJS","data":{"":"The path has been changed to /docs/swagger/editor/.Please wait for a moment while you are redirected to the new page."}},"/docs/e2e/benchmark":{"title":"Guide Documents > E2E Testing > Benchmark","data":{"outline#Outline":"Benchmark your backend server with e2e test functions.If you've developed e2e test functions utilizing SDK library of @nestia/sdk, you can re-use those e2e test functions in the benchmark program supported by @nestia/benchmark. The benchmark program will run these e2e test functions in parallel and randomly to measure the performance of your backend server.If you want to pre-experience the benchmark program utliizng the e2e test functions of @nestia/sdk, visit below playground website. Also, here is the benchmark report example generated by the benchmark program of @nestia/benchmark executed in the below playground link.\n💻 https://stackblitz.com/~/github.com/samchon/nestia-start\n? Number of requests to make 1024\r\n? Number of threads to use 4\r\n? Number of simultaneous requests to make 32\r\n████████████████████████████████████████ 100% | ETA: 0s | 3654/1024","main-program#Main Program":"import { DynamicBenchmarker } from \"@nestia/benchmark\";\r\nimport cliProgress from \"cli-progress\";\r\nimport fs from \"fs\";\r\nimport os from \"os\";\r\nimport { IPointer } from \"tstl\";\r\n\r\nimport { MyBackend } from \"../../src/MyBackend\";\r\nimport { MyConfiguration } from \"../../src/MyConfiguration\";\r\nimport { MyGlobal } from \"../../src/MyGlobal\";\r\nimport { ArgumentParser } from \"../helpers/ArgumentParser\";\r\n\r\ninterface IOptions {\r\n  include?: string[];\r\n  exclude?: string[];\r\n  count: number;\r\n  threads: number;\r\n  simultaneous: number;\r\n}\r\n\r\nconst getOptions = () =>\r\n  ArgumentParser.parse<IOptions>(async (command, prompt, action) => {\r\n    // command.option(\"--mode <string>\", \"target mode\");\r\n    // command.option(\"--reset <true|false>\", \"reset local DB or not\");\r\n    command.option(\"--include <string...>\", \"include feature files\");\r\n    command.option(\"--exclude <string...>\", \"exclude feature files\");\r\n    command.option(\"--count <number>\", \"number of requests to make\");\r\n    command.option(\"--threads <number>\", \"number of threads to use\");\r\n    command.option(\r\n      \"--simultaneous <number>\",\r\n      \"number of simultaneous requests to make\",\r\n    );\r\n    return action(async (options) => {\r\n      // if (typeof options.reset === \"string\")\r\n      //     options.reset = options.reset === \"true\";\r\n      // options.mode ??= await prompt.select(\"mode\")(\"Select mode\")([\r\n      //     \"LOCAL\",\r\n      //     \"DEV\",\r\n      //     \"REAL\",\r\n      // ]);\r\n      // options.reset ??= await prompt.boolean(\"reset\")(\"Reset local DB\");\r\n      options.count = Number(\r\n        options.count ??\r\n          (await prompt.number(\"count\")(\"Number of requests to make\")),\r\n      );\r\n      options.threads = Number(\r\n        options.threads ??\r\n          (await prompt.number(\"threads\")(\"Number of threads to use\")),\r\n      );\r\n      options.simultaneous = Number(\r\n        options.simultaneous ??\r\n          (await prompt.number(\"simultaneous\")(\r\n            \"Number of simultaneous requests to make\",\r\n          )),\r\n      );\r\n      return options as IOptions;\r\n    });\r\n  });\r\n\r\nconst main = async (): Promise<void> => {\r\n  // CONFIGURATIONS\r\n  const options: IOptions = await getOptions();\r\n  MyGlobal.testing = true;\r\n\r\n  // BACKEND SERVER\r\n  const backend: MyBackend = new MyBackend();\r\n  await backend.open();\r\n\r\n  // DO BENCHMARK\r\n  const prev: IPointer<number> = { value: 0 };\r\n  const bar: cliProgress.SingleBar = new cliProgress.SingleBar(\r\n    {},\r\n    cliProgress.Presets.shades_classic,\r\n  );\r\n  bar.start(options.count, 0);\r\n\r\n  const report: DynamicBenchmarker.IReport = await DynamicBenchmarker.master({\r\n    servant: `${__dirname}/servant.js`,\r\n    count: options.count,\r\n    threads: options.threads,\r\n    simultaneous: options.simultaneous,\r\n    filter: (func) =>\r\n      (!options.include?.length ||\r\n        (options.include ?? []).some((str) => func.includes(str))) &&\r\n      (!options.exclude?.length ||\r\n        (options.exclude ?? []).every((str) => !func.includes(str))),\r\n    progress: (value: number) => {\r\n      if (value >= 100 + prev.value) {\r\n        bar.update(value);\r\n        prev.value = value;\r\n      }\r\n    },\r\n    stdio: \"ignore\",\r\n  });\r\n  bar.stop();\r\n\r\n  // DOCUMENTATION\r\n  try {\r\n    await fs.promises.mkdir(`${MyConfiguration.ROOT}/docs/benchmarks`, {\r\n      recursive: true,\r\n    });\r\n  } catch {}\r\n  await fs.promises.writeFile(\r\n    `${MyConfiguration.ROOT}/docs/benchmarks/${os\r\n      .cpus()[0]\r\n      .model.trim()\r\n      .split(\"\\\\\")\r\n      .join(\"\")\r\n      .split(\"/\")\r\n      .join(\"\")}.md`,\r\n    DynamicBenchmarker.markdown(report),\r\n    \"utf8\",\r\n  );\r\n\r\n  // CLOSE\r\n  await backend.close();\r\n};\r\nmain().catch((exp) => {\r\n  console.error(exp);\r\n  process.exit(-1);\r\n});\nimport { DynamicBenchmarker } from \"@nestia/benchmark\";\r\n\r\nimport { MyConfiguration } from \"../../src/MyConfiguration\";\r\n\r\nDynamicBenchmarker.servant({\r\n  connection: {\r\n    host: `http://127.0.0.1:${MyConfiguration.API_PORT()}`,\r\n  },\r\n  location: `${__dirname}/../features`,\r\n  parameters: (connection) => [connection],\r\n  prefix: \"test_api_\",\r\n}).catch((exp) => {\r\n  console.error(exp);\r\n  process.exit(-1);\r\n});\nTo compose the benchmark program of @nestia/benchmark on your backend application, you have to create two executable TypeScript programs; the main program and the servant program.The main program is executed by user (npm run benchmark command in the playground project), and centralizes the benchmark progress. It creates multiple servant programs parallel, and aggregate the benchmark results from them. After the aggregation, it publishes the benchmark report with markdown format.The servant program is executed by the main program multiply in parallel, and actually runs the e2e test functions for benchmarking. Composing the servant program, you have to specify the directory where the e2e test functions are located. Also, composing the main program of benchmark, you also have to specify the file location of the servant program.If you want to see more benchmark program cases, visit below links:\nProject\tMain\tServant\tReport\tsamchon/nestia-start\tindex.ts\tservant.ts\tREPORT.md\tsamchon/backend\tindex.ts\tservant.ts\tREPORT.md","test-functions#Test Functions":"import { RandomGenerator, TestValidator } from \"@nestia/e2e\";\r\nimport { v4 } from \"uuid\";\r\n\r\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\r\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\r\n\r\nexport async function test_api_bbs_article_create(\r\n  connection: api.IConnection,\r\n): Promise<void> {\r\n  // STORE A NEW ARTICLE\r\n  const stored: IBbsArticle = await api.functional.bbs.articles.create(\r\n    connection,\r\n    \"general\",\r\n    {\r\n      writer: RandomGenerator.name(),\r\n      title: RandomGenerator.paragraph(3)(),\r\n      body: RandomGenerator.content(8)()(),\r\n      format: \"txt\",\r\n      files: [\r\n        {\r\n          name: \"logo\",\r\n          extension: \"png\",\r\n          url: \"https://somewhere.com/logo.png\",\r\n        },\r\n      ],\r\n      password: v4(),\r\n    },\r\n  );\r\n\r\n  // READ THE DATA AGAIN\r\n  const read: IBbsArticle = await api.functional.bbs.articles.at(\r\n    connection,\r\n    stored.section,\r\n    stored.id,\r\n  );\r\n  TestValidator.equals(\"created\")(stored)(read);\r\n}\nimport { RandomGenerator, TestValidator } from \"@nestia/e2e\";\r\nimport { v4 } from \"uuid\";\r\n\r\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\r\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\r\n\r\nexport async function test_api_bbs_article_update(\r\n  connection: api.IConnection,\r\n): Promise<void> {\r\n  // STORE A NEW ARTICLE\r\n  const password: string = v4();\r\n  const article: IBbsArticle = await api.functional.bbs.articles.create(\r\n    connection,\r\n    \"general\",\r\n    {\r\n      writer: RandomGenerator.name(),\r\n      title: RandomGenerator.paragraph(3)(),\r\n      body: RandomGenerator.content(8)()(),\r\n      format: \"txt\",\r\n      files: [\r\n        {\r\n          name: \"logo\",\r\n          extension: \"png\",\r\n          url: \"https://somewhere.com/logo.png\",\r\n        },\r\n      ],\r\n      password,\r\n    },\r\n  );\r\n\r\n  // UPDATE WITH EXACT PASSWORD\r\n  const content: IBbsArticle.ISnapshot =\r\n    await api.functional.bbs.articles.update(\r\n      connection,\r\n      article.section,\r\n      article.id,\r\n      {\r\n        title: RandomGenerator.paragraph(3)(),\r\n        body: RandomGenerator.content(8)()(),\r\n        format: \"txt\",\r\n        files: [],\r\n        password,\r\n      },\r\n    );\r\n  article.snapshots.push(content);\r\n\r\n  // TRY UPDATE WITH WRONG PASSWORD\r\n  await TestValidator.error(\"update with wrong password\")(() =>\r\n    api.functional.bbs.articles.update(\r\n      connection,\r\n      article.section,\r\n      article.id,\r\n      {\r\n        title: RandomGenerator.paragraph(5)(),\r\n        body: RandomGenerator.content(8)()(),\r\n        format: \"txt\",\r\n        files: [],\r\n        password: v4(),\r\n      },\r\n    ),\r\n  );\r\n}\nimport { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\r\n\r\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\r\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\r\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/common/IPage\";\r\n\r\nexport async function test_api_bbs_article_index_search(\r\n  connection: api.IConnection,\r\n): Promise<void> {\r\n  // GENERATE 100 ARTICLES\r\n  const section: string = \"general\";\r\n  const articles: IBbsArticle[] = await ArrayUtil.asyncRepeat(100)(() =>\r\n    api.functional.bbs.articles.create(connection, section, {\r\n      writer: RandomGenerator.name(),\r\n      title: RandomGenerator.paragraph(4)(),\r\n      body: RandomGenerator.content(3)()(),\r\n      format: \"txt\",\r\n      files: [],\r\n      password: RandomGenerator.alphabets(8),\r\n    }),\r\n  );\r\n\r\n  // GET ENTIRE DATA\r\n  const total: IPage<IBbsArticle.ISummary> =\r\n    await api.functional.bbs.articles.index(connection, section, {\r\n      limit: articles.length,\r\n      sort: [\"-created_at\"],\r\n    });\r\n\r\n  // PREPARE SEARCH FUNCTION\r\n  const search = TestValidator.search(\"BbsArticleProvider.index()\")(\r\n    async (input: IBbsArticle.IRequest.ISearch) => {\r\n      const page: IPage<IBbsArticle.ISummary> =\r\n        await api.functional.bbs.articles.index(connection, section, {\r\n          limit: articles.length,\r\n          search: input,\r\n          sort: [\"-created_at\"],\r\n        });\r\n      return page.data;\r\n    },\r\n  )(total.data, 10);\r\n\r\n  // SEARCH TITLE\r\n  await search({\r\n    fields: [\"title\"],\r\n    values: (article) => [article.title],\r\n    request: ([title]) => ({ title }),\r\n    filter: (article, [title]) => article.title.includes(title),\r\n  });\r\n\r\n  // SEARCH WRITER\r\n  await search({\r\n    fields: [\"writer\"],\r\n    values: (article) => [article.writer],\r\n    request: ([writer]) => ({ writer }),\r\n    filter: (article, [writer]) => article.writer.includes(writer),\r\n  });\r\n\r\n  // SEARCH BOTH OF THEM\r\n  await search({\r\n    fields: [\"title\", \"writer\"],\r\n    values: (article) => [article.title, article.writer],\r\n    request: ([title, writer]) => ({ title, writer }),\r\n    filter: (article, [title, writer]) =>\r\n      article.title.includes(title) && article.writer.includes(writer),\r\n  });\r\n}\nDeveloping e2e test functions are very easy. Just make e2e based test function utilizing @nestia/sdk generated SDK library, and exports the function with test_ prefixed name (If you've configured another prefix property in the benchmark main program, just follow the configuration).Also, make the function to have parameter(s) configured in the servant program of the benchmark. As above test functions are examples of playground project that has configured to have only one connection parameter, All of them have the only one parameter connection.After composing these e2e test functions, just execute the benchmark main program. In the playground project, it can be executed by npm run benchmark command. The benchmark program will run these e2e test functions in parallel and randomly, and measure the performance of your backend server.\ngit clone https://github.com/samchon/nestia-start\r\ncd nestia-start\r\nnpm install\r\nnpm run build:test\r\nnpm run benchmark"}},"/docs":{"title":"Guide Documents > Introduction","data":{"outline#Outline":"Nestia is a set of helper libraries for NestJS, supporting below features:\n@nestia/core:\nSuper-fast/easy decorators\nAdvanced WebSocket routes\n@nestia/sdk:\nSwagger generator evolved than ever\nOpenAI function calling schema generator\nSDK library generator for clients\nMockup Simulator for client developers\nAutomatic E2E test functions generator\n@nestia/e2e: Test program utilizing e2e test functions\n@nestia/benchmark: Benchmark program using e2e test functions\n@nestia/chat: Super A.I. Chatbot by Swagger document\n@nestia/editor: Swagger-UI with Online TypeScript Editor\nnestia: Just CLI (command line interface) tool\nOnly one line required, with pure TypeScript type\nEnhance performance 30x up\nRuntime validator is 20,000x faster than class-validator\nJSON serialization is 200x faster than class-transformer\nSoftware Development Kit\nCollection of typed fetch functions with DTO structures like tRPC\nMockup simulator means embedded backend simulator in the SDK\nsimilar with msw, but fully automated\nLeft is NestJS server code, and right is client (frontend) code utilizing SDK","sponsors#Sponsors":"Thanks for your support.Your donation would encourage nestia development."}},"/docs/sdk/sdk":{"title":"Guide Documents > S/W Development Kit","data":{"":"The path has been changed to /docs/sdk/.Please wait for a moment while you are redirected to the new page."}},"/docs/sdk/distribute":{"title":"Guide Documents > S/W Development Kit > Distribution","data":{"":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n};\r\nexport default NESTIA_CONFIG;\nThe best to way to distributing SDK library is just publishing as an NPM module.Configure distribute property of nestia.config.ts file, and run npx nestia sdk command. After that, distribution environments would be automatically composed with SDK library generation. At last, move to the packages/api directory, and run npm run deploy command for publishing.From now on, client developers can use the SDK library just by using npm install command.\ncd packages/api\r\nnpm run deploy\nOf course, before publishing the NPM module, you've to customize some configurations like package name. Initial name of the distribution envirionments is @ORGANIZATION/PROJECT-api, but you must change the package name of yours, isn't it?Also, if your SDK library utilize special alias paths, you also need to customize tsconfig.json file, too. Reading below example package.json and tsconfig.json files generated by nestia, consider which features to customize.\n{\r\n  \"name\": \"@ORGANIZATION/PROJECT-api\",\r\n  \"version\": \"0.1.0\",\r\n  \"description\": \"SDK library generated by Nestia\",\r\n  \"main\": \"lib/index.js\",\r\n  \"typings\": \"lib/index.d.ts\",\r\n  \"scripts\": {\r\n    \"build\": \"npm run build:sdk && npm run compile\",\r\n    \"build:sdk\": \"rimraf ../../src/api/functional && cd ../.. && npx nestia sdk && cd packages/api\",\r\n    \"compile\": \"rimraf lib && tsc\",\r\n    \"deploy\": \"npm run build && npm publish\"\r\n  },\r\n  \"repository\": {\r\n    \"type\": \"git\",\r\n    \"url\": \"https://github.com/samchon/nestia\"\r\n  },\r\n  \"author\": \"Jeongho Nam\",\r\n  \"license\": \"MIT\",\r\n  \"bugs\": {\r\n    \"url\": \"https://github.com/samchon/nestia/issues\"\r\n  },\r\n  \"homepage\": \"https://nestia.io\",\r\n  \"devDependencies\": {\r\n    \"rimraf\": \"^5.0.0\",\r\n    \"typescript\": \"^5.4.2\",\r\n    \"ts-patch\": \"^3.1.0\"\r\n  },\r\n  \"dependencies\": {\r\n    \"@nestia/fetcher\": \"^4.2.0\",\r\n    \"typia\": \"^8.0.0\"\r\n  },\r\n  \"files\": [\r\n    \"lib\",\r\n    \"package.json\",\r\n    \"README.md\"\r\n  ]\r\n}\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"ES5\",\r\n    \"lib\": [\r\n      \"DOM\",\r\n      \"ES2015\"\r\n    ],\r\n    \"module\": \"commonjs\",\r\n    \"declaration\": true,\r\n    \"sourceMap\": true,\r\n    \"outDir\": \"./lib\",\r\n    \"downlevelIteration\": true,\r\n    \"newLine\": \"lf\",\r\n    \"esModuleInterop\": true,\r\n    \"forceConsistentCasingInFileNames\": true,\r\n    \"strict\": true,\r\n    \"skipLibCheck\": true\r\n  },\r\n  \"include\": [\r\n    \"../../src/api\"\r\n  ]\r\n}"}},"/docs/sdk/simulator":{"title":"Guide Documents > S/W Development Kit > Mockup Simulator","data":{"":"The path has been changed to /docs/sdk/simulate/.Please wait for a moment while you are redirected to the new page."}},"/docs/sdk/swagger":{"title":"Guide Documents > S/W Development Kit > Swagger Document","data":{"":"The path has been changed to /docs/swagger/.Please wait for a moment while you are redirected to the new page."}},"/docs/swagger/editor":{"title":"Guide Documents > Swagger Document > TypeScript Swagger Editor","data":{"outline#Outline":"Swagger-UI with Cloud TypeScript Editor with embedded SDK.@nestia/editor is a combination of Swagger-UI and web-based TypeScript editor (of StackBlitz) embedding SDK (Software Development Kit) library generated by @nestia/migrate from an OpenAPI document. With the @nestia/editor, you can easily test the backend API with TypeScript code, and it is much convenient than the traditional way of using Swagger UI, due to type checking and auto-completion of the TypeScript.Also, @nestia/editor provides Mockup Simulator of the backend API functions. With the mockup simulator, you can start the frontend (or client) development even when the backend API functions have not been implemented yet. Furthermore, @nestia/editor supports automatic e2e (end-to-end) test functions' generation, so that you can easily validate the backend API functions with the automatically generated test codes.Here are the some example projects generated by @nestia/editor. Traveling those example projects, you may understand how to utilize the @nestia/editor. Let's start the type safe API interaction development with @nestia/editor!\nPut your swagger.json file, then @nestia/editor be opened.","frontend-setup#Frontend Setup":"","react-library#React Library":"import { NestiaEditorIframe } from \"@nestia/editor\";\r\nimport { SwaggerV2, OpenApiV3, OpenApiV3_1 } from \"@samchon/openapi\";\r\n\r\nconst document: SwaggerV2 | OpenApiV3 | OpenApiV3_1;\r\n\r\n<NestiaEditorIframe swagger={document} \r\n                    package=\"your-package-name\"\r\n                    e2e={true} \r\n                    simulate={true} />\r\n<NestiaEditorUploader />\nInstall @nestia/editor and import one of below components.If you've prepared the Swagger Document to serve, you can directly launch the cloud editor by using the NestiaEditorIframe component. Otherwise you want to provide a \"Swagger File Uploader\" for dynamic purpose, utilize the NestiaEditorUploader component instead.\nNestiaEditorIframe: directly launch the cloud editor by given document\nNestiaEditorUploader: upload the swagger.json file and launch the cloud editor","static-hosting#Static Hosting":"💾 https://nestia.io/downloads/editor.zip\nUnzip and place your swagger.json file into the extracted directory.Just download unzip the above editor.zip file, and place your swagger.json (or swagger.yaml) file into the extracted directory. When you open the unzipped index.html in your browser, you can see the @nestia/editor is serving the \"TypeScript Swagger Editor\" application with your swagger.json (or swagger.yaml) file.Also, if you want to specify the package name, or activate the Mockup Simulator, open the index.html file of unzipped and edit some variables like below. Guiding the users th fill these package, simulate and e2e query parameters like http://localhost/?simulate=true&e2e=true can be an alternative way.By the way, if you do not place the swagger.json (or swagger.yaml) file into the directory, the @nestia/editor will just show you the \"Swagger File Uploader\" (NestiaEditorUploader) instead.\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta\r\n      name=\"viewport\"\r\n      content=\"width=device-width, height=device-height, initial-scale=1, minimum-scale=1.0, maximum-scale=3.0s\"\r\n    />\r\n    <title>Nestia Editor</title>\r\n    <script type=\"module\"  src=\"./assets/index-DwHERS4Q.js\"></script>\r\n  </head>\r\n  <body style=\"width: 100%; height: 100%; margin: 0px; overflow: hidden;\">\r\n    <div id=\"root\" style=\"width: 100%; height: 100%\"></div>\r\n    <script>\r\n      window.package = \"@ORGANIZATION/PROJECT\";\r\n      window.simulate = false; \r\n      window.e2e = false;\r\n    </script>\r\n  </body>\r\n</html>","iframe-embedding#<iframe> Embedding":"<iframe url=\"https://nestia.io/editor/?url={URL_ADDRESS}&package={NAME}&simulate=true&e2e=true\"></iframe>\nYou also can embed the @nestia/editor with static URL address.When embedding the @nestia/editor application through the <iframe> tag, fill the url query parameter with the URL address of your swagger.json (or swagger.yaml) file. Also, the simulate and e2e query parameters are optional, but recommended to be filled with true for the best experience. As you know, they activate the Mockup Simulator and automatic e2e test functions' generation.By the way, if you do not fill the url query parameter, the @nestia/editor will just show you the \"Swagger File Uploader\" (NestiaEditorUploader) instead.If you wanna see the example cases of the <iframe> embedding, let's see the below list again.","backend-setup#Backend Setup":"","editor-module#Editor Module":"import { NestiaEditorModule } from \"@nestia/editor/lib/NestiaEditorModule\";\r\nimport { NestFactory } from '@nestjs/core';\r\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\r\n\r\nimport { AppModule } from './app.module';\r\n\r\nconst bootstrap = async (): Promise<void> => {\r\n  const app = await NestFactory.create(AppModule);\r\n  const config = new DocumentBuilder()\r\n    .setTitle('Cats example')\r\n    .setDescription('The cats API description')\r\n    .setVersion('1.0')\r\n    .addTag('cats')\r\n    .build();\r\n  const documentFactory = () => SwaggerModule.createDocument(app, config);\r\n  SwaggerModule.setup('api', app, documentFactory)\r\n\r\n  await NestiaEditorModule.setup({\r\n    path: \"editor\",\r\n    application: app,\r\n    swagger: \"/api-json\",\r\n    package: \"your-package-name\",\r\n    simulate: true,\r\n    e2e: true,\r\n  });\r\n  await app.listen(3000);\r\n};\r\nbootstrap().catch(console.error);\nIn the NestJS, you can serve the Nestia Editor by NestiaEditorModule.setup() function.Note that, if you've configured the path parameter of the SwaggerModule.setup() function (of @nestjs/swagger) as api, its URL path of the composed Swagger Document is /api-json. Fill the /api-json URL path into the swagger parameter of the NestiaEditorModule.setup() function.Also, don't forget to configure the additional properties like package, simulate and e2e for the best experience. Even though these properties are optional, but recommended to be fully filled with the proper values.\npackage: Name of the SDK package generated in the editor\nsimulate: Whether to compose mockup simulator or not\ne2e: Whether to compose e2e automated test functions or not"}},"/":{"title":"Home","data":{"key-features#Key Features":"","sponsors#Sponsors":"Thanks for your support.Your donation would encourage nestia development."}},"/docs/swagger/strategy":{"title":"Guide Documents > Swagger Document > Documentation Strategy","data":{"description-comment#Description Comment":"import { TypedBody, TypedParam, TypedRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport { tags } from \"typia\";\r\n\r\nimport { IBbsArticle } from \"../api/structures/IBbsArticle\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticleController {\r\n  /**\r\n   * Create a new article.\r\n   *\r\n   * Writes a new article and archives it into the DB.\r\n   *\r\n   * @param input Information of the article to create\r\n   * @returns Newly created article\r\n   */\r\n  @TypedRoute.Post()\r\n  public async create(\r\n    @TypedBody() input: IBbsArticle.ICreate\r\n  ): Promise<IBbsArticle>;\r\n\r\n  /**\r\n   * Update an article.\r\n   *\r\n   * Updates an article with new content.\r\n   *\r\n   * @param id Target article's {@link IBbsArticle.id}\r\n   * @param input New content to update\r\n   */\r\n  @TypedRoute.Put(\":id\")\r\n  public async update(\r\n    @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\r\n    @TypedBody() input: IBbsArticle.IUpdate,\r\n  ): Promise<void>;\r\n\r\n  /**\r\n   * Erase an article.\r\n   *\r\n   * Erases an article from the DB.\r\n   *\r\n   * @param id Target article's {@link IBbsArticle.id}\r\n   */\r\n  @TypedRoute.Delete(\":id\")\r\n  public async erase(\r\n    @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\r\n  ): Promise<void>;\r\n}\nimport { tags } from \"typia\";\r\n\r\n/**\r\n * Article entity.\r\n *\r\n * `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\r\n */\r\nexport interface IBbsArticle extends IBbsArticle.ICreate {\r\n  /**\r\n   * Primary Key.\r\n   */\r\n  id: string & tags.Format<\"uuid\">;\r\n \r\n  /**\r\n   * Creation time of the article.\r\n   */\r\n  created_at: string & tags.Format<\"date-time\">;\r\n \r\n  /**\r\n   * Last updated time of the article.\r\n   */\r\n  updated_at: string & tags.Format<\"date-time\">;\r\n}\r\nexport namespace IBbsArticle {\r\n  /**\r\n   * Information of the article to create.\r\n   */\r\n  export interface ICreate {\r\n    /**\r\n     * Title of the article.\r\n     *\r\n     * Representative title of the article.\r\n     */\r\n    title: string;\r\n \r\n    /**\r\n     * Content body.\r\n     *\r\n     * Content body of the article writtn in the markdown format.\r\n     */\r\n    body: string;\r\n \r\n    /**\r\n     * Thumbnail image URI.\r\n     *\r\n     * Thumbnail image URI which can represent the article.\r\n     *\r\n     * If configured as `null`, it means that no thumbnail image in the article.\r\n     */\r\n    thumbnail:\r\n      | null\r\n      | (string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">);\r\n  }\r\n \r\n  /**\r\n   * Information of the article to update.\r\n   *\r\n   * Only the filled properties will be updated.\r\n   */\r\n  export type IUpdate = Partial<ICreate>;\r\n}\n{\r\n  \"openapi\": \"3.1.0\",\r\n  \"servers\": [\r\n    {\r\n      \"url\": \"http://localhost:37001\",\r\n      \"description\": \"Local Server\"\r\n    }\r\n  ],\r\n  \"info\": {\r\n    \"version\": \"0.1.0\",\r\n    \"title\": \"@samchon/bbs-api\",\r\n    \"description\": \"BBS Backend API\",\r\n    \"license\": {\r\n      \"name\": \"MIT\"\r\n    }\r\n  },\r\n  \"paths\": {\r\n    \"/bbs/articles\": {\r\n      \"post\": {\r\n        \"summary\": \"Create a new article\",\r\n        \"description\": \"Create a new article.\\n\\nWrites a new article and archives it into the DB.\",\r\n        \"tags\": [],\r\n        \"parameters\": [],\r\n        \"requestBody\": {\r\n          \"description\": \"Information of the article to create\",\r\n          \"content\": {\r\n            \"application/json\": {\r\n              \"schema\": {\r\n                \"$ref\": \"#/components/schemas/IBbsArticle.ICreate\"\r\n              }\r\n            }\r\n          },\r\n          \"required\": true\r\n        },\r\n        \"responses\": {\r\n          \"201\": {\r\n            \"description\": \"Newly created article\",\r\n            \"content\": {\r\n              \"application/json\": {\r\n                \"schema\": {\r\n                  \"$ref\": \"#/components/schemas/IBbsArticle\"\r\n                }\r\n              }\r\n            }\r\n          }\r\n        },\r\n        \"x-samchon-accessor\": [\r\n          \"bbs\",\r\n          \"articles\",\r\n          \"create\"\r\n        ],\r\n        \"x-samchon-controller\": \"BbsArticleController\"\r\n      }\r\n    },\r\n    \"/bbs/articles/{id}\": {\r\n      \"put\": {\r\n        \"summary\": \"Update an article\",\r\n        \"description\": \"Update an article.\\n\\nUpdates an article with new content.\",\r\n        \"tags\": [],\r\n        \"parameters\": [\r\n          {\r\n            \"name\": \"id\",\r\n            \"in\": \"path\",\r\n            \"schema\": {\r\n              \"type\": \"string\",\r\n              \"format\": \"uuid\"\r\n            },\r\n            \"required\": true,\r\n            \"description\": \" Target article's {@link IBbsArticle.id }\"\r\n          }\r\n        ],\r\n        \"requestBody\": {\r\n          \"description\": \"New content to update\",\r\n          \"content\": {\r\n            \"application/json\": {\r\n              \"schema\": {\r\n                \"$ref\": \"#/components/schemas/PartialIBbsArticle.ICreate\"\r\n              }\r\n            }\r\n          },\r\n          \"required\": true\r\n        },\r\n        \"responses\": {\r\n          \"200\": {\r\n            \"description\": \"\",\r\n            \"content\": {\r\n              \"application/json\": {}\r\n            }\r\n          }\r\n        },\r\n        \"x-samchon-accessor\": [\r\n          \"bbs\",\r\n          \"articles\",\r\n          \"update\"\r\n        ],\r\n        \"x-samchon-controller\": \"BbsArticleController\"\r\n      },\r\n      \"delete\": {\r\n        \"summary\": \"Erase an article\",\r\n        \"description\": \"Erase an article.\\n\\nErases an article from the DB.\",\r\n        \"tags\": [],\r\n        \"parameters\": [\r\n          {\r\n            \"name\": \"id\",\r\n            \"in\": \"path\",\r\n            \"schema\": {\r\n              \"type\": \"string\",\r\n              \"format\": \"uuid\"\r\n            },\r\n            \"required\": true,\r\n            \"description\": \" Target article's {@link IBbsArticle.id }\"\r\n          }\r\n        ],\r\n        \"responses\": {\r\n          \"200\": {\r\n            \"description\": \"\",\r\n            \"content\": {\r\n              \"application/json\": {}\r\n            }\r\n          }\r\n        },\r\n        \"x-samchon-accessor\": [\r\n          \"bbs\",\r\n          \"articles\",\r\n          \"erase\"\r\n        ],\r\n        \"x-samchon-controller\": \"BbsArticleController\"\r\n      }\r\n    }\r\n  },\r\n  \"components\": {\r\n    \"schemas\": {\r\n      \"IBbsArticle\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"id\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"uuid\",\r\n            \"title\": \"Primary Key\",\r\n            \"description\": \"Primary Key.\"\r\n          },\r\n          \"created_at\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"date-time\",\r\n            \"title\": \"Creation time of the article\",\r\n            \"description\": \"Creation time of the article.\"\r\n          },\r\n          \"updated_at\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"date-time\",\r\n            \"title\": \"Last updated time of the article\",\r\n            \"description\": \"Last updated time of the article.\"\r\n          },\r\n          \"title\": {\r\n            \"type\": \"string\",\r\n            \"title\": \"Title of the article\",\r\n            \"description\": \"Title of the article.\\n\\nRepresentative title of the article.\"\r\n          },\r\n          \"body\": {\r\n            \"type\": \"string\",\r\n            \"title\": \"Content body\",\r\n            \"description\": \"Content body.\\n\\nContent body of the article writtn in the markdown format.\"\r\n          },\r\n          \"thumbnail\": {\r\n            \"oneOf\": [\r\n              {\r\n                \"type\": \"null\"\r\n              },\r\n              {\r\n                \"type\": \"string\",\r\n                \"format\": \"uri\",\r\n                \"contentMediaType\": \"image/*\"\r\n              }\r\n            ],\r\n            \"title\": \"Thumbnail image URI\",\r\n            \"description\": \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\"\r\n          }\r\n        },\r\n        \"required\": [\r\n          \"id\",\r\n          \"created_at\",\r\n          \"updated_at\",\r\n          \"title\",\r\n          \"body\",\r\n          \"thumbnail\"\r\n        ],\r\n        \"description\": \"Article entity.\\n\\n`IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\"\r\n      },\r\n      \"IBbsArticle.ICreate\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"title\": {\r\n            \"type\": \"string\",\r\n            \"title\": \"Title of the article\",\r\n            \"description\": \"Title of the article.\\n\\nRepresentative title of the article.\"\r\n          },\r\n          \"body\": {\r\n            \"type\": \"string\",\r\n            \"title\": \"Content body\",\r\n            \"description\": \"Content body.\\n\\nContent body of the article writtn in the markdown format.\"\r\n          },\r\n          \"thumbnail\": {\r\n            \"oneOf\": [\r\n              {\r\n                \"type\": \"null\"\r\n              },\r\n              {\r\n                \"type\": \"string\",\r\n                \"format\": \"uri\",\r\n                \"contentMediaType\": \"image/*\"\r\n              }\r\n            ],\r\n            \"title\": \"Thumbnail image URI\",\r\n            \"description\": \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\"\r\n          }\r\n        },\r\n        \"required\": [\r\n          \"title\",\r\n          \"body\",\r\n          \"thumbnail\"\r\n        ],\r\n        \"description\": \"Information of the article to create.\"\r\n      },\r\n      \"PartialIBbsArticle.ICreate\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"title\": {\r\n            \"type\": \"string\",\r\n            \"title\": \"Title of the article\",\r\n            \"description\": \"Title of the article.\\n\\nRepresentative title of the article.\"\r\n          },\r\n          \"body\": {\r\n            \"type\": \"string\",\r\n            \"title\": \"Content body\",\r\n            \"description\": \"Content body.\\n\\nContent body of the article writtn in the markdown format.\"\r\n          },\r\n          \"thumbnail\": {\r\n            \"oneOf\": [\r\n              {\r\n                \"type\": \"null\"\r\n              },\r\n              {\r\n                \"type\": \"string\",\r\n                \"format\": \"uri\",\r\n                \"contentMediaType\": \"image/*\"\r\n              }\r\n            ],\r\n            \"title\": \"Thumbnail image URI\",\r\n            \"description\": \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\"\r\n          }\r\n        },\r\n        \"required\": [],\r\n        \"description\": \"Make all properties in T optional\"\r\n      }\r\n    }\r\n  },\r\n  \"tags\": [],\r\n  \"x-samchon-emended\": true\r\n}\n{\r\n  \"model\": \"chatgpt\",\r\n  \"options\": {\r\n    \"reference\": false,\r\n    \"strict\": false,\r\n    \"separate\": null,\r\n    \"maxLength\": null\r\n  },\r\n  \"functions\": [\r\n    {\r\n      \"method\": \"post\",\r\n      \"path\": \"/bbs/articles\",\r\n      \"name\": \"bbs_articles_create\",\r\n      \"parameters\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"body\": {\r\n            \"description\": \"Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the current {@link IBbsArticle.ICreate} type:\\n\\n> Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the parent {@link IBbsArticle} type:\\n\\n> Article entity.\\n> \\n> `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n              \"title\": {\r\n                \"title\": \"Title of the article\",\r\n                \"description\": \"Title of the article.\\n\\nRepresentative title of the article.\",\r\n                \"type\": \"string\"\r\n              },\r\n              \"body\": {\r\n                \"title\": \"Content body\",\r\n                \"description\": \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\r\n                \"type\": \"string\"\r\n              },\r\n              \"thumbnail\": {\r\n                \"title\": \"Thumbnail image URI\",\r\n                \"description\": \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\r\n                \"anyOf\": [\r\n                  {\r\n                    \"type\": \"null\"\r\n                  },\r\n                  {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"@format uri\\n@contentMediaType image/*\"\r\n                  }\r\n                ]\r\n              }\r\n            },\r\n            \"required\": [\r\n              \"title\",\r\n              \"body\",\r\n              \"thumbnail\"\r\n            ]\r\n          }\r\n        },\r\n        \"additionalProperties\": false,\r\n        \"required\": [\r\n          \"body\"\r\n        ],\r\n        \"$defs\": {}\r\n      },\r\n      \"output\": {\r\n        \"description\": \"Article entity.\\n\\n`IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"id\": {\r\n            \"title\": \"Primary Key\",\r\n            \"description\": \"Primary Key.\\n\\n\\n@format uuid\",\r\n            \"type\": \"string\"\r\n          },\r\n          \"created_at\": {\r\n            \"title\": \"Creation time of the article\",\r\n            \"description\": \"Creation time of the article.\\n\\n\\n@format date-time\",\r\n            \"type\": \"string\"\r\n          },\r\n          \"updated_at\": {\r\n            \"title\": \"Last updated time of the article\",\r\n            \"description\": \"Last updated time of the article.\\n\\n\\n@format date-time\",\r\n            \"type\": \"string\"\r\n          },\r\n          \"title\": {\r\n            \"title\": \"Title of the article\",\r\n            \"description\": \"Title of the article.\\n\\nRepresentative title of the article.\",\r\n            \"type\": \"string\"\r\n          },\r\n          \"body\": {\r\n            \"title\": \"Content body\",\r\n            \"description\": \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\r\n            \"type\": \"string\"\r\n          },\r\n          \"thumbnail\": {\r\n            \"title\": \"Thumbnail image URI\",\r\n            \"description\": \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\r\n            \"anyOf\": [\r\n              {\r\n                \"type\": \"null\"\r\n              },\r\n              {\r\n                \"type\": \"string\",\r\n                \"description\": \"@format uri\\n@contentMediaType image/*\"\r\n              }\r\n            ]\r\n          }\r\n        },\r\n        \"required\": [\r\n          \"id\",\r\n          \"created_at\",\r\n          \"updated_at\",\r\n          \"title\",\r\n          \"body\",\r\n          \"thumbnail\"\r\n        ]\r\n      },\r\n      \"description\": \"Create a new article.\\n\\nWrites a new article and archives it into the DB.\",\r\n      \"tags\": []\r\n    },\r\n    {\r\n      \"method\": \"put\",\r\n      \"path\": \"/bbs/articles/{id}\",\r\n      \"name\": \"bbs_articles_update\",\r\n      \"parameters\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"id\": {\r\n            \"description\": \" Target article's {@link IBbsArticle.id }\\n\\n\\n@format uuid\",\r\n            \"type\": \"string\"\r\n          },\r\n          \"body\": {\r\n            \"description\": \"Make all properties in T optional\\n\\n------------------------------\\n\\nDescription of the current {@link PartialIBbsArticle.ICreate} type:\\n\\n> Make all properties in T optional\",\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n              \"title\": {\r\n                \"title\": \"Title of the article\",\r\n                \"description\": \"Title of the article.\\n\\nRepresentative title of the article.\",\r\n                \"type\": \"string\"\r\n              },\r\n              \"body\": {\r\n                \"title\": \"Content body\",\r\n                \"description\": \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\r\n                \"type\": \"string\"\r\n              },\r\n              \"thumbnail\": {\r\n                \"title\": \"Thumbnail image URI\",\r\n                \"description\": \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\r\n                \"anyOf\": [\r\n                  {\r\n                    \"type\": \"null\"\r\n                  },\r\n                  {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"@format uri\\n@contentMediaType image/*\"\r\n                  }\r\n                ]\r\n              }\r\n            },\r\n            \"required\": []\r\n          }\r\n        },\r\n        \"additionalProperties\": false,\r\n        \"required\": [\r\n          \"id\",\r\n          \"body\"\r\n        ],\r\n        \"$defs\": {}\r\n      },\r\n      \"output\": {},\r\n      \"description\": \"Update an article.\\n\\nUpdates an article with new content.\",\r\n      \"tags\": []\r\n    },\r\n    {\r\n      \"method\": \"delete\",\r\n      \"path\": \"/bbs/articles/{id}\",\r\n      \"name\": \"bbs_articles_erase\",\r\n      \"parameters\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"id\": {\r\n            \"description\": \" Target article's {@link IBbsArticle.id }\\n\\n\\n@format uuid\",\r\n            \"type\": \"string\"\r\n          }\r\n        },\r\n        \"additionalProperties\": false,\r\n        \"required\": [\r\n          \"id\"\r\n        ],\r\n        \"$defs\": {}\r\n      },\r\n      \"output\": {},\r\n      \"description\": \"Erase an article.\\n\\nErases an article from the DB.\",\r\n      \"tags\": []\r\n    }\r\n  ],\r\n  \"errors\": []\r\n}\nWrite descriptions as comments on controller methods, and DTO interfaces.The description comments would be transformed into the description, summary and title fields of the Swagger Document. And some special comment tags like @param and @returns would fill the adequate properties of the Swagger Document. If you're using nestia for the the A.I. chatbot development purpose, such detailed descriptions are very important to teach the purpose of the function to the LLM (Language Large Model), and LLM actually determines which function to call by the description.Also, OpenApi.IOperation type has two descriptive properties summary and description. And the OpenApi.IJsonSchema has similar categorized two properties title and description. Both summary and title can be filled with two ways. The first way is closing the first line of the description comment with a period (.). By the way, this way's description property would be the entire description comment even including the first line composing the summary or title field.If you don’t want that, you can adapt the second way that writing @summary {string} or @title {string} comment tag. In that case, the title value would not be contained in the description value. For reference, it is possible to fill the description property of the ILlmSchema by the comment tag @description, but you have to take care of the indentation like below.\nexport interface IMember {\r\n  /**\r\n   * Primary Key.\r\n   * \r\n   * Above \"Primary Key\" would be the title of LLM schema. \r\n   */\r\n  id: string;\r\n \r\n  /**\r\n   * Below \"Age of the member\" would be the title of LLM schema.\r\n   * \r\n   * @title Age of the member\r\n   */\r\n  age: number;\r\n \r\n  /**\r\n   * @title Email address of the member\r\n   * @description The description property also can be filled by \r\n   *              the comment tag `@description`. Instead, be\r\n   *              careful about the indentation.\r\n   */\r\n  email: string;\r\n}","namespace-strategy#Namespace Strategy":"import { tags } from \"typia\";\r\n\r\n/**\r\n * Article entity.\r\n *\r\n * `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\r\n */\r\nexport interface IBbsArticle extends IBbsArticle.ICreate {\r\n  /**\r\n   * Primary Key.\r\n   */\r\n  id: string & tags.Format<\"uuid\">;\r\n \r\n  /**\r\n   * Creation time of the article.\r\n   */\r\n  created_at: string & tags.Format<\"date-time\">;\r\n \r\n  /**\r\n   * Last updated time of the article.\r\n   */\r\n  updated_at: string & tags.Format<\"date-time\">;\r\n}\r\nexport namespace IBbsArticle {\r\n  /**\r\n   * Information of the article to create.\r\n   */\r\n  export interface ICreate {\r\n    /**\r\n     * Title of the article.\r\n     *\r\n     * Representative title of the article.\r\n     */\r\n    title: string;\r\n \r\n    /**\r\n     * Content body.\r\n     *\r\n     * Content body of the article writtn in the markdown format.\r\n     */\r\n    body: string;\r\n \r\n    /**\r\n     * Thumbnail image URI.\r\n     *\r\n     * Thumbnail image URI which can represent the article.\r\n     *\r\n     * If configured as `null`, it means that no thumbnail image in the article.\r\n     */\r\n    thumbnail:\r\n      | null\r\n      | (string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">);\r\n  }\r\n \r\n  /**\r\n   * Information of the article to update.\r\n   *\r\n   * Only the filled properties will be updated.\r\n   */\r\n  export type IUpdate = Partial<ICreate>;\r\n}\nInformation of the article to create.\r\n \r\n------------------------------\r\n \r\nDescription of the current {@link IBbsArticle.ICreate} type:\r\n \r\nInformation of the article to create.\r\n \r\n> Description of the parent {@link IBbsArticle} type: Article entity.\r\n> \r\n> `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System\nIf you're using nestia for the A.I. chatbot development purpose, the namespace strategy is very important.When you compose an IHttpLlmApplication / IHttpLlmFunction schema from a Swagger Document, it copies the parent namespaced type description comment to the children types. If you utilize this namespace strategy properly, you can make the LLM function calling schema more informative and undeerstandable minimizing the duplicated description comments.As you can see, above IBbsArticle.ICreate and IBbsArticle.IUpdate interfaces are the children of the IBbsArticle interface. And the IBbsArticle interface has a detailed description comment about the article. In this case, the description comment of the IBbsArticle interface would be copied to the IBbsArticle.ICreate and IBbsArticle.IUpdate interfaces. Therefore, you don't need to write the same description comment on the children interfaces again.","function-hiding#Function Hiding":"import { HumanRoute, TypedBody, TypedParam, TypedRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport { tags } from \"typia\";\r\n\r\nimport { IBbsArticle } from \"../api/structures/IBbsArticle\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticleController {\r\n  /**\r\n   * Read an article.\r\n   * \r\n   * Reads an article from the DB.\r\n   * \r\n   * @param id Target article's {@link IBbsArticle.id}\r\n   * @returns The article\r\n   */\r\n  @TypedRoute.Get(\":id\")\r\n  public async at(\r\n    @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\r\n  ): Promise<IBbsArticle>;\r\n\r\n  /**\r\n   * Create a new article.\r\n   *\r\n   * Writes a new article and archives it into the DB.\r\n   *\r\n   * @param input Information of the article to create\r\n   * @returns Newly created article\r\n   * @hidden\r\n   */\r\n  @TypedRoute.Post()\r\n  public async create(\r\n    @TypedBody() input: IBbsArticle.ICreate\r\n  ): Promise<IBbsArticle>;\r\n\r\n  /**\r\n   * Update an article.\r\n   *\r\n   * Updates an article with new content.\r\n   *\r\n   * @param id Target article's {@link IBbsArticle.id}\r\n   * @param input New content to update\r\n   * @internal\r\n   */\r\n  @TypedRoute.Put(\":id\")\r\n  public async update(\r\n    @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\r\n    @TypedBody() input: IBbsArticle.IUpdate,\r\n  ): Promise<void>;\r\n\r\n  /**\r\n   * Erase an article.\r\n   *\r\n   * Erases an article from the DB.\r\n   *\r\n   * @param id Target article's {@link IBbsArticle.id}\r\n   */\r\n  @HumanRoute()\r\n  @TypedRoute.Delete(\":id\")\r\n  public async erase(\r\n    @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\r\n  ): Promise<void>;\r\n}\n{\r\n  \"openapi\": \"3.1.0\",\r\n  \"servers\": [\r\n    {\r\n      \"url\": \"http://localhost:37001\",\r\n      \"description\": \"Local Server\"\r\n    }\r\n  ],\r\n  \"info\": {\r\n    \"version\": \"0.1.0\",\r\n    \"title\": \"@ORGANIZATION/PROJECT\",\r\n    \"description\": \"Starter kit of Nestia\",\r\n    \"license\": {\r\n      \"name\": \"MIT\"\r\n    }\r\n  },\r\n  \"paths\": {\r\n    \"/bbs/articles/{id}\": {\r\n      \"get\": {\r\n        \"summary\": \"Read an article\",\r\n        \"description\": \"Read an article.\\n\\nReads an article from the DB.\",\r\n        \"tags\": [],\r\n        \"parameters\": [\r\n          {\r\n            \"name\": \"id\",\r\n            \"in\": \"path\",\r\n            \"schema\": {\r\n              \"type\": \"string\",\r\n              \"format\": \"uuid\"\r\n            },\r\n            \"required\": true,\r\n            \"description\": \" Target article's {@link IBbsArticle.id }\"\r\n          }\r\n        ],\r\n        \"responses\": {\r\n          \"200\": {\r\n            \"description\": \"The article\",\r\n            \"content\": {\r\n              \"application/json\": {\r\n                \"schema\": {\r\n                  \"$ref\": \"#/components/schemas/IBbsArticle\"\r\n                }\r\n              }\r\n            }\r\n          }\r\n        },\r\n        \"x-samchon-accessor\": [\r\n          \"bbs\",\r\n          \"articles\",\r\n          \"at\"\r\n        ],\r\n        \"x-samchon-controller\": \"BbsArticleController\"\r\n      },\r\n      \"delete\": {\r\n        \"summary\": \"Erase an article\",\r\n        \"description\": \"Erase an article.\\n\\nErases an article from the DB.\",\r\n        \"tags\": [],\r\n        \"parameters\": [\r\n          {\r\n            \"name\": \"id\",\r\n            \"in\": \"path\",\r\n            \"schema\": {\r\n              \"type\": \"string\",\r\n              \"format\": \"uuid\"\r\n            },\r\n            \"required\": true,\r\n            \"description\": \" Target article's {@link IBbsArticle.id }\"\r\n          }\r\n        ],\r\n        \"responses\": {\r\n          \"200\": {\r\n            \"description\": \"\",\r\n            \"content\": {\r\n              \"application/json\": {}\r\n            }\r\n          }\r\n        },\r\n        \"x-samchon-accessor\": [\r\n          \"bbs\",\r\n          \"articles\",\r\n          \"erase\"\r\n        ],\r\n        \"x-samchon-controller\": \"BbsArticleController\"\r\n      }\r\n    }\r\n  },\r\n  \"components\": {\r\n    \"schemas\": {\r\n      \"IBbsArticle\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"id\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"uuid\",\r\n            \"title\": \"Primary Key\",\r\n            \"description\": \"Primary Key.\"\r\n          },\r\n          \"created_at\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"date-time\",\r\n            \"title\": \"Creation time of the article\",\r\n            \"description\": \"Creation time of the article.\"\r\n          },\r\n          \"updated_at\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"date-time\",\r\n            \"title\": \"Last updated time of the article\",\r\n            \"description\": \"Last updated time of the article.\"\r\n          },\r\n          \"title\": {\r\n            \"type\": \"string\",\r\n            \"title\": \"Title of the article\",\r\n            \"description\": \"Title of the article.\\n\\nRepresentative title of the article.\"\r\n          },\r\n          \"body\": {\r\n            \"type\": \"string\",\r\n            \"title\": \"Content body\",\r\n            \"description\": \"Content body.\\n\\nContent body of the article writtn in the markdown format.\"\r\n          },\r\n          \"thumbnail\": {\r\n            \"oneOf\": [\r\n              {\r\n                \"type\": \"null\"\r\n              },\r\n              {\r\n                \"type\": \"string\",\r\n                \"format\": \"uri\",\r\n                \"contentMediaType\": \"image/*\"\r\n              }\r\n            ],\r\n            \"title\": \"Thumbnail image URI\",\r\n            \"description\": \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\"\r\n          }\r\n        },\r\n        \"required\": [\r\n          \"id\",\r\n          \"created_at\",\r\n          \"updated_at\",\r\n          \"title\",\r\n          \"body\",\r\n          \"thumbnail\"\r\n        ],\r\n        \"description\": \"Article entity.\\n\\n`IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\"\r\n      }\r\n    }\r\n  },\r\n  \"tags\": [],\r\n  \"x-samchon-emended\": true\r\n}\n{\r\n  \"model\": \"chatgpt\",\r\n  \"options\": {\r\n    \"reference\": false,\r\n    \"strict\": false,\r\n    \"separate\": null,\r\n    \"maxLength\": null\r\n  },\r\n  \"functions\": [\r\n    {\r\n      \"method\": \"get\",\r\n      \"path\": \"/bbs/articles/{id}\",\r\n      \"name\": \"bbs_articles_at\",\r\n      \"parameters\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"id\": {\r\n            \"description\": \" Target article's {@link IBbsArticle.id }\\n\\n\\n@format uuid\",\r\n            \"type\": \"string\"\r\n          }\r\n        },\r\n        \"additionalProperties\": false,\r\n        \"required\": [\r\n          \"id\"\r\n        ],\r\n        \"$defs\": {}\r\n      },\r\n      \"output\": {\r\n        \"description\": \"Article entity.\\n\\n`IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"id\": {\r\n            \"title\": \"Primary Key\",\r\n            \"description\": \"Primary Key.\\n\\n\\n@format uuid\",\r\n            \"type\": \"string\"\r\n          },\r\n          \"created_at\": {\r\n            \"title\": \"Creation time of the article\",\r\n            \"description\": \"Creation time of the article.\\n\\n\\n@format date-time\",\r\n            \"type\": \"string\"\r\n          },\r\n          \"updated_at\": {\r\n            \"title\": \"Last updated time of the article\",\r\n            \"description\": \"Last updated time of the article.\\n\\n\\n@format date-time\",\r\n            \"type\": \"string\"\r\n          },\r\n          \"title\": {\r\n            \"title\": \"Title of the article\",\r\n            \"description\": \"Title of the article.\\n\\nRepresentative title of the article.\",\r\n            \"type\": \"string\"\r\n          },\r\n          \"body\": {\r\n            \"title\": \"Content body\",\r\n            \"description\": \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\r\n            \"type\": \"string\"\r\n          },\r\n          \"thumbnail\": {\r\n            \"title\": \"Thumbnail image URI\",\r\n            \"description\": \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\r\n            \"anyOf\": [\r\n              {\r\n                \"type\": \"null\"\r\n              },\r\n              {\r\n                \"type\": \"string\",\r\n                \"description\": \"@format uri\\n@contentMediaType image/*\"\r\n              }\r\n            ]\r\n          }\r\n        },\r\n        \"required\": [\r\n          \"id\",\r\n          \"created_at\",\r\n          \"updated_at\",\r\n          \"title\",\r\n          \"body\",\r\n          \"thumbnail\"\r\n        ]\r\n      },\r\n      \"description\": \"Read an article.\\n\\nReads an article from the DB.\",\r\n      \"tags\": []\r\n    }\r\n  ],\r\n  \"errors\": []\r\n}\nHiding some API functions by comment tag.If you write @hidden or @internal comment tag on a controller method, it would be hidden in the Swagger Document. And if you adjust @HumanRoute() decorator to a controller method, it would be shown in the Swagger Document, but would be hidden in the LLM Application Schema.When you need to hide some internal functions from Swagger Document, or block A.I. chatbot to call some prohibited functions that must be called by human manually.","specialization#Specialization":"import { tags } from \"typia\";\r\n\r\ninterface Special {\r\n  /**\r\n   * Deprecated tags are just used for marking.\r\n   *\r\n   * @title Unsigned integer\r\n   * @deprecated\r\n   */\r\n  type: number & tags.Type<\"int32\">;\r\n \r\n  /**\r\n   * Internal tagged property never be shown in JSON schema.\r\n   *\r\n   * It even doesn't be shown in other `typia` functions like `assert<T>()`.\r\n   *\r\n   * @internal\r\n   */\r\n  internal: number[];\r\n \r\n  /**\r\n   * Hidden tagged property never be shown in JSON schema.\r\n   *\r\n   * However, it would be shown in other `typia` functions like `stringify<T>()`.\r\n   *\r\n   * @hidden\r\n   */\r\n  hidden: boolean;\r\n \r\n  /**\r\n   * You can limit the range of number.\r\n   *\r\n   * @exclusiveMinimum 19\r\n   * @maximum 100\r\n   */\r\n  number?: number;\r\n \r\n  /**\r\n   * You can limit the length of string.\r\n   *\r\n   * Also, multiple range conditions are also possible.\r\n   */\r\n  string: string &\r\n    (\r\n      | (tags.MinLength<3> & tags.MaxLength<24>)\r\n      | (tags.MinLength<40> & tags.MaxLength<100>)\r\n    );\r\n \r\n  /**\r\n   * You can limit the pattern of string.\r\n   *\r\n   * @pattern ^[a-z]+$\r\n   */\r\n  pattern: string;\r\n \r\n  /**\r\n   * You can limit the format of string.\r\n   *\r\n   * @format date-time\r\n   */\r\n  format: string | null;\r\n \r\n  /**\r\n   * In the Array case, possible to restrict its elements.\r\n   */\r\n  array: Array<string & tags.Format<\"uuid\">> & tags.MinItems<3>;\r\n}\n{\r\n  \"components\": {\r\n    \"schemas\": {\r\n      \"Special\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"type\": {\r\n            \"type\": \"integer\",\r\n            \"deprecated\": true,\r\n            \"title\": \"Unsigned integer\",\r\n            \"description\": \"Deprecated tags are just used for marking.\"       \r\n          },\r\n          \"number\": {\r\n            \"type\": \"number\",\r\n            \"exclusiveMinimum\": true,\r\n            \"minimum\": 19,\r\n            \"maximum\": 100,\r\n            \"title\": \"You can limit the range of number\",\r\n            \"description\": \"You can limit the range of number.\"\r\n          },\r\n          \"string\": {\r\n            \"oneOf\": [\r\n              {\r\n                \"type\": \"string\",\r\n                \"minLength\": 3,\r\n                \"maxLength\": 24\r\n              },\r\n              {\r\n                \"type\": \"string\",\r\n                \"minLength\": 40,\r\n                \"maxLength\": 100\r\n              }\r\n            ],\r\n            \"title\": \"You can limit the length of string\",\r\n            \"description\": \"You can limit the length of string.\\n\\nAlso, multi\r\nple range conditions are also possible.\"\r\n          },\r\n          \"pattern\": {\r\n            \"type\": \"string\",\r\n            \"pattern\": \"^[a-z]+$\",\r\n            \"title\": \"You can limit the pattern of string\",\r\n            \"description\": \"You can limit the pattern of string.\"\r\n          },\r\n          \"format\": {\r\n            \"oneOf\": [\r\n              {\r\n                \"type\": \"null\"\r\n              },\r\n              {\r\n                \"type\": \"string\",\r\n                \"format\": \"date-time\"\r\n              }\r\n            ],\r\n            \"title\": \"You can limit the format of string\",\r\n            \"description\": \"You can limit the format of string.\"\r\n          },\r\n          \"array\": {\r\n            \"type\": \"array\",\r\n            \"items\": {\r\n              \"type\": \"string\",\r\n              \"format\": \"uuid\"\r\n            },\r\n            \"minItems\": 3,\r\n            \"title\": \"In the Array case, possible to restrict its elements\",  \r\n            \"description\": \"In the Array case, possible to restrict its elements.\"\r\n          }\r\n        },\r\n        \"required\": [\r\n          \"type\",\r\n          \"string\",\r\n          \"pattern\",\r\n          \"format\",\r\n          \"array\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}\nYou can utilize type tags (or validator’s comment tags) to constructing special fields of JSON schema.If you write any comment on a property, it would fill the IJsonSchema.description value. Also, there’re special comment tags only for JSON schema definition that are different with validator’s comment tags like below.\n@deprecated\n@hidden\n@internal\n@title {string}\nLet’s see how those type tags, comment tags and description comments are working with example code."}},"/docs/core/TypedBody":{"title":"Guide Documents > Core Library > TypedBody","data":{"outline#Outline":"export function TypedBody(): ParameterDecorator;\nRequest body decorator 20,000x faster, even easy to use.@TypedBody() is a decorator function parsing application/json typed request body, and validates the request body value type through typia.validate<T>() function. If the request body is not following the promised type, 400 bad request error would be thrown.It is almost same with original @Body() function of NestJS, however, 20,000x faster.Also, @TypedBody() is much more easier to use than class-validator, because it can use pure TypeScript type. If you can't understand the word \"pure TypeScript type\", then move to below #How to use section and read the IBbsArticle.IUpdate interface type. You may understand what it means.\nIf you want other Content-Type, use one of below:\napplication/x-www-form-urlencoded: @TypedQuery.Body().\nmultipart/form-data: @TypedFormData.Body()\n@TypedBody() is not essential for Swagger Documents or SDK Library building.Therefore, it is not a matter to use @TypedBody() or @Body() of the original NestJS.","how-to-use#How to use":"import { tags } from \"typia\";\r\n\r\nexport interface IBbsArticle extends IBbsArticle.IStore {\r\n  id: string & tags.Format<\"uuid\">;\r\n  created_at: string & tags.Format<\"date-time\">;\r\n}\r\nexport namespace IBbsArticle {\r\n  export interface IStore {\r\n    title: string & tags.MinLength<3> & tags.MaxLength<50>;\r\n    body: string;\r\n    files: IAttachmentFile[];\r\n  }\r\n}\nimport { tags } from \"typia\";\r\n\r\nexport interface IAttachmentFile {\r\n  name: null | (string & tags.MinLength<1> & tags.MaxLength<255>);\r\n  extension: null | (string & tags.MinLength<1> & tags.MaxLength<8>);\r\n  url: string & tags.Format<\"url\">;\r\n}\nimport { TypedBody, TypedRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport { tags } from \"typia\";\r\n\r\nimport { IBbsArticle } from \"./IBbsArticle\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  @TypedRoute.Post()\r\n  public async store(\r\n    @TypedBody() input: IBbsArticle.IStore,\r\n  ): Promise<IBbsArticle> {\r\n    return {\r\n      ...input,\r\n      id: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\r\n      created_at: \"2023-04-23T12:04:54.168Z\",\r\n    };\r\n  }\r\n}\n\"use strict\";\r\nvar __decorate =\r\n  (this && this.__decorate) ||\r\n  function (decorators, target, key, desc) {\r\n    var c = arguments.length,\r\n      r =\r\n        c < 3\r\n          ? target\r\n          : desc === null\r\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\r\n          : desc,\r\n      d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\r\n      r = Reflect.decorate(decorators, target, key, desc);\r\n    else\r\n      for (var i = decorators.length - 1; i >= 0; i--)\r\n        if ((d = decorators[i]))\r\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n  };\r\nvar __metadata =\r\n  (this && this.__metadata) ||\r\n  function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\r\n      return Reflect.metadata(k, v);\r\n  };\r\nvar __param =\r\n  (this && this.__param) ||\r\n  function (paramIndex, decorator) {\r\n    return function (target, key) {\r\n      decorator(target, key, paramIndex);\r\n    };\r\n  };\r\nvar __awaiter =\r\n  (this && this.__awaiter) ||\r\n  function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) {\r\n      return value instanceof P\r\n        ? value\r\n        : new P(function (resolve) {\r\n            resolve(value);\r\n          });\r\n    }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n      function fulfilled(value) {\r\n        try {\r\n          step(generator.next(value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function rejected(value) {\r\n        try {\r\n          step(generator[\"throw\"](value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function step(result) {\r\n        result.done\r\n          ? resolve(result.value)\r\n          : adopt(result.value).then(fulfilled, rejected);\r\n      }\r\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BbsArticlesController = void 0;\r\nconst core_1 = require(\"@nestia/core\");\r\nconst common_1 = require(\"@nestjs/common\");\r\nlet BbsArticlesController = class BbsArticlesController {\r\n  store(input) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return Object.assign(Object.assign({}, input), {\r\n        id: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\r\n        created_at: \"2023-04-23T12:04:54.168Z\",\r\n      });\r\n    });\r\n  }\r\n};\r\nexports.BbsArticlesController = BbsArticlesController;\r\n__decorate(\r\n  [\r\n    core_1.TypedRoute.Post({\r\n      type: \"assert\",\r\n      assert: (input) => {\r\n        const assert = (input) => {\r\n          const __is = (input) => {\r\n            const $io0 = (input) =>\r\n              \"string\" === typeof input.id &&\r\n              /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n                input.id,\r\n              ) &&\r\n              \"string\" === typeof input.created_at &&\r\n              !isNaN(new Date(input.created_at).getTime()) &&\r\n              \"string\" === typeof input.title &&\r\n              3 <= input.title.length &&\r\n              input.title.length <= 50 &&\r\n              \"string\" === typeof input.body &&\r\n              Array.isArray(input.files) &&\r\n              input.files.every(\r\n                (elem) =>\r\n                  \"object\" === typeof elem && null !== elem && $io1(elem),\r\n              );\r\n            const $io1 = (input) =>\r\n              (null === input.name ||\r\n                (\"string\" === typeof input.name &&\r\n                  1 <= input.name.length &&\r\n                  input.name.length <= 255)) &&\r\n              (null === input.extension ||\r\n                (\"string\" === typeof input.extension &&\r\n                  1 <= input.extension.length &&\r\n                  input.extension.length <= 8)) &&\r\n              \"string\" === typeof input.url &&\r\n              /^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(\r\n                input.url,\r\n              );\r\n            return \"object\" === typeof input && null !== input && $io0(input);\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.TypedRoute.Post.guard;\r\n              const $ao0 = (input, _path, _exceptionable = true) =>\r\n                ((\"string\" === typeof input.id &&\r\n                  (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n                    input.id,\r\n                  ) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".id\",\r\n                      expected: 'string & Format<\"uuid\">',\r\n                      value: input.id,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".id\",\r\n                    expected: '(string & Format<\"uuid\">)',\r\n                    value: input.id,\r\n                  })) &&\r\n                ((\"string\" === typeof input.created_at &&\r\n                  (!isNaN(new Date(input.created_at).getTime()) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".created_at\",\r\n                      expected: 'string & Format<\"date-time\">',\r\n                      value: input.created_at,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".created_at\",\r\n                    expected: '(string & Format<\"date-time\">)',\r\n                    value: input.created_at,\r\n                  })) &&\r\n                ((\"string\" === typeof input.title &&\r\n                  (3 <= input.title.length ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MinLength<3>\",\r\n                      value: input.title,\r\n                    })) &&\r\n                  (input.title.length <= 50 ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MaxLength<50>\",\r\n                      value: input.title,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".title\",\r\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\r\n                    value: input.title,\r\n                  })) &&\r\n                (\"string\" === typeof input.body ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".body\",\r\n                    expected: \"string\",\r\n                    value: input.body,\r\n                  })) &&\r\n                (((Array.isArray(input.files) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files\",\r\n                    expected: \"Array<IAttachmentFile>\",\r\n                    value: input.files,\r\n                  })) &&\r\n                  input.files.every(\r\n                    (elem, _index1) =>\r\n                      (((\"object\" === typeof elem && null !== elem) ||\r\n                        $guard(_exceptionable, {\r\n                          path: _path + \".files[\" + _index1 + \"]\",\r\n                          expected: \"IAttachmentFile\",\r\n                          value: elem,\r\n                        })) &&\r\n                        $ao1(\r\n                          elem,\r\n                          _path + \".files[\" + _index1 + \"]\",\r\n                          true && _exceptionable,\r\n                        )) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".files[\" + _index1 + \"]\",\r\n                        expected: \"IAttachmentFile\",\r\n                        value: elem,\r\n                      }),\r\n                  )) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files\",\r\n                    expected: \"Array<IAttachmentFile>\",\r\n                    value: input.files,\r\n                  }));\r\n              const $ao1 = (input, _path, _exceptionable = true) =>\r\n                (null === input.name ||\r\n                  (\"string\" === typeof input.name &&\r\n                    (1 <= input.name.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".name\",\r\n                        expected: \"string & MinLength<1>\",\r\n                        value: input.name,\r\n                      })) &&\r\n                    (input.name.length <= 255 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".name\",\r\n                        expected: \"string & MaxLength<255>\",\r\n                        value: input.name,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".name\",\r\n                    expected:\r\n                      \"((string & MinLength<1> & MaxLength<255>) | null)\",\r\n                    value: input.name,\r\n                  })) &&\r\n                (null === input.extension ||\r\n                  (\"string\" === typeof input.extension &&\r\n                    (1 <= input.extension.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".extension\",\r\n                        expected: \"string & MinLength<1>\",\r\n                        value: input.extension,\r\n                      })) &&\r\n                    (input.extension.length <= 8 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".extension\",\r\n                        expected: \"string & MaxLength<8>\",\r\n                        value: input.extension,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".extension\",\r\n                    expected: \"((string & MinLength<1> & MaxLength<8>) | null)\",\r\n                    value: input.extension,\r\n                  })) &&\r\n                ((\"string\" === typeof input.url &&\r\n                  (/^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(\r\n                    input.url,\r\n                  ) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".url\",\r\n                      expected: 'string & Format<\"url\">',\r\n                      value: input.url,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".url\",\r\n                    expected: '(string & Format<\"url\">)',\r\n                    value: input.url,\r\n                  }));\r\n              return (\r\n                (((\"object\" === typeof input && null !== input) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IBbsArticle\",\r\n                    value: input,\r\n                  })) &&\r\n                  $ao0(input, _path + \"\", true)) ||\r\n                $guard(true, {\r\n                  path: _path + \"\",\r\n                  expected: \"IBbsArticle\",\r\n                  value: input,\r\n                })\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        };\r\n        const stringify = (input) => {\r\n          const $io1 = (input) =>\r\n            (null === input.name ||\r\n              (\"string\" === typeof input.name &&\r\n                1 <= input.name.length &&\r\n                input.name.length <= 255)) &&\r\n            (null === input.extension ||\r\n              (\"string\" === typeof input.extension &&\r\n                1 <= input.extension.length &&\r\n                input.extension.length <= 8)) &&\r\n            \"string\" === typeof input.url &&\r\n            /^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(\r\n              input.url,\r\n            );\r\n          const $string = core_1.TypedRoute.Post.string;\r\n          const $so0 = (input) =>\r\n            `{\"id\":${$string(input.id)},\"created_at\":${$string(\r\n              input.created_at,\r\n            )},\"title\":${$string(input.title)},\"body\":${$string(\r\n              input.body,\r\n            )},\"files\":${`[${input.files\r\n              .map((elem) => $so1(elem))\r\n              .join(\",\")}]`}}`;\r\n          const $so1 = (input) =>\r\n            `{\"name\":${\r\n              null !== input.name ? $string(input.name) : \"null\"\r\n            },\"extension\":${\r\n              null !== input.extension ? $string(input.extension) : \"null\"\r\n            },\"url\":${$string(input.url)}}`;\r\n          return $so0(input);\r\n        };\r\n        return stringify(assert(input));\r\n      },\r\n    }),\r\n    __param(\r\n      0,\r\n      (0, core_1.TypedBody)({\r\n        type: \"assert\",\r\n        assert: (input) => {\r\n          const __is = (input) => {\r\n            const $io0 = (input) =>\r\n              \"string\" === typeof input.title &&\r\n              3 <= input.title.length &&\r\n              input.title.length <= 50 &&\r\n              \"string\" === typeof input.body &&\r\n              Array.isArray(input.files) &&\r\n              input.files.every(\r\n                (elem) =>\r\n                  \"object\" === typeof elem && null !== elem && $io1(elem),\r\n              );\r\n            const $io1 = (input) =>\r\n              (null === input.name ||\r\n                (\"string\" === typeof input.name &&\r\n                  1 <= input.name.length &&\r\n                  input.name.length <= 255)) &&\r\n              (null === input.extension ||\r\n                (\"string\" === typeof input.extension &&\r\n                  1 <= input.extension.length &&\r\n                  input.extension.length <= 8)) &&\r\n              \"string\" === typeof input.url &&\r\n              /^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(\r\n                input.url,\r\n              );\r\n            return \"object\" === typeof input && null !== input && $io0(input);\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.TypedBody.guard;\r\n              const $ao0 = (input, _path, _exceptionable = true) =>\r\n                ((\"string\" === typeof input.title &&\r\n                  (3 <= input.title.length ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MinLength<3>\",\r\n                      value: input.title,\r\n                    })) &&\r\n                  (input.title.length <= 50 ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MaxLength<50>\",\r\n                      value: input.title,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".title\",\r\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\r\n                    value: input.title,\r\n                  })) &&\r\n                (\"string\" === typeof input.body ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".body\",\r\n                    expected: \"string\",\r\n                    value: input.body,\r\n                  })) &&\r\n                (((Array.isArray(input.files) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files\",\r\n                    expected: \"Array<IAttachmentFile>\",\r\n                    value: input.files,\r\n                  })) &&\r\n                  input.files.every(\r\n                    (elem, _index1) =>\r\n                      (((\"object\" === typeof elem && null !== elem) ||\r\n                        $guard(_exceptionable, {\r\n                          path: _path + \".files[\" + _index1 + \"]\",\r\n                          expected: \"IAttachmentFile\",\r\n                          value: elem,\r\n                        })) &&\r\n                        $ao1(\r\n                          elem,\r\n                          _path + \".files[\" + _index1 + \"]\",\r\n                          true && _exceptionable,\r\n                        )) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".files[\" + _index1 + \"]\",\r\n                        expected: \"IAttachmentFile\",\r\n                        value: elem,\r\n                      }),\r\n                  )) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files\",\r\n                    expected: \"Array<IAttachmentFile>\",\r\n                    value: input.files,\r\n                  }));\r\n              const $ao1 = (input, _path, _exceptionable = true) =>\r\n                (null === input.name ||\r\n                  (\"string\" === typeof input.name &&\r\n                    (1 <= input.name.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".name\",\r\n                        expected: \"string & MinLength<1>\",\r\n                        value: input.name,\r\n                      })) &&\r\n                    (input.name.length <= 255 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".name\",\r\n                        expected: \"string & MaxLength<255>\",\r\n                        value: input.name,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".name\",\r\n                    expected:\r\n                      \"((string & MinLength<1> & MaxLength<255>) | null)\",\r\n                    value: input.name,\r\n                  })) &&\r\n                (null === input.extension ||\r\n                  (\"string\" === typeof input.extension &&\r\n                    (1 <= input.extension.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".extension\",\r\n                        expected: \"string & MinLength<1>\",\r\n                        value: input.extension,\r\n                      })) &&\r\n                    (input.extension.length <= 8 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".extension\",\r\n                        expected: \"string & MaxLength<8>\",\r\n                        value: input.extension,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".extension\",\r\n                    expected: \"((string & MinLength<1> & MaxLength<8>) | null)\",\r\n                    value: input.extension,\r\n                  })) &&\r\n                ((\"string\" === typeof input.url &&\r\n                  (/^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(\r\n                    input.url,\r\n                  ) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".url\",\r\n                      expected: 'string & Format<\"url\">',\r\n                      value: input.url,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".url\",\r\n                    expected: '(string & Format<\"url\">)',\r\n                    value: input.url,\r\n                  }));\r\n              return (\r\n                (((\"object\" === typeof input && null !== input) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IBbsArticle.IStore\",\r\n                    value: input,\r\n                  })) &&\r\n                  $ao0(input, _path + \"\", true)) ||\r\n                $guard(true, {\r\n                  path: _path + \"\",\r\n                  expected: \"IBbsArticle.IStore\",\r\n                  value: input,\r\n                })\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        },\r\n      }),\r\n    ),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object]),\r\n    __metadata(\"design:returntype\", Promise),\r\n  ],\r\n  BbsArticlesController.prototype,\r\n  \"store\",\r\n  null,\r\n);\r\nexports.BbsArticlesController = BbsArticlesController = __decorate(\r\n  [(0, common_1.Controller)(\"bbs/articles\")],\r\n  BbsArticlesController,\r\n);\nJust call @TypedBody() function on the request body parameter, that's all.Nestia will analyze your type (IBbsArticle.IUpdate), and writes optimal code for the target type, in the compilation level. If you click the \"Complied JavaScript File\" tab of above, you can see the optimal validation code.Such optimization is called AOT (Ahead of Time) compilation, and it is the secret of @TypedBody.","special-tags#Special Tags":"You can enhance validation logic, of @TypedBody(), through special tags.You know what? @TypedBody() utilizes typia.validate<T>() function for request body data validation, and the typia.validate<T>() function supports additional type checking logics through type and comment tags. For reference, \"Type Tag\" means a intersection type with atomic type and special tag type of typia like number & tags.Type<\"uint32\">, and \"Comment Tag\" means a comment starting from @ symbol following @${name} ${value} format.With those type and comment tags, you can add additional validation logics. If you want to add a custom validation logic, you also can do it. Read below Guide Docments of typia, and see the example code. You may understand how to utilize such type and comment tags, in a few minutes.\ntypia > Validators > Custom Tags\nOutline\nType Tags\nComment Tags\nCustomization\nimport typia, { tags } from \"typia\";\r\n\r\nexport const checkSpecialTag = typia.createIs<SpecialTag>();\r\n\r\ninterface SpecialTag {\r\n  int32: number & tags.Type<\"int32\">;\r\n  range?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\r\n  minLength: string & tags.MinLength<3>;\r\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\r\n  date: null | (string & tags.Format<\"date\">);\r\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\r\n  uuids: Array<string & tags.Format<\"uuid\">> &\r\n    tags.MinItems<3> &\r\n    tags.MaxItems<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.checkSpecialTag = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst checkSpecialTag = (input) => {\r\n  const $io0 = (input) =>\r\n    \"number\" === typeof input.int32 &&\r\n    Math.floor(input.int32) === input.int32 &&\r\n    -2147483648 <= input.int32 &&\r\n    input.int32 <= 2147483647 &&\r\n    (undefined === input.range ||\r\n      (\"number\" === typeof input.range &&\r\n        19 < input.range &&\r\n        input.range <= 100)) &&\r\n    \"string\" === typeof input.minLength &&\r\n    3 <= input.minLength.length &&\r\n    \"string\" === typeof input.pattern &&\r\n    /^[a-z]+$/.test(input.pattern) &&\r\n    (null === input.date ||\r\n      (\"string\" === typeof input.date &&\r\n        /^(d{4})-(d{2})-(d{2})$/.test(input.date))) &&\r\n    \"string\" === typeof input.ip &&\r\n    (/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\r\n      input.ip,\r\n    ) ||\r\n      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(\r\n        input.ip,\r\n      )) &&\r\n    Array.isArray(input.uuids) &&\r\n    3 <= input.uuids.length &&\r\n    input.uuids.length <= 100 &&\r\n    input.uuids.every(\r\n      (elem) =>\r\n        \"string\" === typeof elem &&\r\n        /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n          elem,\r\n        ),\r\n    );\r\n  return \"object\" === typeof input && null !== input && $io0(input);\r\n};\r\nexports.checkSpecialTag = checkSpecialTag;","encryptedbody#EncryptedBody":"Encrypted request body decorator function.@EncryptedBody() is a decorator function similar with @TypedBody(), but it encrypts the request body through AES-128/256-CBC algorithm like below. Therefore, it would be slower than @TypedBody(), but it guarantees the security of request body data.\nAES-128/256\nCBC mode\nPKCS #5 Padding\nBase64 Encoding\nFor reference, such encryption spec is not supported in the Swagger-UI. Instead, SDK (Software Development Kit) generated by @nestia/sdk supports it. Thus, you have to build and distribute the SDK library to the client developers when using such encryption decorators.","configuration#Configuration":"{\r\n  \"compilerOptions\": {\r\n    \"strict\": true,\r\n    \"plugins\": [\r\n      { \"transform\": \"typia/lib/transform\" },\r\n      {\r\n        \"transform\": \"@nestia/core/lib/transform\",\r\n        \"validate\": \"validate\",\r\n        // \"llm\": {\r\n        //   \"model\": \"chatgpt\",\r\n        //   \"strict\": true,\r\n        // },\r\n      }\r\n    ]\r\n  }\r\n}\nChange type validation function to another one.If you configure validate property of plugin defined in the tsconfig.json file, you can change the @TypedBody() to use another validation function instead of the default typia.validate<T> function. For example, if you want to use typia.validateEquals<T>() function instead, then set the validate property to validateEquals.Below is the list of available validation functions.\nis or equals: check validation only, and do not reveal the reason why\nassert or assertEquals: find the 1st type error with reason\nvalidate or validateEquals: find every type errors with detailed reasons\nassertPrune or validatePrune: prune extra properties with type checking\nassertClone or validateClone: deep clone with type checking for faster pruning\nAlso, if you configure llm property of the plugin, @nestia/core considers that your backend application has been developed for LLM function calling, and validates the request/response body types following the target LLM model's restrictions.For example, if you configure chatgpt with strict option, dynamic properties and optional properties are not allowed in the request/response body types. If your some request/response body types are not following the target LLM model's restrictions, @nestia/core will throw a compilation error.Here is the list of available LLM models. Read their definitions, and follow their restrictions.\nSupported schemas\n\"chatgpt\": (IChatGptSchema), OpenAI ChatGPT\n\"claude\": (IClaudeSchema), Anthropic Claude\n\"gemini\": (IGeminiSchema), Google Gemini\n\"llama\": (ILlamaSchema), Meta Llama\nMidldle layer schemas\n\"3.0\": (ILlmSchemaV3), middle layer based on OpenAPI v3.0 specification\n\"3.1\": (ILlmSchemaV3_1), middle layer based on OpenAPI v3.1 specification","benchmark#Benchmark":"Super-fast and super-safe.Nestia utilizes typia, and NestJS uses class-validator. One thing amazing is, typia is maximum 20,000x faster than class-validator of NestJS. Color of class-transformer is skyblue, and can you find the skyblue color in the below benchmark graph? It may hard to find because class-validator is extremely slow.\nMeasured on AMD R9-7940HS, Rog Flow X13\nFurthermore, while other libraries can't validate complicate union types, typia can validate every TypeScript types. However, in the class-validator case, it always be failed when any type of complicate comes. I can't understand why NestJS has adopted such slow and unstable library.Moreover, only typia can utilize pure TypeScript type, without any extra schema definition. Beside, all of other libraries require extra and duplicated schema definition, different with pure TypeScript type. Nestia is using such wonderful, super-fast and super-fast typia library.\nTypeBox requires TypeBox schema\najv requires JSON schema definition\nio-ts requires io-ts schema\nzod requires zod schema\nclass-validator requires DTO class with decorator function calls\nComponents\ttypia\tTypeBox\tajv\tio-ts\tzod\tC.V.\tEasy to use\t✅\t❌\t❌\t❌\t❌\t❌\tObject (simple)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (recursive)\t✔\t❌\t✔\t✔\t✔\t✔\t✔\tObject (union, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tObject (union, explicit)\t✔\t✔\t✔\t✔\t✔\t❌\tObject (additional tags)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (template literal types)\t✔\t✔\t✔\t❌\t❌\t❌\tObject (dynamic properties)\t✔\t✔\t✔\t❌\t❌\t❌\tArray (rest tuple)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tArray (recursive)\t✔\t✔\t✔\t✔\t✔\t❌\tArray (recursive, union)\t✔\t✔\t❌\t✔\t✔\t❌\tArray (R+U, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tUltimate Union Type\t✅\t❌\t❌\t❌\t❌\t❌\t\nC.V. means class-validator"}},"/docs/core/TypedFormData":{"title":"Guide Documents > Core Library > TypedFormData","data":{"outline#Outline":"export namespace TypedFormData {\r\n  export function Body<Multer extends IMulterBase>(\r\n    factory: () => Multer | Promise<Multer>\r\n  ): ParameterDecorator;\r\n  export type IMulterBase = ExpressMulter.Multer | FastifyMulter.Multer;\r\n}\nRequest body decorator of multipart/form-data.@TypedFormData.Body() is a request body decorator function, for the multipart/form-data content type. It is useful for file uploading with additional data, and automatically casts property type following its DTO definition, performing the type validation.As you can see from the below code, @TypedFormData.Body() function is much easier and type safer than @UploadFile() of NestJS. Also, if you're considering the SDK library generation, only @TypedFormData.Body() is supported. Therefore, I recommend you to utilize @TypedFormData.Body() instead of the @UploadFile() function.Of course, as every features of nestia does, you don't need to define any extra schema definition for the Swagger Documents generation. @nestia/sdk and @TypedFormData.Body() will do everything just by analyzing your TypeScript types and codes.\nimport { TypedFormData, TypedRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport Multer from \"multer\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  @TypedRoute.Post()\r\n  public async create(\r\n    @TypedFormData.Body(() => Multer()) input: IBbsArticleCreate,\r\n  ): Promise<void> {\r\n    input;\r\n  }\r\n}\r\n\r\nexport interface IBbsArticleCreate {\r\n  title: string;\r\n  body: string | null;\r\n  thumbnail?: File | undefined;\r\n  files: File[];\r\n  tags: string[];\r\n}\nimport { \r\n  Body, \r\n  Controller, \r\n  Post, \r\n  UploadedFile, \r\n  UploadedFiles, \r\n  UseInterceptors \r\n} from \"@nestjs/common\";\r\nimport { ApiBody, ApiConsumes } from \"@nestjs/swagger\";\r\nimport { FileFieldsInterceptor } from \"@nestjs/platform-express\";\r\nimport { IsArray, IsOptional, IsString } from \"class-validator\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  @Post()\r\n  @ApiConsumes(\"multipart/form-data\")\r\n  @UseInterceptors(\r\n    FileFieldsInterceptor([\r\n      { name: \"thumbnail\", maxCount: 1 },\r\n      { name: \"files\" },\r\n    ]),\r\n  )\r\n  @ApiBody({\r\n    schema: {\r\n      type: \"object\",\r\n      properties: {\r\n        title: {\r\n          type: \"string\",\r\n        },\r\n        body: {\r\n          type: \"string\",\r\n          nullable: true,\r\n        },\r\n        thumbnail: {\r\n          type: \"string\",\r\n          format: \"binary\",\r\n        },\r\n        files: {\r\n          type: \"array\",\r\n          items: {\r\n            type: \"string\",\r\n            format: \"binary\",\r\n          },\r\n        },\r\n      },\r\n      required: [\r\n        \"id\", \r\n        \"title\", \r\n        \"body\", \r\n        \"files\",\r\n        \"tags\",\r\n        \"created_at\",\r\n      ],\r\n    },\r\n  })\r\n  public async create(\r\n    @Body() input: BbsArticleCreateDto,\r\n    @UploadedFiles() binary: {\r\n      thumbnail?: Express.Multer.File[];\r\n      files: Express.Multer.File[];\r\n    },\r\n  ): Promise<void> {\r\n    input;\r\n    binary;\r\n  }\r\n}\r\n\r\nexport class BbsArticleCreateDto {\r\n  @IsString()\r\n  title: string;\r\n\r\n  @IsString()\r\n  @IsOptional()\r\n  body: string | null;\r\n\r\n  @IsArray({ each: true })\r\n  @IsString()\r\n  tags: string[];\r\n}","how-to-use#How to use":"export interface IBbsArticleCreate {\r\n  title: string;\r\n  body: string | null;\r\n  thumbnail?: File | undefined;\r\n  files: File[];\r\n  tags: string[];\r\n}\nimport { TypedFormData, TypedRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport Multer from \"multer\";\r\n\r\nimport { IBbsArticleCreate } from \"./IBbsArticleCreate\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  @TypedRoute.Post()\r\n  public async create(\r\n    @TypedFormData.Body(() => Multer()) input: IBbsArticleCreate,\r\n  ): Promise<void> {\r\n    input;\r\n  }\r\n}\n\"use strict\";\r\nvar __decorate =\r\n  (this && this.__decorate) ||\r\n  function (decorators, target, key, desc) {\r\n    var c = arguments.length,\r\n      r =\r\n        c < 3\r\n          ? target\r\n          : desc === null\r\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\r\n          : desc,\r\n      d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\r\n      r = Reflect.decorate(decorators, target, key, desc);\r\n    else\r\n      for (var i = decorators.length - 1; i >= 0; i--)\r\n        if ((d = decorators[i]))\r\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n  };\r\nvar __metadata =\r\n  (this && this.__metadata) ||\r\n  function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\r\n      return Reflect.metadata(k, v);\r\n  };\r\nvar __param =\r\n  (this && this.__param) ||\r\n  function (paramIndex, decorator) {\r\n    return function (target, key) {\r\n      decorator(target, key, paramIndex);\r\n    };\r\n  };\r\nvar __awaiter =\r\n  (this && this.__awaiter) ||\r\n  function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) {\r\n      return value instanceof P\r\n        ? value\r\n        : new P(function (resolve) {\r\n            resolve(value);\r\n          });\r\n    }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n      function fulfilled(value) {\r\n        try {\r\n          step(generator.next(value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function rejected(value) {\r\n        try {\r\n          step(generator[\"throw\"](value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function step(result) {\r\n        result.done\r\n          ? resolve(result.value)\r\n          : adopt(result.value).then(fulfilled, rejected);\r\n      }\r\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BbsArticlesController = void 0;\r\nconst core_1 = require(\"@nestia/core\");\r\nconst common_1 = require(\"@nestjs/common\");\r\nlet BbsArticlesController = class BbsArticlesController {\r\n  create(input) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      input;\r\n    });\r\n  }\r\n};\r\nexports.BbsArticlesController = BbsArticlesController;\r\n__decorate(\r\n  [\r\n    core_1.TypedRoute.Post({\r\n      type: \"assert\",\r\n      assert: (input) => {\r\n        const assert = (input) => {\r\n          const __is = (input) => {\r\n            return null !== input && undefined === input;\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.TypedRoute.Post.guard;\r\n              return (\r\n                (null !== input ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"undefined\",\r\n                    value: input,\r\n                  })) &&\r\n                (undefined === input ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"undefined\",\r\n                    value: input,\r\n                  }))\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        };\r\n        const stringify = (input) => {\r\n          return undefined;\r\n        };\r\n        return stringify(assert(input));\r\n      },\r\n    }),\r\n    __param(\r\n      0,\r\n      core_1.TypedFormData.Body({\r\n        files: [\r\n          {\r\n            name: \"thumbnail\",\r\n            limit: 1,\r\n          },\r\n          {\r\n            name: \"files\",\r\n            limit: null,\r\n          },\r\n        ],\r\n        validator: {\r\n          type: \"assert\",\r\n          assert: (input) => {\r\n            const decode = (input) => {\r\n              var _a;\r\n              const $string = core_1.TypedFormData.Body.string;\r\n              const $file = core_1.TypedFormData.Body.file;\r\n              const output = {\r\n                title: $string(input.get(\"title\")),\r\n                body: $string(input.get(\"body\")),\r\n                thumbnail:\r\n                  (_a = $file(input.get(\"thumbnail\"))) !== null && _a !== void 0\r\n                    ? _a\r\n                    : undefined,\r\n                files: input.getAll(\"files\").map((elem) => $file(elem)),\r\n                tags: input.getAll(\"tags\").map((elem) => $string(elem)),\r\n              };\r\n              return output;\r\n            };\r\n            const assert = (input) => {\r\n              const __is = (input) => {\r\n                const $io0 = (input) =>\r\n                  \"string\" === typeof input.title &&\r\n                  (null === input.body || \"string\" === typeof input.body) &&\r\n                  (undefined === input.thumbnail ||\r\n                    input.thumbnail instanceof File) &&\r\n                  Array.isArray(input.files) &&\r\n                  input.files.every((elem) => elem instanceof File) &&\r\n                  Array.isArray(input.tags) &&\r\n                  input.tags.every((elem) => \"string\" === typeof elem);\r\n                return (\r\n                  \"object\" === typeof input && null !== input && $io0(input)\r\n                );\r\n              };\r\n              if (false === __is(input))\r\n                ((input, _path, _exceptionable = true) => {\r\n                  const $guard = core_1.TypedFormData.Body.guard;\r\n                  const $ao0 = (input, _path, _exceptionable = true) =>\r\n                    (\"string\" === typeof input.title ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".title\",\r\n                        expected: \"string\",\r\n                        value: input.title,\r\n                      })) &&\r\n                    (null === input.body ||\r\n                      \"string\" === typeof input.body ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".body\",\r\n                        expected: \"(null | string)\",\r\n                        value: input.body,\r\n                      })) &&\r\n                    (undefined === input.thumbnail ||\r\n                      input.thumbnail instanceof File ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".thumbnail\",\r\n                        expected: \"(File | undefined)\",\r\n                        value: input.thumbnail,\r\n                      })) &&\r\n                    (((Array.isArray(input.files) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".files\",\r\n                        expected: \"Array<File>\",\r\n                        value: input.files,\r\n                      })) &&\r\n                      input.files.every(\r\n                        (elem, _index1) =>\r\n                          elem instanceof File ||\r\n                          $guard(_exceptionable, {\r\n                            path: _path + \".files[\" + _index1 + \"]\",\r\n                            expected: \"File\",\r\n                            value: elem,\r\n                          }),\r\n                      )) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".files\",\r\n                        expected: \"Array<File>\",\r\n                        value: input.files,\r\n                      })) &&\r\n                    (((Array.isArray(input.tags) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".tags\",\r\n                        expected: \"Array<string>\",\r\n                        value: input.tags,\r\n                      })) &&\r\n                      input.tags.every(\r\n                        (elem, _index2) =>\r\n                          \"string\" === typeof elem ||\r\n                          $guard(_exceptionable, {\r\n                            path: _path + \".tags[\" + _index2 + \"]\",\r\n                            expected: \"string\",\r\n                            value: elem,\r\n                          }),\r\n                      )) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".tags\",\r\n                        expected: \"Array<string>\",\r\n                        value: input.tags,\r\n                      }));\r\n                  return (\r\n                    (((\"object\" === typeof input && null !== input) ||\r\n                      $guard(true, {\r\n                        path: _path + \"\",\r\n                        expected: \"IBbsArticleCreate\",\r\n                        value: input,\r\n                      })) &&\r\n                      $ao0(input, _path + \"\", true)) ||\r\n                    $guard(true, {\r\n                      path: _path + \"\",\r\n                      expected: \"IBbsArticleCreate\",\r\n                      value: input,\r\n                    })\r\n                  );\r\n                })(input, \"$input\", true);\r\n              return input;\r\n            };\r\n            const output = decode(input);\r\n            return assert(output);\r\n          },\r\n        },\r\n      }),\r\n    ),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object]),\r\n    __metadata(\"design:returntype\", Promise),\r\n  ],\r\n  BbsArticlesController.prototype,\r\n  \"create\",\r\n  null,\r\n);\r\nexports.BbsArticlesController = BbsArticlesController = __decorate(\r\n  [(0, common_1.Controller)(\"bbs/articles\")],\r\n  BbsArticlesController,\r\n);\r\n//# sourceMappingURL=BbsArticlesController.js.map\nJust call @TypedFormData.Body() function on the request body parameter, that's all.Nestia will analyze your type (IBbsArticleCreate), and writes optimal code for the target type, in the compilation level. If you click the \"Compiled JavaScript File\" tab of above, you can see the optimal transformation and validation code.Such optimization is called AOT (Ahead of Time) compilation, and it is the secret of @TypedFormData.Body.By the way, if you're using fastify, you have to setup fastify-multer and configure like below when composing the NestJS application. If you don't do it, @TypedFormData.Body() will not work properly, and throw 500 internal server error when Blob or File type being utilized.\n// main.ts\r\nimport { NestFactory } from \"@nestjs/core\";\r\nimport { \r\n  FastifyAdapter, \r\n  NestFastifyApplication \r\n} from \"@nestjs/platform-fastify\";\r\nimport FastifyMulter from \"fastify-multer\";\r\n\r\nexport async function main() {\r\n  const app = await NestFactory.create<NestFastifyApplication>(\r\n    AppModule,\r\n    new FastifyAdapter(),\r\n  );\r\n  app.register(FastifyMulter.contentParser as any);\r\n  await app.listen(3000);\r\n}\r\n\r\n// BbsArticlesController.ts\r\nimport { TypedFormData, TypedRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport FastifyMulter from \"fastify-multer\";\r\n\r\nimport { IBbsArticleCreate } from \"./IBbsArticleCreate\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  @TypedRoute.Post()\r\n  public async create(\r\n    @TypedFormData.Body(() => FastifyMulter()) input: IBbsArticleCreate,\r\n  ): Promise<void> {\r\n    input;\r\n  }\r\n}","special-tags#Special Tags":"You can enhance validation logic, of @TypedFormData.Body(), through comment tags.You know what? @TypedFormData.Body() utilizes typia.assert<T>() function for form data validation, and the typia.assert<T>() function supports additional type checking logics through comment tags. For reference, \"Type Tag\" means a intersection type with atomic type and special tag type of typia like number & tags.Type<\"uint32\">, and \"Comment Tag\" means a comment starting from @ symbol following @${name} ${value} format.With those type and comment tags, you can add additional validation logics. If you want to add a custom validation logic, you also can do it. Read below Guide Documents of typia, and see the example code. You may understand how to utilize such type and comment tags, in a few minutes.\ntypia > Validators > Custom Tags\nOutline\nType Tags\nComment Tags\nCustomization\nimport typia, { tags } from \"typia\";\r\n\r\nexport const checkSpecialTag = typia.createIs<SpecialTag>();\r\n\r\ninterface SpecialTag {\r\n  int32: number & tags.Type<\"int32\">;\r\n  range?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\r\n  minLength: string & tags.MinLength<3>;\r\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\r\n  date: null | (string & tags.Format<\"date\">);\r\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\r\n  uuids: Array<string & tags.Format<\"uuid\">> &\r\n    tags.MinItems<3> &\r\n    tags.MaxItems<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.checkSpecialTag = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst checkSpecialTag = (input) => {\r\n  const $io0 = (input) =>\r\n    \"number\" === typeof input.int32 &&\r\n    Math.floor(input.int32) === input.int32 &&\r\n    -2147483648 <= input.int32 &&\r\n    input.int32 <= 2147483647 &&\r\n    (undefined === input.range ||\r\n      (\"number\" === typeof input.range &&\r\n        19 < input.range &&\r\n        input.range <= 100)) &&\r\n    \"string\" === typeof input.minLength &&\r\n    3 <= input.minLength.length &&\r\n    \"string\" === typeof input.pattern &&\r\n    /^[a-z]+$/.test(input.pattern) &&\r\n    (null === input.date ||\r\n      (\"string\" === typeof input.date &&\r\n        /^(d{4})-(d{2})-(d{2})$/.test(input.date))) &&\r\n    \"string\" === typeof input.ip &&\r\n    (/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\r\n      input.ip,\r\n    ) ||\r\n      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(\r\n        input.ip,\r\n      )) &&\r\n    Array.isArray(input.uuids) &&\r\n    3 <= input.uuids.length &&\r\n    input.uuids.length <= 100 &&\r\n    input.uuids.every(\r\n      (elem) =>\r\n        \"string\" === typeof elem &&\r\n        /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n          elem,\r\n        ),\r\n    );\r\n  return \"object\" === typeof input && null !== input && $io0(input);\r\n};\r\nexports.checkSpecialTag = checkSpecialTag;","restriction#Restriction":"When using @TypedFormData.Body(), you've to follow such restriction.At first, type of @TypedFormData.Body() must be a pure object type. It does not allow union type. Also, nullable and undefindable types are not allowed, either. Note that, query parameter type must be a sole object type without any extra definition.At next, type of properties must be atomic, Blob, File or array of them. In the atomic type case, the atomic type allows both nullable and undefindable types. However, mixed union atomic type like string | number or \"1\" | \"2\" | 3 are not allowed. Also, the array type does not allow both nullable and undefindable types, either.\nboolean\nnumber\nbigint\nstring\nBlob\nFile\nexport interface SomeFormDataDto {\r\n  //----\r\n  // ATOMIC OR FILE TYPES\r\n  //----\r\n  // ALLOWED\r\n  boolean: boolean;\r\n  number: number;\r\n  string: string;\r\n  bigint: bigint;\r\n  optional_number?: number;\r\n  nullable_string: string | null;\r\n  literal_union: \"A\" | \"B\" | \"C\" | \"D\";\r\n  blob: Blob;\r\n  file: File;\r\n\r\n  // NOT ALLOWED\r\n  mixed_union: string | number | boolean;\r\n  mixed_literal: \"A\" | \"B\" | 3;\r\n\r\n  //----\r\n  // ARRAY TYPES\r\n  //----\r\n  // ALLOWED\r\n  nullable_element_array: (string | null)[];\r\n  string_array: string[];\r\n  number_array: number[];\r\n  literal_union_array: (\"A\" | \"B\" | \"C\")[];\r\n  literal_tuple: [\"A\", \"B\", \"C\"];\r\n  blobs: Blob[];\r\n  files: File[];\r\n\r\n  // NOT ALLOWED\r\n  optional_element_array: (string | undefined)[];\r\n  optional_array: string[] | undefined;\r\n  nullable_array: string[] | null;\r\n  union_atomic_array: (string | number)[];\r\n  mixed_literal_array: (\"A\", \"B\", 3)[];\r\n  mixed_tuple: [\"A\", \"B\", 3];\r\n}"}},"/docs/core/TypedHeaders":{"title":"Guide Documents > Core Library > TypedHeaders","data":{"outline#Outline":"export function TypedHeaders(): ParameterDecorator;\nRequest headers decorator, type safe.@TypedHeaders() is a decorator function parsing request headers to a typed object. It validates the request header values through typia.assert<T>(). If the request header values are invalid, it will throw 400 bad request exception.It is almost same with original @Headers() of NestJS, but much type safe.\n@TypedHeaders() is not essential for Swagger Documents or SDK Library building.Therefore, it is not a matter to use @TypedHeaders() or @Headers() of the original NestJS.","how-to-use#How to use":"export interface IHeaders {\r\n  \"x-category\": \"x\" | \"y\" | \"z\";\r\n  \"x-memo\"?: string;\r\n  \"x-name\"?: string;\r\n  \"x-values\": number[];\r\n  \"x-flags\": boolean[];\r\n  \"X-Descriptions\": string[]; // ALLOW UPPER-CASE\r\n}\nimport { Controller } from \"@nestjs/common\";\r\n\r\nimport core from \"@nestia/core\";\r\n\r\nimport { IHeaders } from \"@api/lib/structures/IHeaders\";\r\n\r\n@Controller(\"headers/:section\")\r\nexport class HeadersController {\r\n  /**\r\n   * Emplace headers.\r\n   *\r\n   * @param headers Headers for authentication\r\n   * @param section Target section code\r\n   * @returns Store article\r\n   *\r\n   * @author Samchon\r\n   */\r\n  @core.TypedRoute.Patch()\r\n  public emplace(\r\n    @core.TypedHeaders() headers: IHeaders,\r\n    @core.TypedParam(\"section\", \"string\") section: string,\r\n  ): void {\r\n    headers;\r\n    section;\r\n  }\r\n}\n\"use strict\";\r\nvar __decorate =\r\n  (this && this.__decorate) ||\r\n  function (decorators, target, key, desc) {\r\n    var c = arguments.length,\r\n      r =\r\n        c < 3\r\n          ? target\r\n          : desc === null\r\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\r\n          : desc,\r\n      d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\r\n      r = Reflect.decorate(decorators, target, key, desc);\r\n    else\r\n      for (var i = decorators.length - 1; i >= 0; i--)\r\n        if ((d = decorators[i]))\r\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n  };\r\nvar __metadata =\r\n  (this && this.__metadata) ||\r\n  function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\r\n      return Reflect.metadata(k, v);\r\n  };\r\nvar __param =\r\n  (this && this.__param) ||\r\n  function (paramIndex, decorator) {\r\n    return function (target, key) {\r\n      decorator(target, key, paramIndex);\r\n    };\r\n  };\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.HeadersController = void 0;\r\nconst common_1 = require(\"@nestjs/common\");\r\nconst core_1 = __importDefault(require(\"@nestia/core\"));\r\nlet HeadersController = (exports.HeadersController = class HeadersController {\r\n  /**\r\n   * Emplace headers.\r\n   *\r\n   * @param headers Headers for authentication\r\n   * @param section Target section code\r\n   * @returns Store article\r\n   *\r\n   * @author Samchon\r\n   */\r\n  emplace(headers, section) {\r\n    headers;\r\n    section;\r\n  }\r\n});\r\n__decorate(\r\n  [\r\n    (0, common_1.Get)(),\r\n    __param(\r\n      0,\r\n      core_1.default.TypedHeaders((input) => {\r\n        const $number = core_1.default.TypedHeaders.number;\r\n        const $boolean = core_1.default.TypedHeaders.boolean;\r\n        const $string = core_1.default.TypedHeaders.string;\r\n        const output = {\r\n          \"x-category\": input[\"x-category\"],\r\n          \"x-memo\": input[\"x-memo\"],\r\n          \"x-name\": input[\"x-name\"],\r\n          \"x-values\": input[\"x-values\"]?.split(\", \")?.map($number),\r\n          \"x-flags\": input[\"x-flags\"]?.split(\", \")?.map($boolean),\r\n          \"X-Descriptions\": input[\"x-descriptions\"]?.split(\", \")?.map($string),\r\n          // AUTOMATIC UPPER-CASE CONVERTING\r\n        };\r\n        return ((input) => {\r\n          const __is = (input) => {\r\n            const $io0 = (input) =>\r\n              (\"x\" === input[\"x-category\"] ||\r\n                \"y\" === input[\"x-category\"] ||\r\n                \"z\" === input[\"x-category\"]) &&\r\n              (undefined === input[\"x-memo\"] ||\r\n                \"string\" === typeof input[\"x-memo\"]) &&\r\n              (undefined === input[\"x-name\"] ||\r\n                \"string\" === typeof input[\"x-name\"]) &&\r\n              Array.isArray(input[\"x-values\"]) &&\r\n              input[\"x-values\"].every(\r\n                (elem) => \"number\" === typeof elem && Number.isFinite(elem),\r\n              ) &&\r\n              Array.isArray(input[\"x-flags\"]) &&\r\n              input[\"x-flags\"].every((elem) => \"boolean\" === typeof elem) &&\r\n              Array.isArray(input[\"X-Descriptions\"]) &&\r\n              input[\"X-Descriptions\"].every((elem) => \"string\" === typeof elem);\r\n            return \"object\" === typeof input && null !== input && $io0(input);\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.default.TypedHeaders.guard;\r\n              const $ao0 = (input, _path, _exceptionable = true) =>\r\n                (\"x\" === input[\"x-category\"] ||\r\n                  \"y\" === input[\"x-category\"] ||\r\n                  \"z\" === input[\"x-category\"] ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + '[\"x-category\"]',\r\n                    expected: '(\"x\" | \"y\" | \"z\")',\r\n                    value: input[\"x-category\"],\r\n                  })) &&\r\n                (undefined === input[\"x-memo\"] ||\r\n                  \"string\" === typeof input[\"x-memo\"] ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + '[\"x-memo\"]',\r\n                    expected: \"(string | undefined)\",\r\n                    value: input[\"x-memo\"],\r\n                  })) &&\r\n                (undefined === input[\"x-name\"] ||\r\n                  \"string\" === typeof input[\"x-name\"] ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + '[\"x-name\"]',\r\n                    expected: \"(string | undefined)\",\r\n                    value: input[\"x-name\"],\r\n                  })) &&\r\n                (((Array.isArray(input[\"x-values\"]) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + '[\"x-values\"]',\r\n                    expected: \"Array<number>\",\r\n                    value: input[\"x-values\"],\r\n                  })) &&\r\n                  input[\"x-values\"].every(\r\n                    (elem, _index1) =>\r\n                      (\"number\" === typeof elem && Number.isFinite(elem)) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + '[\"x-values\"][' + _index1 + \"]\",\r\n                        expected: \"number\",\r\n                        value: elem,\r\n                      }),\r\n                  )) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + '[\"x-values\"]',\r\n                    expected: \"Array<number>\",\r\n                    value: input[\"x-values\"],\r\n                  })) &&\r\n                (((Array.isArray(input[\"x-flags\"]) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + '[\"x-flags\"]',\r\n                    expected: \"Array<boolean>\",\r\n                    value: input[\"x-flags\"],\r\n                  })) &&\r\n                  input[\"x-flags\"].every(\r\n                    (elem, _index2) =>\r\n                      \"boolean\" === typeof elem ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + '[\"x-flags\"][' + _index2 + \"]\",\r\n                        expected: \"boolean\",\r\n                        value: elem,\r\n                      }),\r\n                  )) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + '[\"x-flags\"]',\r\n                    expected: \"Array<boolean>\",\r\n                    value: input[\"x-flags\"],\r\n                  })) &&\r\n                (((Array.isArray(input[\"X-Descriptions\"]) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + '[\"X-Descriptions\"]',\r\n                    expected: \"Array<string>\",\r\n                    value: input[\"X-Descriptions\"],\r\n                  })) &&\r\n                  input[\"X-Descriptions\"].every(\r\n                    (elem, _index3) =>\r\n                      \"string\" === typeof elem ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + '[\"X-Descriptions\"][' + _index3 + \"]\",\r\n                        expected: \"string\",\r\n                        value: elem,\r\n                      }),\r\n                  )) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + '[\"X-Descriptions\"]',\r\n                    expected: \"Array<string>\",\r\n                    value: input[\"X-Descriptions\"],\r\n                  }));\r\n              return (\r\n                (((\"object\" === typeof input && null !== input) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IHeaders\",\r\n                    value: input,\r\n                  })) &&\r\n                  $ao0(input, _path + \"\", true)) ||\r\n                $guard(true, {\r\n                  path: _path + \"\",\r\n                  expected: \"IHeaders\",\r\n                  value: input,\r\n                })\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        })(output);\r\n      }),\r\n    ),\r\n    __param(1, core_1.default.TypedParam(\"section\", \"string\", false)),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object, String]),\r\n    __metadata(\"design:returntype\", void 0),\r\n  ],\r\n  HeadersController.prototype,\r\n  \"emplace\",\r\n  null,\r\n);\r\nexports.HeadersController = HeadersController = __decorate(\r\n  [(0, common_1.Controller)(\"headers/:section\")],\r\n  HeadersController,\r\n);\nJust call @TypedHeaders() function on the request headers parameter, that's all.Nestia will analyze your type (IHeaders), and write optimal conversion and validation code for the target type, in the compilation level. If you click the \"Compiled JavaScript File\" tab of above, you can see the optimal code.Also, as you can see from the \"Compiled JavaScript File\", when upper case alphabet is used in the header key name like IHeaders[\"X-Descriptions\"], @TypedHeaders() would automatically convert to the upper case alphabet key named property from lower case key named property of raw data.Such optimization is called AOT (Ahead of Time) compilation, and it is the secret of @TypedHeaders\nBesides, the original @Headers() decorator of NestJS does not support such automatic upper case conversion. When you've define upper-cased property name in DTO, undefined value always be assigned, even if you've sent upper-cased property in the client side.","special-tags#Special Tags":"You can enhance validation logic, of @TypedHeaders(), through comment tags.You know what? @TypedHeaders() utilizes typia.assert<T>() function for query data validation, and the typia.assert<T>() function supports additional type checking logics through comment tags. For reference, \"Type Tag\" means a intersection type with atomic type and special tag type of typia like number & tags.Type<\"uint32\">, and \"Comment Tag\" means a comment starting from @ symbol following @${name} ${value} format.With those type and comment tags, you can add additional validation logics. If you want to add a custom validation logic, you also can do it. Read below Guide Docments of typia, and see the example code. You may understand how to utilize such type and comment tags, in a few minutes.\ntypia > Validators > Custom Tags\nOutline\nType Tags\nComment Tags\nCustomization\nimport typia, { tags } from \"typia\";\r\n\r\nexport const checkSpecialTag = typia.createIs<SpecialTag>();\r\n\r\ninterface SpecialTag {\r\n  int32: number & tags.Type<\"int32\">;\r\n  range?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\r\n  minLength: string & tags.MinLength<3>;\r\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\r\n  date: null | (string & tags.Format<\"date\">);\r\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\r\n  uuids: Array<string & tags.Format<\"uuid\">> &\r\n    tags.MinItems<3> &\r\n    tags.MaxItems<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.checkSpecialTag = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst checkSpecialTag = (input) => {\r\n  const $io0 = (input) =>\r\n    \"number\" === typeof input.int32 &&\r\n    Math.floor(input.int32) === input.int32 &&\r\n    -2147483648 <= input.int32 &&\r\n    input.int32 <= 2147483647 &&\r\n    (undefined === input.range ||\r\n      (\"number\" === typeof input.range &&\r\n        19 < input.range &&\r\n        input.range <= 100)) &&\r\n    \"string\" === typeof input.minLength &&\r\n    3 <= input.minLength.length &&\r\n    \"string\" === typeof input.pattern &&\r\n    /^[a-z]+$/.test(input.pattern) &&\r\n    (null === input.date ||\r\n      (\"string\" === typeof input.date &&\r\n        /^(d{4})-(d{2})-(d{2})$/.test(input.date))) &&\r\n    \"string\" === typeof input.ip &&\r\n    (/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\r\n      input.ip,\r\n    ) ||\r\n      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(\r\n        input.ip,\r\n      )) &&\r\n    Array.isArray(input.uuids) &&\r\n    3 <= input.uuids.length &&\r\n    input.uuids.length <= 100 &&\r\n    input.uuids.every(\r\n      (elem) =>\r\n        \"string\" === typeof elem &&\r\n        /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n          elem,\r\n        ),\r\n    );\r\n  return \"object\" === typeof input && null !== input && $io0(input);\r\n};\r\nexports.checkSpecialTag = checkSpecialTag;","restriction#Restriction":"When using @TypedHeaders(), you've to follow such restrictions.At first, type of @TypedHeaders() must be a pure object type. It does not allow union type. Also, nullable types are not allowed, either. Note that, request headers type must be a sole object type without any extra definition. Of course, the word object does not contain array type.At next, type of properties must be atomic, or array of atomic type. In the atomic type case, the atomic type allows both nullable and undefindable types. However, mixed union atomic type like string | number or \"1\" | \"2\" | 3 are not allowed. Also, the array type does not allow both nullable and undefindable types, either.\nboolean\nnumber\nbigint\nstring\nAt last, HTTP headers has special restriction on value types for specific key names. For example, Set-Cookie must be Array type, and Authorization must be an atomic type like string. Therefore, @TypedHeaders() also restricts the value type of specific key names, and it is described in below.\nOnly array type allowed:\nset-cookie\nOnly atomic type allowed:\nage\nauthorization\ncontent-length\ncontent-type\netag\nexpires\nfrom\nhost\nif-modified-since\nif-unmodified-since\nlast-modified\nlocation\nmax-forwards\nproxy-authorization\nreferer\nretry-after\nserver\nuser-agent\nexport interface SomeHeadersDto {\r\n  //----\r\n  // ATOMIC TYPES\r\n  //----\r\n  // ALLOWED\r\n  boolean: boolean;\r\n  number: number;\r\n  string: string;\r\n  bigint: bigint;\r\n  optional_number?: number;\r\n  nullable_string: string | null;\r\n  literal_union: \"A\" | \"B\" | \"C\" | \"D\";\r\n\r\n  // NOT ALLOWED\r\n  mixed_union: string | number | boolean;\r\n  mixed_literal: \"A\" | \"B\" | 3;\r\n\r\n  //----\r\n  // ARRAY TYPES\r\n  //----\r\n  // ALLOWED\r\n  nullable_element_array: (string | null)[];\r\n  string_array: string[];\r\n  number_array: number[];\r\n  literal_union_array: (\"A\" | \"B\" | \"C\")[];\r\n  literal_tuple: [\"A\", \"B\", \"C\"];\r\n\r\n  // NOT ALLOWED\r\n  optional_element_array: (string | undefined)[];\r\n  optional_array: string[] | undefined;\r\n  nullable_array: string[] | null;\r\n  union_atomic_array: (string | number)[];\r\n  mixed_literal_array: (\"A\", \"B\", 3)[];\r\n  mixed_tuple: [\"A\", \"B\", 3];\r\n\r\n  //----\r\n  // SPECIAL CASES\r\n  //----\r\n  // MUST BE ARRAY\r\n  \"Set-Cookie\": string[];\r\n\r\n  // MUST BE ATOMIC\r\n  Accept: string;\r\n  Authorization: string;\r\n\r\n  // NOT ALLOWED - MUST BE ATOMIC\r\n  referer: string[];\r\n  age: number[];\r\n}"}},"/docs/core/TypedQuery":{"title":"Guide Documents > Core Library > TypedQuery","data":{"outline#Outline":"export function TypedQuery(): ParameterDecorator;\r\nexport namespace TypedQuery {\r\n  export function Body(): ParameterDecorator;\r\n  export function Get(path?: string): MethodDecorator;\r\n  export function Post(path?: string): MethodDecorator;\r\n  export function Put(path?: string): MethodDecorator;\r\n  export function Patch(path?: string): MethodDecorator;\r\n  export function Delete(path?: string): MethodDecorator;\r\n}\nDecorators for query parameters.\nWhat the query parameters are?This is the query parameters!\nname=Samchon&age=20&sex=male\n@TypedQuery() is not essential for Swagger Documents or SDK Library building.Therefore, it is not a matter to use @TypedQuery() or @Query() of the original NestJS.","typedquery#@TypedQuery()":"export function TypedQuery(): ParameterDecorator;\nType safe URL query decorator.@TypedQuery() is a decorator parsing URL query.It's almost same with original @Query() function of NestJS, but @TypedQuery() is more stable and general.While NestJS does not support query type validation, @TypedQuery() validates the request query type and throws 400 bad request error when mismatched. Also, while NestJS does not support property type (@Query() only supports string typed properties), @TypedQuery() can define variable property types like bigint, number or boolean.\nimport { tags } from \"typia\";\r\n\r\nexport namespace IBbsArticle {\r\n  export interface ISummary {\r\n    id: string & tags.Format<\"uuid\">;\r\n    writer: string;\r\n    title: string & tags.MinLength<3> & tags.MaxLength<50>;\r\n    created_at: string & tags.Format<\"date-time\">;\r\n  }\r\n}\nimport { tags } from \"typia\";\r\n\r\nexport interface IPage<T> {\r\n  data: T[];\r\n  pagination: IPage.IPagination;\r\n}\r\nexport namespace IPage {\r\n  /**\r\n   * Page request data\r\n   */\r\n  export interface IRequest {\r\n    page?: number & tags.Type<\"uint32\">;\r\n    limit?: number & tags.Type<\"uint32\">;\r\n  }\r\n  /**\r\n   * Page information.\r\n   */\r\n  export interface IPagination {\r\n    current: number & tags.Type<\"uint32\">;\r\n    limit: number & tags.Type<\"uint32\">;\r\n    records: number & tags.Type<\"uint32\">;\r\n    pages: number & tags.Type<\"uint32\">;\r\n  }\r\n}\nimport { TypedQuery, TypedRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport { tags } from \"typia\";\r\n\r\nimport { IBbsArticle } from \"./IBbsArticle\";\r\nimport { IPage } from \"./IPage\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  @TypedRoute.Get()\r\n  public async index(\r\n    @TypedQuery() query: IPage.IRequest\r\n  ): Promise<IPage<IBbsArticle.ISummary>> {\r\n    return {\r\n      pagination: {\r\n        current: query.page ?? 1,\r\n        limit: query.limit ?? 100,\r\n        records: 0,\r\n        pages: 0,\r\n      },\r\n      data: [],\r\n    };\r\n  }\r\n}\n\"use strict\";\r\nvar __decorate =\r\n  (this && this.__decorate) ||\r\n  function (decorators, target, key, desc) {\r\n    var c = arguments.length,\r\n      r =\r\n        c < 3\r\n          ? target\r\n          : desc === null\r\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\r\n          : desc,\r\n      d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\r\n      r = Reflect.decorate(decorators, target, key, desc);\r\n    else\r\n      for (var i = decorators.length - 1; i >= 0; i--)\r\n        if ((d = decorators[i]))\r\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n  };\r\nvar __metadata =\r\n  (this && this.__metadata) ||\r\n  function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\r\n      return Reflect.metadata(k, v);\r\n  };\r\nvar __param =\r\n  (this && this.__param) ||\r\n  function (paramIndex, decorator) {\r\n    return function (target, key) {\r\n      decorator(target, key, paramIndex);\r\n    };\r\n  };\r\nvar __awaiter =\r\n  (this && this.__awaiter) ||\r\n  function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) {\r\n      return value instanceof P\r\n        ? value\r\n        : new P(function (resolve) {\r\n            resolve(value);\r\n          });\r\n    }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n      function fulfilled(value) {\r\n        try {\r\n          step(generator.next(value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function rejected(value) {\r\n        try {\r\n          step(generator[\"throw\"](value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function step(result) {\r\n        result.done\r\n          ? resolve(result.value)\r\n          : adopt(result.value).then(fulfilled, rejected);\r\n      }\r\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BbsArticlesController = void 0;\r\nconst core_1 = require(\"@nestia/core\");\r\nconst common_1 = require(\"@nestjs/common\");\r\nlet BbsArticlesController = class BbsArticlesController {\r\n  index(query) {\r\n    var _a, _b;\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return {\r\n        pagination: {\r\n          current: (_a = query.page) !== null && _a !== void 0 ? _a : 1,\r\n          limit: (_b = query.limit) !== null && _b !== void 0 ? _b : 100,\r\n          records: 0,\r\n          pages: 0,\r\n        },\r\n        data: [],\r\n      };\r\n    });\r\n  }\r\n};\r\nexports.BbsArticlesController = BbsArticlesController;\r\n__decorate(\r\n  [\r\n    core_1.TypedRoute.Get({\r\n      type: \"assert\",\r\n      assert: (input) => {\r\n        const assert = (input) => {\r\n          const __is = (input) => {\r\n            const $io0 = (input) =>\r\n              Array.isArray(input.data) &&\r\n              input.data.every(\r\n                (elem) =>\r\n                  \"object\" === typeof elem && null !== elem && $io1(elem),\r\n              ) &&\r\n              \"object\" === typeof input.pagination &&\r\n              null !== input.pagination &&\r\n              \"number\" === typeof input.pagination.current &&\r\n              Math.floor(input.pagination.current) ===\r\n                input.pagination.current &&\r\n              0 <= input.pagination.current &&\r\n              input.pagination.current <= 4294967295 &&\r\n              \"number\" === typeof input.pagination.limit &&\r\n              Math.floor(input.pagination.limit) === input.pagination.limit &&\r\n              0 <= input.pagination.limit &&\r\n              input.pagination.limit <= 4294967295 &&\r\n              \"number\" === typeof input.pagination.records &&\r\n              Math.floor(input.pagination.records) ===\r\n                input.pagination.records &&\r\n              0 <= input.pagination.records &&\r\n              input.pagination.records <= 4294967295 &&\r\n              \"number\" === typeof input.pagination.pages &&\r\n              Math.floor(input.pagination.pages) === input.pagination.pages &&\r\n              0 <= input.pagination.pages &&\r\n              input.pagination.pages <= 4294967295;\r\n            const $io1 = (input) =>\r\n              \"string\" === typeof input.id &&\r\n              /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n                input.id,\r\n              ) &&\r\n              \"string\" === typeof input.writer &&\r\n              \"string\" === typeof input.title &&\r\n              3 <= input.title.length &&\r\n              input.title.length <= 50 &&\r\n              \"string\" === typeof input.created_at &&\r\n              !isNaN(new Date(input.created_at).getTime());\r\n            return \"object\" === typeof input && null !== input && $io0(input);\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.TypedRoute.Get.guard;\r\n              const $ao0 = (input, _path, _exceptionable = true) =>\r\n                (((Array.isArray(input.data) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".data\",\r\n                    expected: \"Array<IBbsArticle.ISummary>\",\r\n                    value: input.data,\r\n                  })) &&\r\n                  input.data.every(\r\n                    (elem, _index1) =>\r\n                      (((\"object\" === typeof elem && null !== elem) ||\r\n                        $guard(_exceptionable, {\r\n                          path: _path + \".data[\" + _index1 + \"]\",\r\n                          expected: \"IBbsArticle.ISummary\",\r\n                          value: elem,\r\n                        })) &&\r\n                        $ao1(\r\n                          elem,\r\n                          _path + \".data[\" + _index1 + \"]\",\r\n                          true && _exceptionable,\r\n                        )) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".data[\" + _index1 + \"]\",\r\n                        expected: \"IBbsArticle.ISummary\",\r\n                        value: elem,\r\n                      }),\r\n                  )) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".data\",\r\n                    expected: \"Array<IBbsArticle.ISummary>\",\r\n                    value: input.data,\r\n                  })) &&\r\n                ((((\"object\" === typeof input.pagination &&\r\n                  null !== input.pagination) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".pagination\",\r\n                    expected: \"IPage.IPagination\",\r\n                    value: input.pagination,\r\n                  })) &&\r\n                  $ao2(\r\n                    input.pagination,\r\n                    _path + \".pagination\",\r\n                    true && _exceptionable,\r\n                  )) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".pagination\",\r\n                    expected: \"IPage.IPagination\",\r\n                    value: input.pagination,\r\n                  }));\r\n              const $ao1 = (input, _path, _exceptionable = true) =>\r\n                ((\"string\" === typeof input.id &&\r\n                  (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n                    input.id,\r\n                  ) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".id\",\r\n                      expected: 'string & Format<\"uuid\">',\r\n                      value: input.id,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".id\",\r\n                    expected: '(string & Format<\"uuid\">)',\r\n                    value: input.id,\r\n                  })) &&\r\n                (\"string\" === typeof input.writer ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".writer\",\r\n                    expected: \"string\",\r\n                    value: input.writer,\r\n                  })) &&\r\n                ((\"string\" === typeof input.title &&\r\n                  (3 <= input.title.length ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MinLength<3>\",\r\n                      value: input.title,\r\n                    })) &&\r\n                  (input.title.length <= 50 ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MaxLength<50>\",\r\n                      value: input.title,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".title\",\r\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\r\n                    value: input.title,\r\n                  })) &&\r\n                ((\"string\" === typeof input.created_at &&\r\n                  (!isNaN(new Date(input.created_at).getTime()) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".created_at\",\r\n                      expected: 'string & Format<\"date-time\">',\r\n                      value: input.created_at,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".created_at\",\r\n                    expected: '(string & Format<\"date-time\">)',\r\n                    value: input.created_at,\r\n                  }));\r\n              const $ao2 = (input, _path, _exceptionable = true) =>\r\n                ((\"number\" === typeof input.current &&\r\n                  ((Math.floor(input.current) === input.current &&\r\n                    0 <= input.current &&\r\n                    input.current <= 4294967295) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".current\",\r\n                      expected: 'number & Type<\"uint32\">',\r\n                      value: input.current,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".current\",\r\n                    expected: '(number & Type<\"uint32\">)',\r\n                    value: input.current,\r\n                  })) &&\r\n                ((\"number\" === typeof input.limit &&\r\n                  ((Math.floor(input.limit) === input.limit &&\r\n                    0 <= input.limit &&\r\n                    input.limit <= 4294967295) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".limit\",\r\n                      expected: 'number & Type<\"uint32\">',\r\n                      value: input.limit,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".limit\",\r\n                    expected: '(number & Type<\"uint32\">)',\r\n                    value: input.limit,\r\n                  })) &&\r\n                ((\"number\" === typeof input.records &&\r\n                  ((Math.floor(input.records) === input.records &&\r\n                    0 <= input.records &&\r\n                    input.records <= 4294967295) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".records\",\r\n                      expected: 'number & Type<\"uint32\">',\r\n                      value: input.records,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".records\",\r\n                    expected: '(number & Type<\"uint32\">)',\r\n                    value: input.records,\r\n                  })) &&\r\n                ((\"number\" === typeof input.pages &&\r\n                  ((Math.floor(input.pages) === input.pages &&\r\n                    0 <= input.pages &&\r\n                    input.pages <= 4294967295) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".pages\",\r\n                      expected: 'number & Type<\"uint32\">',\r\n                      value: input.pages,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".pages\",\r\n                    expected: '(number & Type<\"uint32\">)',\r\n                    value: input.pages,\r\n                  }));\r\n              return (\r\n                (((\"object\" === typeof input && null !== input) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IPage<IBbsArticle.ISummary>\",\r\n                    value: input,\r\n                  })) &&\r\n                  $ao0(input, _path + \"\", true)) ||\r\n                $guard(true, {\r\n                  path: _path + \"\",\r\n                  expected: \"IPage<IBbsArticle.ISummary>\",\r\n                  value: input,\r\n                })\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        };\r\n        const stringify = (input) => {\r\n          const $io1 = (input) =>\r\n            \"string\" === typeof input.id &&\r\n            /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n              input.id,\r\n            ) &&\r\n            \"string\" === typeof input.writer &&\r\n            \"string\" === typeof input.title &&\r\n            3 <= input.title.length &&\r\n            input.title.length <= 50 &&\r\n            \"string\" === typeof input.created_at &&\r\n            !isNaN(new Date(input.created_at).getTime());\r\n          const $io2 = (input) =>\r\n            \"number\" === typeof input.current &&\r\n            Math.floor(input.current) === input.current &&\r\n            0 <= input.current &&\r\n            input.current <= 4294967295 &&\r\n            \"number\" === typeof input.limit &&\r\n            Math.floor(input.limit) === input.limit &&\r\n            0 <= input.limit &&\r\n            input.limit <= 4294967295 &&\r\n            \"number\" === typeof input.records &&\r\n            Math.floor(input.records) === input.records &&\r\n            0 <= input.records &&\r\n            input.records <= 4294967295 &&\r\n            \"number\" === typeof input.pages &&\r\n            Math.floor(input.pages) === input.pages &&\r\n            0 <= input.pages &&\r\n            input.pages <= 4294967295;\r\n          const $string = core_1.TypedRoute.Get.string;\r\n          const $so0 = (input) =>\r\n            `{\"data\":${`[${input.data\r\n              .map(\r\n                (elem) =>\r\n                  `{\"id\":${$string(elem.id)},\"writer\":${$string(\r\n                    elem.writer,\r\n                  )},\"title\":${$string(elem.title)},\"created_at\":${$string(\r\n                    elem.created_at,\r\n                  )}}`,\r\n              )\r\n              .join(\r\n                \",\",\r\n              )}]`},\"pagination\":${`{\"current\":${input.pagination.current},\"limit\":${input.pagination.limit},\"records\":${input.pagination.records},\"pages\":${input.pagination.pages}}`}}`;\r\n          return $so0(input);\r\n        };\r\n        return stringify(assert(input));\r\n      },\r\n    }),\r\n    __param(\r\n      0,\r\n      (0, core_1.TypedQuery)((input) => {\r\n        var _a, _b;\r\n        const $number = core_1.TypedQuery.number;\r\n        const output = {\r\n          page:\r\n            (_a = $number(input.get(\"page\"))) !== null && _a !== void 0\r\n              ? _a\r\n              : undefined,\r\n          limit:\r\n            (_b = $number(input.get(\"limit\"))) !== null && _b !== void 0\r\n              ? _b\r\n              : undefined,\r\n        };\r\n        return ((input) => {\r\n          const __is = (input) => {\r\n            const $io0 = (input) =>\r\n              (undefined === input.page ||\r\n                (\"number\" === typeof input.page &&\r\n                  Math.floor(input.page) === input.page &&\r\n                  0 <= input.page &&\r\n                  input.page <= 4294967295)) &&\r\n              (undefined === input.limit ||\r\n                (\"number\" === typeof input.limit &&\r\n                  Math.floor(input.limit) === input.limit &&\r\n                  0 <= input.limit &&\r\n                  input.limit <= 4294967295));\r\n            return (\r\n              \"object\" === typeof input &&\r\n              null !== input &&\r\n              false === Array.isArray(input) &&\r\n              $io0(input)\r\n            );\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.TypedQuery.guard;\r\n              const $ao0 = (input, _path, _exceptionable = true) =>\r\n                (undefined === input.page ||\r\n                  (\"number\" === typeof input.page &&\r\n                    ((Math.floor(input.page) === input.page &&\r\n                      0 <= input.page &&\r\n                      input.page <= 4294967295) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".page\",\r\n                        expected: 'number & Type<\"uint32\">',\r\n                        value: input.page,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".page\",\r\n                    expected: '((number & Type<\"uint32\">) | undefined)',\r\n                    value: input.page,\r\n                  })) &&\r\n                (undefined === input.limit ||\r\n                  (\"number\" === typeof input.limit &&\r\n                    ((Math.floor(input.limit) === input.limit &&\r\n                      0 <= input.limit &&\r\n                      input.limit <= 4294967295) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".limit\",\r\n                        expected: 'number & Type<\"uint32\">',\r\n                        value: input.limit,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".limit\",\r\n                    expected: '((number & Type<\"uint32\">) | undefined)',\r\n                    value: input.limit,\r\n                  }));\r\n              return (\r\n                (((\"object\" === typeof input &&\r\n                  null !== input &&\r\n                  false === Array.isArray(input)) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IPage.IRequest\",\r\n                    value: input,\r\n                  })) &&\r\n                  $ao0(input, _path + \"\", true)) ||\r\n                $guard(true, {\r\n                  path: _path + \"\",\r\n                  expected: \"IPage.IRequest\",\r\n                  value: input,\r\n                })\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        })(output);\r\n      }),\r\n    ),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object]),\r\n    __metadata(\"design:returntype\", Promise),\r\n  ],\r\n  BbsArticlesController.prototype,\r\n  \"index\",\r\n  null,\r\n);\r\nexports.BbsArticlesController = BbsArticlesController = __decorate(\r\n  [(0, common_1.Controller)(\"bbs/articles\")],\r\n  BbsArticlesController,\r\n);\nJust call @TypedQuery() function on the query parameter, that's all.Nestia will analyze your type (IPage.IRequest), and writes optimal code for the target type, in the compilation level. If you click the \"Compiled JavaScript\" file tab of above and fine enhanced lines by blue lines, you can see the optimal parsing and validation code.Such optimization is called AOT (Ahead of Time) compilation, and it is the secret of @TypedQuery.","typedquerybody#TypedQuery.Body()":"export namespace TypedQuery {\r\n  export function Body(): ParameterDecorator;\r\n}\nRequest body decorator of application/x-www-form-urlencoded format.If you call @TypedQuery.Body() decorator function on a specific parameter, the parameter will be parsed from the request body as application/x-www-form-urlencoded format. Otherwise, you want to declare a application/json format response body, use @TypedBody() decorator function instead.\nimport { tags } from \"typia\";\r\n\r\nexport interface IBbsArticle {\r\n  id: string;\r\n  writer: string;\r\n  title: string & tags.MinLength<3> & tags.MaxLength<50>;\r\n  body: string;\r\n  created_at: string & tags.Format<\"date-time\">;\r\n}\r\nexport namespace IBbsArticle {\r\n  export interface IStore {\r\n    title: string & tags.MinLength<3> & tags.MaxLength<50>;\r\n    body: string;\r\n  }\r\n}\nimport { TypedQuery } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\n\r\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  @TypedQuery.Post()\r\n  public async store(\r\n    @TypedQuery.Body() body: IBbsArticle.IStore,\r\n  ): Promise<IBbsArticle> {\r\n    return {\r\n      id: \"00000000-0000-0000-0000-000000000000\",\r\n      writer: \"Samchon\",\r\n      title: body.title,\r\n      body: body.body,\r\n      created_at: new Date().toISOString(),\r\n    };\r\n  }\r\n}\n\"use strict\";\r\nvar __decorate =\r\n  (this && this.__decorate) ||\r\n  function (decorators, target, key, desc) {\r\n    var c = arguments.length,\r\n      r =\r\n        c < 3\r\n          ? target\r\n          : desc === null\r\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\r\n          : desc,\r\n      d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\r\n      r = Reflect.decorate(decorators, target, key, desc);\r\n    else\r\n      for (var i = decorators.length - 1; i >= 0; i--)\r\n        if ((d = decorators[i]))\r\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n  };\r\nvar __metadata =\r\n  (this && this.__metadata) ||\r\n  function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\r\n      return Reflect.metadata(k, v);\r\n  };\r\nvar __param =\r\n  (this && this.__param) ||\r\n  function (paramIndex, decorator) {\r\n    return function (target, key) {\r\n      decorator(target, key, paramIndex);\r\n    };\r\n  };\r\nvar __awaiter =\r\n  (this && this.__awaiter) ||\r\n  function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) {\r\n      return value instanceof P\r\n        ? value\r\n        : new P(function (resolve) {\r\n            resolve(value);\r\n          });\r\n    }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n      function fulfilled(value) {\r\n        try {\r\n          step(generator.next(value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function rejected(value) {\r\n        try {\r\n          step(generator[\"throw\"](value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function step(result) {\r\n        result.done\r\n          ? resolve(result.value)\r\n          : adopt(result.value).then(fulfilled, rejected);\r\n      }\r\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BbsArticlesController = void 0;\r\nconst core_1 = require(\"@nestia/core\");\r\nconst common_1 = require(\"@nestjs/common\");\r\nlet BbsArticlesController = class BbsArticlesController {\r\n  store(body) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return {\r\n        id: \"00000000-0000-0000-0000-000000000000\",\r\n        writer: \"Samchon\",\r\n        title: body.title,\r\n        body: body.body,\r\n        created_at: new Date().toISOString(),\r\n      };\r\n    });\r\n  }\r\n};\r\nexports.BbsArticlesController = BbsArticlesController;\r\n__decorate(\r\n  [\r\n    core_1.TypedQuery.Post({\r\n      type: \"assert\",\r\n      assert: (input) => {\r\n        const assert = (input) => {\r\n          const __is = (input) => {\r\n            return (\r\n              \"object\" === typeof input &&\r\n              null !== input &&\r\n              \"string\" === typeof input.id &&\r\n              \"string\" === typeof input.writer &&\r\n              \"string\" === typeof input.title &&\r\n              3 <= input.title.length &&\r\n              input.title.length <= 50 &&\r\n              \"string\" === typeof input.body &&\r\n              \"string\" === typeof input.created_at &&\r\n              !isNaN(new Date(input.created_at).getTime())\r\n            );\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.TypedQuery.Post.guard;\r\n              const $ao0 = (input, _path, _exceptionable = true) =>\r\n                (\"string\" === typeof input.id ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".id\",\r\n                    expected: \"string\",\r\n                    value: input.id,\r\n                  })) &&\r\n                (\"string\" === typeof input.writer ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".writer\",\r\n                    expected: \"string\",\r\n                    value: input.writer,\r\n                  })) &&\r\n                ((\"string\" === typeof input.title &&\r\n                  (3 <= input.title.length ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MinLength<3>\",\r\n                      value: input.title,\r\n                    })) &&\r\n                  (input.title.length <= 50 ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MaxLength<50>\",\r\n                      value: input.title,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".title\",\r\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\r\n                    value: input.title,\r\n                  })) &&\r\n                (\"string\" === typeof input.body ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".body\",\r\n                    expected: \"string\",\r\n                    value: input.body,\r\n                  })) &&\r\n                ((\"string\" === typeof input.created_at &&\r\n                  (!isNaN(new Date(input.created_at).getTime()) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".created_at\",\r\n                      expected: 'string & Format<\"date-time\">',\r\n                      value: input.created_at,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".created_at\",\r\n                    expected: '(string & Format<\"date-time\">)',\r\n                    value: input.created_at,\r\n                  }));\r\n              return (\r\n                (((\"object\" === typeof input && null !== input) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IBbsArticle\",\r\n                    value: input,\r\n                  })) &&\r\n                  $ao0(input, _path + \"\", true)) ||\r\n                $guard(true, {\r\n                  path: _path + \"\",\r\n                  expected: \"IBbsArticle\",\r\n                  value: input,\r\n                })\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        };\r\n        const stringify = (input) => {\r\n          const output = new URLSearchParams();\r\n          output.append(\"id\", input.id);\r\n          output.append(\"writer\", input.writer);\r\n          output.append(\"title\", input.title);\r\n          output.append(\"body\", input.body);\r\n          output.append(\"created_at\", input.created_at);\r\n          return output;\r\n        };\r\n        return stringify(assert(input));\r\n      },\r\n    }),\r\n    __param(\r\n      0,\r\n      core_1.TypedQuery.Body({\r\n        type: \"assert\",\r\n        assert: (input) => {\r\n          const decode = (input) => {\r\n            const $params = core_1.TypedQuery.Body.params;\r\n            const $string = core_1.TypedQuery.Body.string;\r\n            input = $params(input);\r\n            const output = {\r\n              title: $string(input.get(\"title\")),\r\n              body: $string(input.get(\"body\")),\r\n            };\r\n            return output;\r\n          };\r\n          const assert = (input) => {\r\n            const __is = (input) => {\r\n              return (\r\n                \"object\" === typeof input &&\r\n                null !== input &&\r\n                \"string\" === typeof input.title &&\r\n                3 <= input.title.length &&\r\n                input.title.length <= 50 &&\r\n                \"string\" === typeof input.body\r\n              );\r\n            };\r\n            if (false === __is(input))\r\n              ((input, _path, _exceptionable = true) => {\r\n                const $guard = core_1.TypedQuery.Body.guard;\r\n                const $ao0 = (input, _path, _exceptionable = true) =>\r\n                  ((\"string\" === typeof input.title &&\r\n                    (3 <= input.title.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".title\",\r\n                        expected: \"string & MinLength<3>\",\r\n                        value: input.title,\r\n                      })) &&\r\n                    (input.title.length <= 50 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".title\",\r\n                        expected: \"string & MaxLength<50>\",\r\n                        value: input.title,\r\n                      }))) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"(string & MinLength<3> & MaxLength<50>)\",\r\n                      value: input.title,\r\n                    })) &&\r\n                  (\"string\" === typeof input.body ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".body\",\r\n                      expected: \"string\",\r\n                      value: input.body,\r\n                    }));\r\n                return (\r\n                  (((\"object\" === typeof input && null !== input) ||\r\n                    $guard(true, {\r\n                      path: _path + \"\",\r\n                      expected: \"IBbsArticle.IStore\",\r\n                      value: input,\r\n                    })) &&\r\n                    $ao0(input, _path + \"\", true)) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IBbsArticle.IStore\",\r\n                    value: input,\r\n                  })\r\n                );\r\n              })(input, \"$input\", true);\r\n            return input;\r\n          };\r\n          const output = decode(input);\r\n          return assert(output);\r\n        },\r\n      }),\r\n    ),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object]),\r\n    __metadata(\"design:returntype\", Promise),\r\n  ],\r\n  BbsArticlesController.prototype,\r\n  \"store\",\r\n  null,\r\n);\r\nexports.BbsArticlesController = BbsArticlesController = __decorate(\r\n  [(0, common_1.Controller)(\"bbs/articles\")],\r\n  BbsArticlesController,\r\n);","typedquerypost#TypedQuery.Post()":"export namespace TypedQuery {\r\n  export function Get(path?: string): MethodDecorator;\r\n  export function Post(path?: string): MethodDecorator;\r\n  export function Put(path?: string): MethodDecorator;\r\n  export function Patch(path?: string): MethodDecorator;\r\n  export function Delete(path?: string): MethodDecorator;\r\n}\nRoute decorators of application/x-www-form-urlencoded format response body.If you call one of below decorator functions on a method, the method will return application/x-www-form-urlencoded format response body. Otherwise, you want to declare a application/json format response body, use @TypedRoute.Post() decorator function instead.\n@TypedQuery.Get()\n@TypedQuery.Post()\n@TypedQuery.Put()\n@TypedQuery.Patch()\n@TypedQuery.Delete()\nimport { tags } from \"typia\";\r\n\r\nexport interface IBbsArticle {\r\n  id: string;\r\n  writer: string;\r\n  title: string & tags.MinLength<3> & tags.MaxLength<50>;\r\n  body: string;\r\n  created_at: string & tags.Format<\"date-time\">;\r\n}\r\nexport namespace IBbsArticle {\r\n  export interface IStore {\r\n    title: string & tags.MinLength<3> & tags.MaxLength<50>;\r\n    body: string;\r\n  }\r\n}\nimport { TypedQuery } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\n\r\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  @TypedQuery.Post()\r\n  public async store(\r\n    @TypedQuery.Body() body: IBbsArticle.IStore,\r\n  ): Promise<IBbsArticle> {\r\n    return {\r\n      id: \"00000000-0000-0000-0000-000000000000\",\r\n      writer: \"Samchon\",\r\n      title: body.title,\r\n      body: body.body,\r\n      created_at: new Date().toISOString(),\r\n    };\r\n  }\r\n}\n\"use strict\";\r\nvar __decorate =\r\n  (this && this.__decorate) ||\r\n  function (decorators, target, key, desc) {\r\n    var c = arguments.length,\r\n      r =\r\n        c < 3\r\n          ? target\r\n          : desc === null\r\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\r\n          : desc,\r\n      d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\r\n      r = Reflect.decorate(decorators, target, key, desc);\r\n    else\r\n      for (var i = decorators.length - 1; i >= 0; i--)\r\n        if ((d = decorators[i]))\r\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n  };\r\nvar __metadata =\r\n  (this && this.__metadata) ||\r\n  function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\r\n      return Reflect.metadata(k, v);\r\n  };\r\nvar __param =\r\n  (this && this.__param) ||\r\n  function (paramIndex, decorator) {\r\n    return function (target, key) {\r\n      decorator(target, key, paramIndex);\r\n    };\r\n  };\r\nvar __awaiter =\r\n  (this && this.__awaiter) ||\r\n  function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) {\r\n      return value instanceof P\r\n        ? value\r\n        : new P(function (resolve) {\r\n            resolve(value);\r\n          });\r\n    }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n      function fulfilled(value) {\r\n        try {\r\n          step(generator.next(value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function rejected(value) {\r\n        try {\r\n          step(generator[\"throw\"](value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function step(result) {\r\n        result.done\r\n          ? resolve(result.value)\r\n          : adopt(result.value).then(fulfilled, rejected);\r\n      }\r\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BbsArticlesController = void 0;\r\nconst core_1 = require(\"@nestia/core\");\r\nconst common_1 = require(\"@nestjs/common\");\r\nlet BbsArticlesController = class BbsArticlesController {\r\n  store(body) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return {\r\n        id: \"00000000-0000-0000-0000-000000000000\",\r\n        writer: \"Samchon\",\r\n        title: body.title,\r\n        body: body.body,\r\n        created_at: new Date().toISOString(),\r\n      };\r\n    });\r\n  }\r\n};\r\nexports.BbsArticlesController = BbsArticlesController;\r\n__decorate(\r\n  [\r\n    core_1.TypedQuery.Post({\r\n      type: \"assert\",\r\n      assert: (input) => {\r\n        const assert = (input) => {\r\n          const __is = (input) => {\r\n            return (\r\n              \"object\" === typeof input &&\r\n              null !== input &&\r\n              \"string\" === typeof input.id &&\r\n              \"string\" === typeof input.writer &&\r\n              \"string\" === typeof input.title &&\r\n              3 <= input.title.length &&\r\n              input.title.length <= 50 &&\r\n              \"string\" === typeof input.body &&\r\n              \"string\" === typeof input.created_at &&\r\n              !isNaN(new Date(input.created_at).getTime())\r\n            );\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.TypedQuery.Post.guard;\r\n              const $ao0 = (input, _path, _exceptionable = true) =>\r\n                (\"string\" === typeof input.id ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".id\",\r\n                    expected: \"string\",\r\n                    value: input.id,\r\n                  })) &&\r\n                (\"string\" === typeof input.writer ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".writer\",\r\n                    expected: \"string\",\r\n                    value: input.writer,\r\n                  })) &&\r\n                ((\"string\" === typeof input.title &&\r\n                  (3 <= input.title.length ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MinLength<3>\",\r\n                      value: input.title,\r\n                    })) &&\r\n                  (input.title.length <= 50 ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MaxLength<50>\",\r\n                      value: input.title,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".title\",\r\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\r\n                    value: input.title,\r\n                  })) &&\r\n                (\"string\" === typeof input.body ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".body\",\r\n                    expected: \"string\",\r\n                    value: input.body,\r\n                  })) &&\r\n                ((\"string\" === typeof input.created_at &&\r\n                  (!isNaN(new Date(input.created_at).getTime()) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".created_at\",\r\n                      expected: 'string & Format<\"date-time\">',\r\n                      value: input.created_at,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".created_at\",\r\n                    expected: '(string & Format<\"date-time\">)',\r\n                    value: input.created_at,\r\n                  }));\r\n              return (\r\n                (((\"object\" === typeof input && null !== input) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IBbsArticle\",\r\n                    value: input,\r\n                  })) &&\r\n                  $ao0(input, _path + \"\", true)) ||\r\n                $guard(true, {\r\n                  path: _path + \"\",\r\n                  expected: \"IBbsArticle\",\r\n                  value: input,\r\n                })\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        };\r\n        const stringify = (input) => {\r\n          const output = new URLSearchParams();\r\n          output.append(\"id\", input.id);\r\n          output.append(\"writer\", input.writer);\r\n          output.append(\"title\", input.title);\r\n          output.append(\"body\", input.body);\r\n          output.append(\"created_at\", input.created_at);\r\n          return output;\r\n        };\r\n        return stringify(assert(input));\r\n      },\r\n    }),\r\n    __param(\r\n      0,\r\n      core_1.TypedQuery.Body({\r\n        type: \"assert\",\r\n        assert: (input) => {\r\n          const decode = (input) => {\r\n            const $params = core_1.TypedQuery.Body.params;\r\n            const $string = core_1.TypedQuery.Body.string;\r\n            input = $params(input);\r\n            const output = {\r\n              title: $string(input.get(\"title\")),\r\n              body: $string(input.get(\"body\")),\r\n            };\r\n            return output;\r\n          };\r\n          const assert = (input) => {\r\n            const __is = (input) => {\r\n              return (\r\n                \"object\" === typeof input &&\r\n                null !== input &&\r\n                \"string\" === typeof input.title &&\r\n                3 <= input.title.length &&\r\n                input.title.length <= 50 &&\r\n                \"string\" === typeof input.body\r\n              );\r\n            };\r\n            if (false === __is(input))\r\n              ((input, _path, _exceptionable = true) => {\r\n                const $guard = core_1.TypedQuery.Body.guard;\r\n                const $ao0 = (input, _path, _exceptionable = true) =>\r\n                  ((\"string\" === typeof input.title &&\r\n                    (3 <= input.title.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".title\",\r\n                        expected: \"string & MinLength<3>\",\r\n                        value: input.title,\r\n                      })) &&\r\n                    (input.title.length <= 50 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".title\",\r\n                        expected: \"string & MaxLength<50>\",\r\n                        value: input.title,\r\n                      }))) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"(string & MinLength<3> & MaxLength<50>)\",\r\n                      value: input.title,\r\n                    })) &&\r\n                  (\"string\" === typeof input.body ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".body\",\r\n                      expected: \"string\",\r\n                      value: input.body,\r\n                    }));\r\n                return (\r\n                  (((\"object\" === typeof input && null !== input) ||\r\n                    $guard(true, {\r\n                      path: _path + \"\",\r\n                      expected: \"IBbsArticle.IStore\",\r\n                      value: input,\r\n                    })) &&\r\n                    $ao0(input, _path + \"\", true)) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IBbsArticle.IStore\",\r\n                    value: input,\r\n                  })\r\n                );\r\n              })(input, \"$input\", true);\r\n            return input;\r\n          };\r\n          const output = decode(input);\r\n          return assert(output);\r\n        },\r\n      }),\r\n    ),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object]),\r\n    __metadata(\"design:returntype\", Promise),\r\n  ],\r\n  BbsArticlesController.prototype,\r\n  \"store\",\r\n  null,\r\n);\r\nexports.BbsArticlesController = BbsArticlesController = __decorate(\r\n  [(0, common_1.Controller)(\"bbs/articles\")],\r\n  BbsArticlesController,\r\n);","special-tags#Special Tags":"You can enhance validation logic, of @TypedQuery(), through comment tags.You know what? @TypedQuery() utilizes typia.assert<T>() function for query data validation, and the typia.assert<T>() function supports additional type checking logics through comment tags. For reference, \"Type Tag\" means a intersection type with atomic type and special tag type of typia like number & tags.Type<\"uint32\">, and \"Comment Tag\" means a comment starting from @ symbol following @${name} ${value} format.With those type and comment tags, you can add additional validation logics. If you want to add a custom validation logic, you also can do it. Read below Guide Docments of typia, and see the example code. You may understand how to utilize such type and comment tags, in a few minutes.\ntypia > Validators > Custom Tags\nOutline\nType Tags\nComment Tags\nCustomization\nimport typia, { tags } from \"typia\";\r\n\r\nexport const checkSpecialTag = typia.createIs<SpecialTag>();\r\n\r\ninterface SpecialTag {\r\n  int32: number & tags.Type<\"int32\">;\r\n  range?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\r\n  minLength: string & tags.MinLength<3>;\r\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\r\n  date: null | (string & tags.Format<\"date\">);\r\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\r\n  uuids: Array<string & tags.Format<\"uuid\">> &\r\n    tags.MinItems<3> &\r\n    tags.MaxItems<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.checkSpecialTag = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst checkSpecialTag = (input) => {\r\n  const $io0 = (input) =>\r\n    \"number\" === typeof input.int32 &&\r\n    Math.floor(input.int32) === input.int32 &&\r\n    -2147483648 <= input.int32 &&\r\n    input.int32 <= 2147483647 &&\r\n    (undefined === input.range ||\r\n      (\"number\" === typeof input.range &&\r\n        19 < input.range &&\r\n        input.range <= 100)) &&\r\n    \"string\" === typeof input.minLength &&\r\n    3 <= input.minLength.length &&\r\n    \"string\" === typeof input.pattern &&\r\n    /^[a-z]+$/.test(input.pattern) &&\r\n    (null === input.date ||\r\n      (\"string\" === typeof input.date &&\r\n        /^(d{4})-(d{2})-(d{2})$/.test(input.date))) &&\r\n    \"string\" === typeof input.ip &&\r\n    (/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\r\n      input.ip,\r\n    ) ||\r\n      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(\r\n        input.ip,\r\n      )) &&\r\n    Array.isArray(input.uuids) &&\r\n    3 <= input.uuids.length &&\r\n    input.uuids.length <= 100 &&\r\n    input.uuids.every(\r\n      (elem) =>\r\n        \"string\" === typeof elem &&\r\n        /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n          elem,\r\n        ),\r\n    );\r\n  return \"object\" === typeof input && null !== input && $io0(input);\r\n};\r\nexports.checkSpecialTag = checkSpecialTag;","restriction#Restriction":"When using @TypedQuery(), you've to follow such restriction.At first, type of @TypedQuery() must be a pure object type. It does not allow union type. Also, nullable and undefindable types are not allowed, either. Note that, query parameter type must be a sole object type without any extra definition.At next, type of properties must be atomic, or array of atomic type. In the atomic type case, the atomic type allows both nullable and undefindable types. However, mixed union atomic type like string | number or \"1\" | \"2\" | 3 are not allowed. Also, the array type does not allow both nullable and undefindable types, either.\nboolean\nnumber\nbigint\nstring\nexport interface SomeQueryDto {\r\n  //----\r\n  // ATOMIC TYPES\r\n  //----\r\n  // ALLOWED\r\n  boolean: boolean;\r\n  number: number;\r\n  string: string;\r\n  bigint: bigint;\r\n  optional_number?: number;\r\n  nullable_string: string | null;\r\n  literal_union: \"A\" | \"B\" | \"C\" | \"D\";\r\n\r\n  // NOT ALLOWED\r\n  mixed_union: string | number | boolean;\r\n  mixed_literal: \"A\" | \"B\" | 3;\r\n\r\n  //----\r\n  // ARRAY TYPES\r\n  //----\r\n  // ALLOWED\r\n  nullable_element_array: (string | null)[];\r\n  string_array: string[];\r\n  number_array: number[];\r\n  literal_union_array: (\"A\" | \"B\" | \"C\")[];\r\n  literal_tuple: [\"A\", \"B\", \"C\"];\r\n\r\n  // NOT ALLOWED\r\n  optional_element_array: (string | undefined)[];\r\n  optional_array: string[] | undefined;\r\n  nullable_array: string[] | null;\r\n  union_atomic_array: (string | number)[];\r\n  mixed_literal_array: (\"A\", \"B\", 3)[];\r\n  mixed_tuple: [\"A\", \"B\", 3];\r\n}"}},"/docs/core/WebSocketRoute":{"title":"Guide Documents > Core Library > WebSocketRoute","data":{"outline#Outline":"export function WebSocketRoute(path?: string): MethodDecorator;\r\nexport namespace WebSocketRoute {\r\n  export function Acceptor(): ParameterDecorator;\r\n  export function Driver(): ParameterDecorator;\r\n  export function Header(): ParameterDecorator;\r\n  export function Param(field: string): ParameterDecorator;\r\n  export function Query(): ParameterDecorator;\r\n}\nimport { WebSocketRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport { Driver, WebSocketAcceptor } from \"tgrid\";\r\n\r\nimport { ICalculator } from \"./api/structures/ICalculator\";\r\nimport { IListener } from \"./api/structures/IListener\";\r\nimport { Calculator } from \"./providers/Calculator\";\r\n\r\n@Controller(\"calculate\")\r\nexport class CalculateController {\r\n  /**\r\n   * Start simple calculator.\r\n   *\r\n   * Start simple calculator through WebSocket.\r\n   */\r\n  @WebSocketRoute(\"start\")\r\n  public async start(\r\n    @WebSocketRoute.Acceptor()\r\n    acceptor: WebSocketAcceptor<any, ICalculator, IListener>,\r\n    @WebSocketRoute.Driver() driver: Driver<IListener>,\r\n  ): Promise<void> {\r\n    await acceptor.accept(new Calculator(driver));\r\n  }\r\n}\nimport { TestValidator } from \"@nestia/e2e\";\r\nimport api from \"@samchon/calculator-api/lib/index\";\r\nimport { IListener } from \"@samchon/calculator-api/lib/structures/IListener\";\r\n\r\nexport const test_api_calculate_start = async (\r\n  connection: api.IConnection,\r\n): Promise<void> => {\r\n  const stack: IListener.IEvent[] = [];\r\n  const listener: IListener = {\r\n    on: (event) => stack.push(event),\r\n  };\r\n  const { connector, driver } = await api.functional.calculate.start(\r\n    connection,\r\n    listener,\r\n  );\r\n  try {\r\n    TestValidator.equals(\"plus\")(await driver.plus(4, 2))(6);\r\n    TestValidator.equals(\"minus\")(await driver.minus(4, 2))(2);\r\n    TestValidator.equals(\"multiply\")(await driver.multiply(4, 2))(8);\r\n    TestValidator.equals(\"divide\")(await driver.divide(4, 2))(2);\r\n    TestValidator.equals(\"events\")(stack)([\r\n      { type: \"plus\", x: 4, y: 2, z: 6 },\r\n      { type: \"minus\", x: 4, y: 2, z: 2 },\r\n      { type: \"multiply\", x: 4, y: 2, z: 8 },\r\n      { type: \"divide\", x: 4, y: 2, z: 2 },\r\n    ]);\r\n  } catch (exp) {\r\n    throw exp;\r\n  } finally {\r\n    await connector.close();\r\n  }\r\n};\nWebSocket route decorators.@WebSocketRoute() is a collection of decorators for WebSocket routes.Also, supports SDK (Software Development Kit), so that you can easily develop the WebSocket client.\nReferences\nTGrid > Guide Documents > Remote Procedure Call\nTGrid > Guide Documents > Features > Components\nTGrid > Guide Documents > Features > WebSocket Protocol\nTGrid > Guide Documents > Learn from Examples > NestJS WebSocket\n💻 Playground Website","how-to-use#How to use":"","application-setup#Application Setup":"import { WebSocketAdaptor } from \"@nestia/core\";\r\nimport { INestApplication } from \"@nestjs/common\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n\r\nimport { CalculateModule } from \"./CalculateModule\";\r\n\r\nexport namespace CalculateBackend {\r\n  export const start = async (): Promise<INestApplication> => {\r\n    const app: INestApplication = await NestFactory.create(CalculateModule);\r\n    await WebSocketAdaptor.upgrade(app);\r\n    await app.listen(3_000, \"0.0.0.0\");\r\n    return app;\r\n  };\r\n}\nAt first, you need to upgrade your NestJS application to support WebSocket protocol.Import WebSocketAdaptor class from @nestia/core, and call WebSocketAdaptor.upgrade() function with the NestJS application instance like above.If you don't upgrade it, @WebSocketRoute() decorated methods never work.","websocketroute#@WebSocketRoute()":"import { WebSocketRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport { Driver, WebSocketAcceptor } from \"tgrid\";\r\n\r\nimport { ICalculator } from \"./api/structures/ICalculator\";\r\nimport { IListener } from \"./api/structures/IListener\";\r\nimport { Calculator } from \"./providers/Calculator\";\r\n\r\n@Controller(\"calculate\")\r\nexport class CalculateController {\r\n  /**\r\n   * Start simple calculator.\r\n   *\r\n   * Start simple calculator through WebSocket.\r\n   */\r\n  @WebSocketRoute(\"start\")\r\n  public async start(\r\n    @WebSocketRoute.Acceptor()\r\n    acceptor: WebSocketAcceptor<any, ICalculator, IListener>,\r\n    @WebSocketRoute.Driver() driver: Driver<IListener>,\r\n  ): Promise<void> {\r\n    await acceptor.accept(new Calculator(driver));\r\n  }\r\n}\nimport { Driver } from \"tgrid\";\r\n\r\nimport { ICalculator } from \"../api/structures/ICalculator\";\r\nimport { IListener } from \"../api/structures/IListener\";\r\n\r\nexport class Calculator implements ICalculator {\r\n  public constructor(private readonly listener: Driver<IListener>) {}\r\n\r\n  public plus(x: number, y: number): number {\r\n    const z: number = x + y;\r\n    this.listener.on({ type: \"plus\", x, y, z }).catch(() => {});\r\n    return z;\r\n  }\r\n\r\n  public minus(x: number, y: number): number {\r\n    const z: number = x - y;\r\n    this.listener.on({ type: \"minus\", x, y, z }).catch(() => {});\r\n    return z;\r\n  }\r\n\r\n  public multiply(x: number, y: number): number {\r\n    const z: number = x * y;\r\n    this.listener.on({ type: \"multiply\", x, y, z }).catch(() => {});\r\n    return z;\r\n  }\r\n\r\n  public divide(x: number, y: number): number {\r\n    const z: number = x / y;\r\n    this.listener.on({ type: \"divide\", x, y, z }).catch(() => {});\r\n    return z;\r\n  }\r\n}\nexport interface ICalculator {\r\n  plus(a: number, b: number): number;\r\n  minus(a: number, b: number): number;\r\n  multiply(a: number, b: number): number;\r\n  divide(a: number, b: number): number;\r\n}\nexport interface IListener {\r\n  on(event: IListener.IEvent): void;\r\n}\r\nexport namespace IListener {\r\n  export interface IEvent {\r\n    type: string;\r\n    x: number;\r\n    y: number;\r\n    z: number;\r\n  }\r\n}\nimport { TestValidator } from \"@nestia/e2e\";\r\nimport api from \"@samchon/calculator-api/lib/index\";\r\nimport { IListener } from \"@samchon/calculator-api/lib/structures/IListener\";\r\n\r\nexport const test_api_calculate_start = async (\r\n  connection: api.IConnection,\r\n): Promise<void> => {\r\n  const stack: IListener.IEvent[] = [];\r\n  const listener: IListener = {\r\n    on: (event) => stack.push(event),\r\n  };\r\n  const { connector, driver } = await api.functional.calculate.start(\r\n    connection,\r\n    listener,\r\n  );\r\n  try {\r\n    TestValidator.equals(\"plus\")(await driver.plus(4, 2))(6);\r\n    TestValidator.equals(\"minus\")(await driver.minus(4, 2))(2);\r\n    TestValidator.equals(\"multiply\")(await driver.multiply(4, 2))(8);\r\n    TestValidator.equals(\"divide\")(await driver.divide(4, 2))(2);\r\n    TestValidator.equals(\"events\")(stack)([\r\n      { type: \"plus\", x: 4, y: 2, z: 6 },\r\n      { type: \"minus\", x: 4, y: 2, z: 2 },\r\n      { type: \"multiply\", x: 4, y: 2, z: 8 },\r\n      { type: \"divide\", x: 4, y: 2, z: 2 },\r\n    ]);\r\n  } catch (exp) {\r\n    throw exp;\r\n  } finally {\r\n    await connector.close();\r\n  }\r\n};\nAfter that, attach @WebSocketRoute() decorator function onto target method like above.Note that, never forget to defining the @WebSocketRoute.Acceptor() decorated parameter. It is essential for both WebSocket route method and SDK library generation. Each generic arguments of WebSocketAcceptor<Header, Provider, Listener> means like below:\nHeader: Header information received by client\nProvider: Service provider for client\nListener: Remote service provider from client\nAlso, the Driver<IListener> is a type of the remote provider by client. If you call any function of the remote provider, your function call request will be sent to the remote client, and returned value would be received from the client asynchronouly.Therefore, the Driver<T> type converts every functions' return type to be Promise<R>. In the client side, your Provider would be also wrapped into the Driver<Provider>, so that client can call your functions asynchronously, too.","nested-decorators#Nested Decorators":"import { WebSocketRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport { Driver, WebSocketAcceptor } from \"tgrid\";\r\nimport { tags } from \"typia\";\r\n\r\nimport { IAdvancedCalculator } from \"./api/structures/IAdvancedCalculator\";\r\nimport { IHeader } from \"./api/structures/IHeader\";\r\nimport { IListener } from \"./api/structures/IListener\";\r\nimport { IMemo } from \"./api/structures/IMemo\";\r\nimport { AdvancedCalculator } from \"./providers/AdvancedCalculator\";\r\n\r\n@Controller(\"calculate\")\r\nexport class CalculateController {\r\n  /**\r\n   * Start advanced calculator.\r\n   *\r\n   * Start advanced calculator through WebSocket with additional information.\r\n   *\r\n   * @param id ID to assign\r\n   * @param header Header information\r\n   * @param memo Memo to archive\r\n   */\r\n  @WebSocketRoute(\":id/advance\")\r\n  public async advance(\r\n    @WebSocketRoute.Param(\"id\") id: string & tags.Format<\"uuid\">,\r\n    @WebSocketRoute.Header() header: undefined | Partial<IHeader>,\r\n    @WebSocketRoute.Query() memo: IMemo,\r\n    @WebSocketRoute.Acceptor()\r\n    acceptor: WebSocketAcceptor<undefined, IAdvancedCalculator, IListener>,\r\n  ): Promise<void> {\r\n    if (header?.precision !== undefined && header.precision < 0)\r\n      await acceptor.reject(1008, \"Invalid precision value\");\r\n    else\r\n      await acceptor.accept(\r\n        new AdvancedCalculator(\r\n          id,\r\n          { precision: header?.precision ?? 2 },\r\n          memo,\r\n          acceptor.getDriver(),\r\n        ),\r\n      );\r\n  }\r\n}\nimport { Driver } from \"tgrid\";\r\n\r\nimport { IAdvancedCalculator } from \"../api/structures/IAdvancedCalculator\";\r\nimport { IHeader } from \"../api/structures/IHeader\";\r\nimport { IListener } from \"../api/structures/IListener\";\r\nimport { IMemo } from \"../api/structures/IMemo\";\r\n\r\nexport class AdvancedCalculator implements IAdvancedCalculator {\r\n  private round: (value: number) => number;\r\n\r\n  public constructor(\r\n    private readonly id: string,\r\n    private readonly header: IHeader,\r\n    private readonly memo: IMemo,\r\n    private readonly listener: Driver<IListener>,\r\n  ) {\r\n    this.round = roundPrecision(header.precision);\r\n  }\r\n\r\n  public getId(): string {\r\n    return this.id;\r\n  }\r\n  public getPrecision(): number {\r\n    return this.header.precision;\r\n  }\r\n  public getMemo(): IMemo {\r\n    return this.memo;\r\n  }\r\n\r\n  public plus(x: number, y: number): number {\r\n    const z: number = this.round(x + y);\r\n    this.listener.on({ type: \"plus\", x, y, z }).catch(() => {});\r\n    return z;\r\n  }\r\n  public minus(x: number, y: number): number {\r\n    const z: number = this.round(x - y);\r\n    this.listener.on({ type: \"minus\", x, y, z }).catch(() => {});\r\n    return z;\r\n  }\r\n  public multiply(x: number, y: number): number {\r\n    const z: number = this.round(x * y);\r\n    this.listener.on({ type: \"multiply\", x, y, z }).catch(() => {});\r\n    return z;\r\n  }\r\n  public divide(x: number, y: number): number {\r\n    const z: number = this.round(x / y);\r\n    this.listener.on({ type: \"divide\", x, y, z }).catch(() => {});\r\n    return z;\r\n  }\r\n}\r\n\r\nconst roundPrecision =\r\n  (precision: number) =>\r\n  (value: number): number => {\r\n    const factor: number = Math.pow(10, precision);\r\n    return Math.round(value * factor) / factor;\r\n  };\nimport { IMemo } from \"./IMemo\";\r\n\r\nexport interface IAdvancedCalculator {\r\n  plus(a: number, b: number): number;\r\n  minus(a: number, b: number): number;\r\n  multiply(a: number, b: number): number;\r\n  divide(a: number, b: number): number;\r\n\r\n  getId(): string;\r\n  getPrecision(): number;\r\n  getMemo(): IMemo;\r\n}\nexport interface IListener {\r\n  on(event: IListener.IEvent): void;\r\n}\r\nexport namespace IListener {\r\n  export interface IEvent {\r\n    type: string;\r\n    x: number;\r\n    y: number;\r\n    z: number;\r\n  }\r\n}\nimport { TestValidator } from \"@nestia/e2e\";\r\nimport api from \"@samchon/calculator-api/lib/index\";\r\nimport { IListener } from \"@samchon/calculator-api/lib/structures/IListener\";\r\nimport { IMemo } from \"@samchon/calculator-api/lib/structures/IMemo\";\r\nimport { v4 } from \"uuid\";\r\n\r\nexport const test_api_calculate_advance = async (\r\n  connection: api.IConnection,\r\n): Promise<void> => {\r\n  const stack: IListener.IEvent[] = [];\r\n  const listener: IListener = {\r\n    on: (event) => stack.push(event),\r\n  };\r\n\r\n  const id: string = v4();\r\n  const memo: IMemo = {\r\n    title: \"test\",\r\n    description: null,\r\n    time: Date.now(),\r\n  };\r\n  const { connector, driver } = await api.functional.calculate.advance(\r\n    {\r\n      ...connection,\r\n      headers: { precision: 2 },\r\n    },\r\n    id,\r\n    memo,\r\n    listener,\r\n  );\r\n  try {\r\n    TestValidator.equals(\"id\")(await driver.getId())(id);\r\n    TestValidator.equals(\"memo\")(await driver.getMemo())(memo);\r\n    TestValidator.equals(\"precision\")(await driver.getPrecision())(2);\r\n    TestValidator.equals(\"plus\")(await driver.plus(1, 2))(3);\r\n    TestValidator.equals(\"minus\")(await driver.minus(1, 2))(-1);\r\n    TestValidator.equals(\"multiply\")(await driver.multiply(0.01, 0.02))(0);\r\n    TestValidator.equals(\"divide\")(await driver.divide(1, 3))(0.33);\r\n    TestValidator.equals(\"events\")(stack)([\r\n      { type: \"plus\", x: 1, y: 2, z: 3 },\r\n      { type: \"minus\", x: 1, y: 2, z: -1 },\r\n      { type: \"multiply\", x: 0.01, y: 0.02, z: 0 },\r\n      { type: \"divide\", x: 1, y: 3, z: 0.33 },\r\n    ]);\r\n  } catch (exp) {\r\n    throw exp;\r\n  } finally {\r\n    await connector.close();\r\n  }\r\n};\nIf you need additional parameters, you can use nested decorators.\n@WebSocketRoute.Acceptor(): Acceptor for the client connection\n@WebSocketRoute.Driver(): Driver for the remote provider by client\n@WebSocketRoute.Header(): Header information from the client\n@WebSocketRoute.Param(): URL path parameter\n@WebSocketRoute.Query(): URL query parameter\nFor reference, those decorators are almost same with @TypedHeaders(), @TypedParam() and @TypedQuery(). However, they can't be used in @WebSocketRoute() decorated method. Only nested decorator functions under the WebSocketRoute module are allowed.Also, if you don't want to accept the client connection, reject it through WebSocketAcceptor.close() function.","software-development-kit#Software Development Kit":"Related Document: Software Development KitWhen you configure a nestia.config.ts file and run npx nestia sdk command, @nestia/sdk will generate a SDK (Software Development Kit) library for the WebSocket route. With the SDK library, you can easily develop the WebSocket client application with TypeScript types.Also, as I've mentioned above, remote provider by WebSocket server is wrapped into the Driver<T> type, so that the client application can call the remote provider's function asynchronously. For example, ICalculator.plus() function returned number value in the server side, but Driver<T> returns Promise<number> type.In the same reason, the IListener type would be wrapped into the Driver<IListener> in the server side, and the listener provider would be called asynchronously in the server side through the WebSocket network communication.\nimport { TestValidator } from \"@nestia/e2e\";\r\nimport api from \"@samchon/calculator-api/lib/index\";\r\nimport { IListener } from \"@samchon/calculator-api/lib/structures/IListener\";\r\n\r\nexport const test_api_calculate_start = async (\r\n  connection: api.IConnection,\r\n): Promise<void> => {\r\n  const stack: IListener.IEvent[] = [];\r\n  const listener: IListener = {\r\n    on: (event) => stack.push(event),\r\n  };\r\n  const { connector, driver } = await api.functional.calculate.start(\r\n    connection,\r\n    listener,\r\n  );\r\n  try {\r\n    TestValidator.equals(\"plus\")(await driver.plus(4, 2))(6);\r\n    TestValidator.equals(\"minus\")(await driver.minus(4, 2))(2);\r\n    TestValidator.equals(\"multiply\")(await driver.multiply(4, 2))(8);\r\n    TestValidator.equals(\"divide\")(await driver.divide(4, 2))(2);\r\n    TestValidator.equals(\"events\")(stack)([\r\n      { type: \"plus\", x: 4, y: 2, z: 6 },\r\n      { type: \"minus\", x: 4, y: 2, z: 2 },\r\n      { type: \"multiply\", x: 4, y: 2, z: 8 },\r\n      { type: \"divide\", x: 4, y: 2, z: 2 },\r\n    ]);\r\n  } catch (exp) {\r\n    throw exp;\r\n  } finally {\r\n    await connector.close();\r\n  }\r\n};\n/**\r\n * @packageDocumentation\r\n * @module api.functional.calculate\r\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\r\n */\r\n//================================================================\r\nimport type { IConnection } from \"@nestia/fetcher\";\r\nimport { WebSocketConnector } from \"tgrid\";\r\nimport type { Driver } from \"tgrid\";\r\nimport type { Format } from \"typia/lib/tags/Format\";\r\n\r\nimport type { IAdvancedCalculator } from \"../../structures/IAdvancedCalculator\";\r\nimport type { IHeader } from \"../../structures/IHeader\";\r\nimport type { IListener } from \"../../structures/IListener\";\r\nimport type { IMemo } from \"../../structures/IMemo\";\r\n\r\n/**\r\n * Start advanced calculator.\r\n *\r\n * Start advanced calculator through WebSocket with additional information.\r\n *\r\n * @param id ID to assign\r\n * @param memo Memo to archive\r\n *\r\n * @controller CalculateController.advance\r\n * @path /calculate/:id/advance\r\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\r\n */\r\nexport async function advance(\r\n  connection: IConnection<advance.Header>,\r\n  id: string & Format<\"uuid\">,\r\n  memo: advance.Query,\r\n  provider: advance.Provider,\r\n): Promise<advance.Output> {\r\n  const connector: WebSocketConnector<\r\n    advance.Header,\r\n    advance.Provider,\r\n    advance.Listener\r\n  > = new WebSocketConnector(connection.headers ?? ({} as any), provider);\r\n  await connector.connect(\r\n    `${connection.host}/${advance.path(id, memo)}`\r\n      .split(\"/\")\r\n      .filter((str) => !!str)\r\n      .join(\"/\"),\r\n  );\r\n  const driver: Driver<advance.Listener> = connector.getDriver();\r\n  return {\r\n    connector,\r\n    driver,\r\n  };\r\n}\r\nexport namespace advance {\r\n  export type Output = {\r\n    connector: WebSocketConnector<Header, Provider, Listener>;\r\n    driver: Driver<Listener>;\r\n  };\r\n  export type Header = undefined | Partial<IHeader>;\r\n  export type Provider = IListener;\r\n  export type Listener = IAdvancedCalculator;\r\n  export type Query = IMemo;\r\n\r\n  export const path = (id: string & Format<\"uuid\">, memo: advance.Query) => {\r\n    const variables: URLSearchParams = new URLSearchParams();\r\n    for (const [key, value] of Object.entries(memo as any))\r\n      if (undefined === value) continue;\r\n      else if (Array.isArray(value))\r\n        value.forEach((elem: any) => variables.append(key, String(elem)));\r\n      else variables.set(key, String(value));\r\n    const location: string = `/calculate/${encodeURIComponent(id ?? \"null\")}/advance`;\r\n    return 0 === variables.size\r\n      ? location\r\n      : `${location}?${variables.toString()}`;\r\n  };\r\n}\nimport { WebSocketRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport { Driver, WebSocketAcceptor } from \"tgrid\";\r\nimport { tags } from \"typia\";\r\n\r\nimport { IAdvancedCalculator } from \"./api/structures/IAdvancedCalculator\";\r\nimport { IHeader } from \"./api/structures/IHeader\";\r\nimport { IListener } from \"./api/structures/IListener\";\r\nimport { IMemo } from \"./api/structures/IMemo\";\r\nimport { AdvancedCalculator } from \"./providers/AdvancedCalculator\";\r\n\r\n@Controller(\"calculate\")\r\nexport class CalculateController {\r\n  /**\r\n   * Start advanced calculator.\r\n   *\r\n   * Start advanced calculator through WebSocket with additional information.\r\n   *\r\n   * @param id ID to assign\r\n   * @param header Header information\r\n   * @param memo Memo to archive\r\n   */\r\n  @WebSocketRoute(\":id/advance\")\r\n  public async advance(\r\n    @WebSocketRoute.Param(\"id\") id: string & tags.Format<\"uuid\">,\r\n    @WebSocketRoute.Header() header: undefined | Partial<IHeader>,\r\n    @WebSocketRoute.Query() memo: IMemo,\r\n    @WebSocketRoute.Acceptor()\r\n    acceptor: WebSocketAcceptor<undefined, IAdvancedCalculator, IListener>,\r\n  ): Promise<void> {\r\n    if (header?.precision !== undefined && header.precision < 0)\r\n      await acceptor.reject(1008, \"Invalid precision value\");\r\n    else\r\n      await acceptor.accept(\r\n        new AdvancedCalculator(\r\n          id,\r\n          { precision: header?.precision ?? 2 },\r\n          memo,\r\n          acceptor.getDriver(),\r\n        ),\r\n      );\r\n  }\r\n}\nimport { IMemo } from \"./IMemo\";\r\n\r\nexport interface IAdvancedCalculator {\r\n  plus(a: number, b: number): number;\r\n  minus(a: number, b: number): number;\r\n  multiply(a: number, b: number): number;\r\n  divide(a: number, b: number): number;\r\n\r\n  getId(): string;\r\n  getPrecision(): number;\r\n  getMemo(): IMemo;\r\n}\nexport interface IListener {\r\n  on(event: IListener.IEvent): void;\r\n}\r\nexport namespace IListener {\r\n  export interface IEvent {\r\n    type: string;\r\n    x: number;\r\n    y: number;\r\n    z: number;\r\n  }\r\n}","restrictions#Restrictions":"","websocketacceptor#@WebSocketAcceptor()":"When defining @WebSocketRoute() decorated method, you must define the @WebSocketRoute.Acceptor() decorated parameter. It is essential for both WebSocket route method and SDK library generation, because its target type WebSocketAcceptor<Header, Provider, Listener> has significant type definitions for WebSocket communication.\nHeader: Header information received by client\nProvider: Service provider for client\nListener: Remote service provider from client\nimport { WebSocketRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport { Driver, WebSocketAcceptor } from \"tgrid\";\r\n\r\nimport { ICalculator } from \"./api/structures/ICalculator\";\r\nimport { IListener } from \"./api/structures/IListener\";\r\nimport { Calculator } from \"./providers/Calculator\";\r\n\r\n@Controller(\"calculate\")\r\nexport class CalculateController {\r\n  /**\r\n   * Start simple calculator.\r\n   *\r\n   * Start simple calculator through WebSocket.\r\n   */\r\n  @WebSocketRoute(\"start\")\r\n  public async start(\r\n    @WebSocketRoute.Acceptor()\r\n    acceptor: WebSocketAcceptor<any, ICalculator, IListener>,\r\n    @WebSocketRoute.Driver() driver: Driver<IListener>,\r\n  ): Promise<void> {\r\n    await acceptor.accept(new Calculator(driver));\r\n  }\r\n}","websocketrouteparam#@WebSocketRoute.Param()":"@WebSocketRoute.Param() allows only atomic type.\nboolean\nnumber\nstring\nAlso, @WebSocketRoute.Param() allows nullable like number | null, but undefindable type is not.\nnumber | null is allowed\nstring | undefined is prohibited\nIf you violate above condition, and try to declare object or union type, compilation error would be occurred:\nError on nestia.core.WebSocketRoute.Param(): only atomic type is allowed","websocketroutequery#@WebSocketRoute.Query()":"When using @WebSocketRoute.Query(), you've to follow such restriction.At first, type of @WebSocketRoute.Query() must be a pure object type. It does not allow union type. Also, nullable and undefindable types are not allowed, either. Note that, query parameter type must be a sole object type without any extra definition.At next, type of properties must be atomic, or array of atomic type. In the atomic type case, the atomic type allows both nullable and undefindable types. However, mixed union atomic type like string | number or \"1\" | \"2\" | 3 are not allowed. Also, the array type does not allow both nullable and undefindable types, either.\nboolean\nnumber\nbigint\nstring\nexport interface SomeQueryDto {\r\n  //----\r\n  // ATOMIC TYPES\r\n  //----\r\n  // ALLOWED\r\n  boolean: boolean;\r\n  number: number;\r\n  string: string;\r\n  bigint: bigint;\r\n  optional_number?: number;\r\n  nullable_string: string | null;\r\n  literal_union: \"A\" | \"B\" | \"C\" | \"D\";\r\n\r\n  // NOT ALLOWED\r\n  mixed_union: string | number | boolean;\r\n  mixed_literal: \"A\" | \"B\" | 3;\r\n\r\n  //----\r\n  // ARRAY TYPES\r\n  //----\r\n  // ALLOWED\r\n  nullable_element_array: (string | null)[];\r\n  string_array: string[];\r\n  number_array: number[];\r\n  literal_union_array: (\"A\" | \"B\" | \"C\")[];\r\n  literal_tuple: [\"A\", \"B\", \"C\"];\r\n\r\n  // NOT ALLOWED\r\n  optional_element_array: (string | undefined)[];\r\n  optional_array: string[] | undefined;\r\n  nullable_array: string[] | null;\r\n  union_atomic_array: (string | number)[];\r\n  mixed_literal_array: (\"A\", \"B\", 3)[];\r\n  mixed_tuple: [\"A\", \"B\", 3];\r\n}"}},"/docs/core/TypedRoute":{"title":"Docs > Core Library > TypedRoute","data":{"outline#Outline":"export namespace TypedRoute {\r\n  export function Get(path?: string): MethodDecorator;\r\n  export function Post(path?: string): MethodDecorator;\r\n  export function Put(path?: string): MethodDecorator;\r\n  export function Patch(path?: string): MethodDecorator;\r\n  export function Delete(path?: string): MethodDecorator;\r\n}\nRoute decorators 200x faster, even type safe and easy to use.TypedRoute is a namespaced module containing router decorators utilizing typia.assertStringify<T>() function. Those decorators are almost same with original NestJS, but TypedRoute can boost up JSON serialization speed maximum 200x times faster than class-transformer, therefore much faster than original NestJS.Furthermore, as TypedRoute utilizes typia.assertStringify<T>() function, it is even type safe. The typia.assertStringify<T>() function validates response data type, via typia.assert<T>() function, before JSON serialization. Therefore, if you try to return wrong typed value, it would be blocked with 500 internal server error.Moreover, TypedRoute is much easier than class-transformer, because it just needs only pure TypeScript type definition. If you can't understand the word \"pure TypeScript type\", then move to below #How to use section and read the IBbsArticle interface type. You may understand what it means.\nIf you want application/x-www-form-urlencoded type, use @TypedQuery.Post() instead.\n@TypedRoute.Get() is not essential for Swagger Documents or SDK Library building.Therefore, it is not a matter to use @TypedRoute.Post() or @Post() of the original NestJS.","how-to-use#How to use":"import { tags } from \"typia\";\r\n\r\nexport interface IBbsArticle extends IBbsArticle.IStore {\r\n  id: string & tags.Format<\"uuid\">;\r\n  created_at: string & tags.Format<\"date-time\">;\r\n}\r\nexport namespace IBbsArticle {\r\n  export interface IStore {\r\n    title: string & tags.MinLength<3> & tags.MaxLength<50>;\r\n    body: string;\r\n    files: IAttachmentFile[];\r\n  }\r\n}\r\n\r\nexport interface IAttachmentFile {\r\n  name: null | (string & tags.MinLength<1> & tags.MaxLength<255>);\r\n  extension: null | (string & tags.MinLength<1> & tags.MaxLength<8>);\r\n  url: string & tags.Format<\"url\">;\r\n}\nimport { TypedRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\n\r\nimport { IBbsArticle } from \"./IBbsArticle\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  /**\r\n   * Get random article for testing.\r\n   */\r\n  @TypedRoute.Get(\"random\")\r\n  public async random(): Promise<IBbsArticle> {\r\n    return {\r\n      id: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\r\n      title: \"Hello nestia users\",\r\n      body: \"Just use `TypedRoute.Get()` function like this\",\r\n      created_at: \"2023-04-23T12:04:54.168Z\",\r\n      files: [],\r\n    };\r\n  }\r\n}\n\"use strict\";\r\nvar __decorate =\r\n  (this && this.__decorate) ||\r\n  function (decorators, target, key, desc) {\r\n    var c = arguments.length,\r\n      r =\r\n        c < 3\r\n          ? target\r\n          : desc === null\r\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\r\n          : desc,\r\n      d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\r\n      r = Reflect.decorate(decorators, target, key, desc);\r\n    else\r\n      for (var i = decorators.length - 1; i >= 0; i--)\r\n        if ((d = decorators[i]))\r\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n  };\r\nvar __metadata =\r\n  (this && this.__metadata) ||\r\n  function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\r\n      return Reflect.metadata(k, v);\r\n  };\r\nvar __awaiter =\r\n  (this && this.__awaiter) ||\r\n  function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) {\r\n      return value instanceof P\r\n        ? value\r\n        : new P(function (resolve) {\r\n            resolve(value);\r\n          });\r\n    }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n      function fulfilled(value) {\r\n        try {\r\n          step(generator.next(value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function rejected(value) {\r\n        try {\r\n          step(generator[\"throw\"](value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function step(result) {\r\n        result.done\r\n          ? resolve(result.value)\r\n          : adopt(result.value).then(fulfilled, rejected);\r\n      }\r\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BbsArticlesController = void 0;\r\nconst core_1 = require(\"@nestia/core\");\r\nconst common_1 = require(\"@nestjs/common\");\r\nlet BbsArticlesController = class BbsArticlesController {\r\n  /**\r\n   * Get random article for testing.\r\n   */\r\n  random() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return {\r\n        id: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\r\n        title: \"Hello nestia users\",\r\n        body: \"Just use `TypedRoute.Get()` function like this\",\r\n        created_at: \"2023-04-23T12:04:54.168Z\",\r\n        files: [],\r\n      };\r\n    });\r\n  }\r\n};\r\nexports.BbsArticlesController = BbsArticlesController;\r\n__decorate(\r\n  [\r\n    core_1.TypedRoute.Get(\"random\", {\r\n      type: \"assert\",\r\n      assert: (input) => {\r\n        const assert = (input) => {\r\n          const __is = (input) => {\r\n            const $io0 = (input) =>\r\n              \"string\" === typeof input.id &&\r\n              /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n                input.id,\r\n              ) &&\r\n              \"string\" === typeof input.created_at &&\r\n              !isNaN(new Date(input.created_at).getTime()) &&\r\n              \"string\" === typeof input.title &&\r\n              3 <= input.title.length &&\r\n              input.title.length <= 50 &&\r\n              \"string\" === typeof input.body &&\r\n              Array.isArray(input.files) &&\r\n              input.files.every(\r\n                (elem) =>\r\n                  \"object\" === typeof elem && null !== elem && $io1(elem),\r\n              );\r\n            const $io1 = (input) =>\r\n              (null === input.name ||\r\n                (\"string\" === typeof input.name &&\r\n                  1 <= input.name.length &&\r\n                  input.name.length <= 255)) &&\r\n              (null === input.extension ||\r\n                (\"string\" === typeof input.extension &&\r\n                  1 <= input.extension.length &&\r\n                  input.extension.length <= 8)) &&\r\n              \"string\" === typeof input.url &&\r\n              /^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(\r\n                input.url,\r\n              );\r\n            return \"object\" === typeof input && null !== input && $io0(input);\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.TypedRoute.Get.guard;\r\n              const $ao0 = (input, _path, _exceptionable = true) =>\r\n                ((\"string\" === typeof input.id &&\r\n                  (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n                    input.id,\r\n                  ) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".id\",\r\n                      expected: 'string & Format<\"uuid\">',\r\n                      value: input.id,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".id\",\r\n                    expected: '(string & Format<\"uuid\">)',\r\n                    value: input.id,\r\n                  })) &&\r\n                ((\"string\" === typeof input.created_at &&\r\n                  (!isNaN(new Date(input.created_at).getTime()) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".created_at\",\r\n                      expected: 'string & Format<\"date-time\">',\r\n                      value: input.created_at,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".created_at\",\r\n                    expected: '(string & Format<\"date-time\">)',\r\n                    value: input.created_at,\r\n                  })) &&\r\n                ((\"string\" === typeof input.title &&\r\n                  (3 <= input.title.length ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MinLength<3>\",\r\n                      value: input.title,\r\n                    })) &&\r\n                  (input.title.length <= 50 ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MaxLength<50>\",\r\n                      value: input.title,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".title\",\r\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\r\n                    value: input.title,\r\n                  })) &&\r\n                (\"string\" === typeof input.body ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".body\",\r\n                    expected: \"string\",\r\n                    value: input.body,\r\n                  })) &&\r\n                (((Array.isArray(input.files) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files\",\r\n                    expected: \"Array<IAttachmentFile>\",\r\n                    value: input.files,\r\n                  })) &&\r\n                  input.files.every(\r\n                    (elem, _index1) =>\r\n                      (((\"object\" === typeof elem && null !== elem) ||\r\n                        $guard(_exceptionable, {\r\n                          path: _path + \".files[\" + _index1 + \"]\",\r\n                          expected: \"IAttachmentFile\",\r\n                          value: elem,\r\n                        })) &&\r\n                        $ao1(\r\n                          elem,\r\n                          _path + \".files[\" + _index1 + \"]\",\r\n                          true && _exceptionable,\r\n                        )) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".files[\" + _index1 + \"]\",\r\n                        expected: \"IAttachmentFile\",\r\n                        value: elem,\r\n                      }),\r\n                  )) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files\",\r\n                    expected: \"Array<IAttachmentFile>\",\r\n                    value: input.files,\r\n                  }));\r\n              const $ao1 = (input, _path, _exceptionable = true) =>\r\n                (null === input.name ||\r\n                  (\"string\" === typeof input.name &&\r\n                    (1 <= input.name.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".name\",\r\n                        expected: \"string & MinLength<1>\",\r\n                        value: input.name,\r\n                      })) &&\r\n                    (input.name.length <= 255 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".name\",\r\n                        expected: \"string & MaxLength<255>\",\r\n                        value: input.name,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".name\",\r\n                    expected:\r\n                      \"((string & MinLength<1> & MaxLength<255>) | null)\",\r\n                    value: input.name,\r\n                  })) &&\r\n                (null === input.extension ||\r\n                  (\"string\" === typeof input.extension &&\r\n                    (1 <= input.extension.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".extension\",\r\n                        expected: \"string & MinLength<1>\",\r\n                        value: input.extension,\r\n                      })) &&\r\n                    (input.extension.length <= 8 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".extension\",\r\n                        expected: \"string & MaxLength<8>\",\r\n                        value: input.extension,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".extension\",\r\n                    expected: \"((string & MinLength<1> & MaxLength<8>) | null)\",\r\n                    value: input.extension,\r\n                  })) &&\r\n                ((\"string\" === typeof input.url &&\r\n                  (/^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(\r\n                    input.url,\r\n                  ) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".url\",\r\n                      expected: 'string & Format<\"url\">',\r\n                      value: input.url,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".url\",\r\n                    expected: '(string & Format<\"url\">)',\r\n                    value: input.url,\r\n                  }));\r\n              return (\r\n                (((\"object\" === typeof input && null !== input) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IBbsArticle\",\r\n                    value: input,\r\n                  })) &&\r\n                  $ao0(input, _path + \"\", true)) ||\r\n                $guard(true, {\r\n                  path: _path + \"\",\r\n                  expected: \"IBbsArticle\",\r\n                  value: input,\r\n                })\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        };\r\n        const stringify = (input) => {\r\n          const $io1 = (input) =>\r\n            (null === input.name ||\r\n              (\"string\" === typeof input.name &&\r\n                1 <= input.name.length &&\r\n                input.name.length <= 255)) &&\r\n            (null === input.extension ||\r\n              (\"string\" === typeof input.extension &&\r\n                1 <= input.extension.length &&\r\n                input.extension.length <= 8)) &&\r\n            \"string\" === typeof input.url &&\r\n            /^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(\r\n              input.url,\r\n            );\r\n          const $string = core_1.TypedRoute.Get.string;\r\n          const $so0 = (input) =>\r\n            `{\"id\":${$string(input.id)},\"created_at\":${$string(\r\n              input.created_at,\r\n            )},\"title\":${$string(input.title)},\"body\":${$string(\r\n              input.body,\r\n            )},\"files\":${`[${input.files\r\n              .map((elem) => $so1(elem))\r\n              .join(\",\")}]`}}`;\r\n          const $so1 = (input) =>\r\n            `{\"name\":${\r\n              null !== input.name ? $string(input.name) : \"null\"\r\n            },\"extension\":${\r\n              null !== input.extension ? $string(input.extension) : \"null\"\r\n            },\"url\":${$string(input.url)}}`;\r\n          return $so0(input);\r\n        };\r\n        return stringify(assert(input));\r\n      },\r\n    }),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", []),\r\n    __metadata(\"design:returntype\", Promise),\r\n  ],\r\n  BbsArticlesController.prototype,\r\n  \"random\",\r\n  null,\r\n);\r\nexports.BbsArticlesController = BbsArticlesController = __decorate(\r\n  [(0, common_1.Controller)(\"bbs/articles\")],\r\n  BbsArticlesController,\r\n);\nJust call @TypedRoute.${method}() function on the target method, that's all.Nestia will analyze your type (IBbsArticle), and writes optimal code for the target type, in the compilation level. If you click the \"Compiled JavaScript File\" tab of above, you can see the optimal validation and JSON serialization code.Such optimization is called AOT (Ahead of Time) compilation, and it is the secret of TypedRoute.","special-tags#Special Tags":"You can enhance validation logic, of TypedRoute, through comment tags.You know what? @TypedRoute.${method}() functions are using typia.assertStringify<T>() function, that is combined with typia.assert<T>() and typia.stringify<T>() functions. It is the secret of @TypedRoute.${method}() functions, which can validates response body data type before JSON serialization, and throws 500 internal server error when the data type is not matched.Also, as typia.assert<T>() function can utililze comment tags for additional validation, TypedRoute also can utillze them, too. For reference, \"Type Tag\" means a intersection type with atomic type and special tag type of typia like number & tags.Type<\"uint32\">, and \"Comment Tag\" means a comment starting from @ symbol following @${name} ${value} format.With those type and comment tags, you can add additional validation logics. If you want to add a custom validation logic, you also can do it. Read below Guide Docments of typia, and see the example code. You may understand how to utilize such type and comment tags, in a few minutes.\ntypia > Validators > Custom Tags\nOutline\nType Tags\nComment Tags\nCustomization\nimport typia, { tags } from \"typia\";\r\n\r\nexport const checkSpecialTag = typia.createIs<SpecialTag>();\r\n\r\ninterface SpecialTag {\r\n  int32: number & tags.Type<\"int32\">;\r\n  range?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\r\n  minLength: string & tags.MinLength<3>;\r\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\r\n  date: null | (string & tags.Format<\"date\">);\r\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\r\n  uuids: Array<string & tags.Format<\"uuid\">> &\r\n    tags.MinItems<3> &\r\n    tags.MaxItems<100>;\r\n}\n\"use strict\";\r\nvar __importDefault =\r\n  (this && this.__importDefault) ||\r\n  function (mod) {\r\n    return mod && mod.__esModule ? mod : { default: mod };\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.checkSpecialTag = void 0;\r\nconst typia_1 = __importDefault(require(\"typia\"));\r\nconst checkSpecialTag = (input) => {\r\n  const $io0 = (input) =>\r\n    \"number\" === typeof input.int32 &&\r\n    Math.floor(input.int32) === input.int32 &&\r\n    -2147483648 <= input.int32 &&\r\n    input.int32 <= 2147483647 &&\r\n    (undefined === input.range ||\r\n      (\"number\" === typeof input.range &&\r\n        19 < input.range &&\r\n        input.range <= 100)) &&\r\n    \"string\" === typeof input.minLength &&\r\n    3 <= input.minLength.length &&\r\n    \"string\" === typeof input.pattern &&\r\n    /^[a-z]+$/.test(input.pattern) &&\r\n    (null === input.date ||\r\n      (\"string\" === typeof input.date &&\r\n        /^(d{4})-(d{2})-(d{2})$/.test(input.date))) &&\r\n    \"string\" === typeof input.ip &&\r\n    (/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\r\n      input.ip,\r\n    ) ||\r\n      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(\r\n        input.ip,\r\n      )) &&\r\n    Array.isArray(input.uuids) &&\r\n    3 <= input.uuids.length &&\r\n    input.uuids.length <= 100 &&\r\n    input.uuids.every(\r\n      (elem) =>\r\n        \"string\" === typeof elem &&\r\n        /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\r\n          elem,\r\n        ),\r\n    );\r\n  return \"object\" === typeof input && null !== input && $io0(input);\r\n};\r\nexports.checkSpecialTag = checkSpecialTag;","encryptedroute#EncryptedRoute":"export namespace EncryptedRoute {\r\n  export function Get(path?: string): MethodDecorator;\r\n  export function Post(path?: string): MethodDecorator;\r\n  export function Put(path?: string): MethodDecorator;\r\n  export function Patch(path?: string): MethodDecorator;\r\n  export function Delete(path?: string): MethodDecorator;\r\n}\nEncrypted router decorator functions.EncryptedRoute is a namespaced module similar with TypedRoute, but it encrypts response body data through AES-128/256 CBC algorithm like below. Therefore, it would be slower than TypedRoute, but it guarantees the security of response body data.\nAES-128/256\nCBC mode\nPKCS #5 Padding\nBase64 Encoding\nFor reference, such encryption spec is not supported in the Swagger-UI. Instead, SDK (Software Development Kit) generated by @nestia/sdk supports it. Thus, you have to build and distribute the SDK library to the client developers when using such encryption decorators.","configuration#Configuration":"{\r\n  \"compilerOptions\": {\r\n    \"strict\": true,\r\n    \"plugins\": [\r\n      { \"transform\": \"typia/lib/transform\" },\r\n      {\r\n        \"transform\": \"@nestia/core/lib/transform\",\r\n        \"stringify\": \"assert\",\r\n        // \"llm\": {\r\n        //   \"model\": \"chatgpt\",\r\n        //   \"strict\": true,\r\n        // },\r\n      }\r\n    ]\r\n  }\r\n}\nChange JSON serializer to another one.If you configure stringify property of plugin defined in the tsconfig.json file, you can change the @TypedRoute module to utilize another JSON serialization function instead of the default typia.json.assertStringify<T>() function. For example, if you change the property to \"validate\", the JSON serialization function of @TypedRoute module be changed to typia.json.validateStringify() function.Here is the list of available options.\nstringify: typia.json.stringify<T>()\nassert: typia.json.assertStringify<T>()\nis: typia.json.isStringify<T>()\nvalidate: typia.json.validateStringify<T>()\nvalidate.log: typia.json.validateStringify<T>(), but do not throw error and just log it\nnull: just use JSON.stringify() function without validation\nBy the way, this is not a recommended way, but you can skip the response type validation for. If you set the stringify property to null, the response type validation will be skipped and just JSON.stringify() function be used.Also, validate.log performs the validation, but does not throw 500 internal server error. When type error be detected, it serializes response data by JSON.stringify() function, and logs the error message to the console or somewhere you've specified. It is useful when you want to know the error message, but do not want to throw 500 internal server error to the client application.\nTypedRoute.setValidateErrorLogger((err: TypedRoute.IValidateErrorLog) => {\r\n  // you can customize the validation error logging\r\n  console.error(err);\r\n});\nAdditionally, if you configure llm property of the plugin, @nestia/core considers that your backend application has been developed for LLM function calling, and validates the request/response body types following the target LLM model's restrictions.For example, if you configure chatgpt with strict option, dynamic properties and optional properties are not allowed in the request/response body types. If your some request/response body types are not following the target LLM model's restrictions, @nestia/core will throw a compilation error.Here is the list of available LLM models. Read their definitions, and follow their restrictions.\nSupported schemas\n\"chatgpt\": (IChatGptSchema), OpenAI ChatGPT\n\"claude\": (IClaudeSchema), Anthropic Claude\n\"gemini\": (IGeminiSchema), Google Gemini\n\"llama\": (ILlamaSchema), Meta Llama\nMidldle layer schemas\n\"3.0\": (ILlmSchemaV3), middle layer based on OpenAPI v3.0 specification\n\"3.1\": (ILlmSchemaV3_1), middle layer based on OpenAPI v3.1 specification","benchmark#Benchmark":"","json#JSON":"Comparing JSON serialization speed, typia is maximum 200x faster than class-transformer.For reference, Nestia is using typia, and NestJS is using class-transformer. The other one fast-json-stringify is made and used by fastify (do not mean NestJS fastify mode, but mean pure fastify library. NestJS fastify mode still utilizes class-transformer), and it requires JSON schema definition.From above benchmark graph, you can see that class-transformer is extremely slower than others, even including built-in JSON.stringify() function. I can't understand why NestJS has adopted such slow and difficult library. The other fast-json-stringify is enough faster, but it needs extra schema definition like class-validator, therefore not easy to use.\ntypia needs only pure TypeScript type.\nclass-transformer requires DTO class with decorator function calls.\nfast-json-stringify requires JSON schema definition.\nMeasured on AMD R9-7940HS, Rog Flow X13","server#Server":"Looking at above benchmark, someone may ask:\nJSON serialization speed affects on the server performance?I think that the JSON serialization is just a tiny thing in the server side, isn't it?\nMy answer is, \"Yes, it affects on the server performance\".Most operations in NodeJS server are asynchronously executed in background thread, what are called \"event based non-blocking I/O model\". However, JSON serialization is a synchronous operation running on the main thread. Therefore, if the JSON serialization speed is slow, it makes the entire server program slow.I'll show you the benchmark result that, how JSON serizliation speed affects on the server performance.\nMeasured on AMD R9-7940HS, Rog Flow X13"}},"/docs/e2e/why":{"title":"Guide Documents > E2E Testing > Why E2E Test?","data":{"outline#Outline":"E2E test functions rather than unit test functions.When developing a test program for NestJS developed backend server, I recommend to adapt E2E test paradigm instead of unit test paradigm. It's because with the @nestia/sdk generated SDK library, E2E test functions can be much easier, safer and efficient for production than the traditional unit test functions.Furthermore, if you develop test functions utilizing the SDK library, you can easily switch the e2e test functions to the performance benchmark functions. Just by utilizing @nestia/e2e and @nestia/benchmark libraries, you can easily measure your NestJS developed backend server's performance through the SDK library utilizing e2e test functions.\nE2E Test Function Example\nBenchmark Result Example\nSDK library utilizing test functions can be used in the performance benchmark program","efficient-for-production#Efficient for Production":"New era, age of E2E testing paradigm comes.In the past era, backend developers had developed test programs following the unit test paradigm. It's because traditional E2E test functions' development could not take any advantage of compiled language's type safety. As you can see from the below example code, E2E test functions had to write hard-coded fetch() function with string literals.Besides, unit test could take advantages of compiled language's type safety by importing related modules. Therefore, it was more efficient to develop test functions following the unit test paradigm. This is the reason why unit test paradigm had been loved in the past era.\nimport { TestValidator } from \"@nestia/e2e\";\r\nimport typia from \"typia\";\r\n\r\nimport { IBbsArticle } from \"@samchon/bbs-api/lib/structures/bbs/IBbsArticle\";\r\n\r\nexport const test_api_bbs_article_create = async (\r\n  host: string,\r\n): Promise<void> => {\r\n  // In the traditional age, E2E test function could not take advantages \r\n  // of type safety of the TypeScript. Instead, have to write hard-coded\r\n  // `fetch()` function with string literals.\r\n  const response: Response = await fetch(`${host}/bbs/articles`, {\r\n    method: \"POST\",\r\n    headers: {\r\n      \"Content-Type\": \"application/json\",\r\n    },\r\n    body: JSON.stringify({\r\n      writer: \"someone\",\r\n      password: \"1234\",\r\n      title: \"title\",\r\n      body: \"content\",\r\n      format: \"md\",\r\n      files: [],\r\n    } satisfies IBbsArticle.ICreate),\r\n  });\r\n  const article: IBbsArticle = await response.json();\r\n  typia.assert(article);\r\n\r\n  const read: IBbsArticle = await (async () => {\r\n    const response: Response = await fetch(`${host}/bbs/articles/${article.id}`);\r\n    const article: IBbsArticle = await response.json();\r\n    return typia.assert(article);\r\n  })();\r\n  TestValidator.equals(\"written\")(article)(read);\r\n};\nimport { TestValidator } from \"@nestia/e2e\";\r\nimport typia from \"typia\";\r\n\r\nimport { IBbsArticle } from \"@samchon/bbs-api/lib/structures/bbs/IBbsArticle\";\r\n\r\nimport { BbsArticleProvider } from \"../../../../src/providers/bbs/BbsArticleProvider\";\r\n\r\nexport const test_provider_bbs_article_create = async (): Promise<void> => {\r\n  // Besides, unit test could take advantages of type safety.\r\n  const article: IBbsArticle = await BbsArticleProvider.write({\r\n    writer: \"someone\",\r\n    password: \"1234\",\r\n    title: \"title\",\r\n    body: \"content\",\r\n    format: \"md\",\r\n    files: [],\r\n  });\r\n  typia.assert(article);\r\n\r\n  // Therefore, unit test had been loved in the past era\r\n  const read: IBbsArticle = await BbsArticleProvider.at(article.id);\r\n  typia.assert(read);\r\n  TestValidator.equals(\"written\")(article)(read);\r\n};\nHowever, in the new era, e2e test functions also can take advantages of the type safety. Just import SDK library generated by @nestia/e2e, and call API functions of it with TypeScript type hints. In this way, as both e2e test paradigm and unit test paradigm can take advantages of type safety, we have to consider which strategy is suitable for the production environment.In here article, I recommend to adapt e2e test paradigm in the below reasons.\nsuitable for CDD (Contract Driven Development)\neasy to develop and maintain\nmuch safer than unit testing due to its coverage\ncan be used for the performance benchmark\ncan guide client developers as an example code\nLook at the below example code of new era's e2e test function, and compare it with the traditional unit test function. As you can see, e2e test function actually tests the backend server's behavior by calling the real API endpoints of it. Besides, unit test can't test the backend server's actual behavior. It just validates the provider's behavior. This is the reason why new era's e2e test function is safer than unit test function.Also, such new era's e2e test function can be provided to the client or frontend developers as an example code. It guides them how to call the backend server's API endpoints through the SDK library. In this way, e2e test function can be used as a well-structured document for the client developers.\nimport { TestValidator } from \"@nestia/e2e\";\r\nimport typia from \"typia\";\r\n\r\nimport BbsApi from \"@samchon/bbs-api\";\r\nimport { IBbsArticle } from \"@samchon/bbs-api/lib/structures/bbs/IBbsArticle\";\r\n\r\nexport const test_provider_bbs_article_create = async (\r\n  connection: BbsApi.IConnection\r\n): Promise<void> => {\r\n  // Unit test functions can't validate \r\n  // the backend server's actual behavior.\r\n  const article: IBbsArticle = await BbsApi.functional.bbs.articles.create(\r\n    connection,\r\n    {\r\n      writer: \"someone\",\r\n      password: \"1234\",\r\n      title: \"title\",\r\n      body: \"content\",\r\n      format: \"md\",\r\n      files: [],\r\n    },\r\n  );\r\n  typia.assert(article);\r\n\r\n  // This is the reason why I've adopted the e2e test paradigm\r\n  const read: IBbsArticle = await BbsApi.functional.bbs.articles.at(\r\n    connection,\r\n    article.id,\r\n  );\r\n  typia.assert(read);\r\n  TestValidator.equals(\"written\")(article)(read);\r\n};\nimport { TestValidator } from \"@nestia/e2e\";\r\nimport typia from \"typia\";\r\n\r\nimport BbsApi from \"@samchon/bbs-api\";\r\n\r\nimport { BbsArticleProvider } from \"../../../../src/providers/bbs/BbsArticleProvider\";\r\n\r\nexport const test_provider_bbs_article_create = async (): Promise<void> => {\r\n  // Unit test functions can't validate \r\n  // the backend server's actual behavior.\r\n  const article: IBbsArticle = await BbsArticleProvider.write({\r\n    writer: \"someone\",\r\n    password: \"1234\",\r\n    title: \"title\",\r\n    body: \"content\",\r\n    format: \"md\",\r\n    files: [],\r\n  });\r\n  typia.assert(article);\r\n\r\n  // This is the reason why I've adopted the e2e test paradigm\r\n  const read: IBbsArticle = await BbsArticleProvider.at(article.id);\r\n  typia.assert(read);\r\n  TestValidator.equals(\"written\")(article)(read);\r\n};\nAt last, the new era's e2e test functions can be used for the performance benchmark without any extra dedication. As the e2e test function directly calls the API endpoints of the backend server, backend server performance benchmark program can be easily developed by utilizing them.Those are the reasons why I recommend to adapt the new era's e2e test paradigm instead of the traditional unit test paradigm. Those are the reason why I am insisting that e2e test functions are efficient for production. From now on, let's see how to compose the e2e test functions for the NestJS developed backend server.\nYou can experience benchmark program utilizing e2e test functions.💻 https://stackblitz.com/~/github.com/samchon/nestia-start","test-program-development#Test Program Development":"import { DynamicExecutor } from \"@nestia/e2e\";\r\n\r\nimport api from \"@ORGANIZATION/PROJECT-api\";\r\n\r\nimport { MyBackend } from \"../src/MyBackend\";\r\nimport { MyConfiguration } from \"../src/MyConfiguration\";\r\nimport { MyGlobal } from \"../src/MyGlobal\";\r\nimport { ArgumentParser } from \"./helpers/ArgumentParser\";\r\n\r\ninterface IOptions {\r\n  include?: string[];\r\n  exclude?: string[];\r\n}\r\n\r\nconst getOptions = () =>\r\n  ArgumentParser.parse<IOptions>(async (command, _prompt, action) => {\r\n    // command.option(\"--mode <string>\", \"target mode\");\r\n    // command.option(\"--reset <true|false>\", \"reset local DB or not\");\r\n    command.option(\"--include <string...>\", \"include feature files\");\r\n    command.option(\"--exclude <string...>\", \"exclude feature files\");\r\n\r\n    return action(async (options) => {\r\n      // if (typeof options.reset === \"string\")\r\n      //     options.reset = options.reset === \"true\";\r\n      // options.mode ??= await prompt.select(\"mode\")(\"Select mode\")([\r\n      //     \"LOCAL\",\r\n      //     \"DEV\",\r\n      //     \"REAL\",\r\n      // ]);\r\n      // options.reset ??= await prompt.boolean(\"reset\")(\"Reset local DB\");\r\n      return options as IOptions;\r\n    });\r\n  });\r\n\r\nasync function main(): Promise<void> {\r\n  // CONFIGURATIONS\r\n  const options: IOptions = await getOptions();\r\n  MyGlobal.testing = true;\r\n\r\n  // BACKEND SERVER\r\n  const backend: MyBackend = new MyBackend();\r\n  await backend.open();\r\n\r\n  //----\r\n  // CLIENT CONNECTOR\r\n  //----\r\n  // DO TEST\r\n  const connection: api.IConnection = {\r\n    host: `http://127.0.0.1:${MyConfiguration.API_PORT()}`,\r\n  };\r\n  const report: DynamicExecutor.IReport = await DynamicExecutor.validate({\r\n    prefix: \"test\",\r\n    parameters: () => [{ ...connection }],\r\n    filter: (func) =>\r\n      (!options.include?.length ||\r\n        (options.include ?? []).some((str) => func.includes(str))) &&\r\n      (!options.exclude?.length ||\r\n        (options.exclude ?? []).every((str) => !func.includes(str))),\r\n  })(__dirname + \"/features\");\r\n\r\n  await backend.close();\r\n\r\n  const failures: DynamicExecutor.IReport.IExecution[] =\r\n    report.executions.filter((exec) => exec.error !== null);\r\n  if (failures.length === 0) {\r\n    console.log(\"Success\");\r\n    console.log(\"Elapsed time\", report.time.toLocaleString(), `ms`);\r\n  } else {\r\n    for (const f of failures) console.log(f.error);\r\n    process.exit(-1);\r\n  }\r\n\r\n  console.log(\r\n    [\r\n      `All: #${report.executions.length}`,\r\n      `Success: #${report.executions.length - failures.length}`,\r\n      `Failed: #${failures.length}`,\r\n    ].join(\"\\n\"),\r\n  );\r\n}\r\nmain().catch((exp) => {\r\n  console.log(exp);\r\n  process.exit(-1);\r\n});\nimport { RandomGenerator, TestValidator } from \"@nestia/e2e\";\r\nimport { v4 } from \"uuid\";\r\n\r\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\r\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\r\n\r\nexport async function test_api_bbs_article_create(\r\n  connection: api.IConnection,\r\n): Promise<void> {\r\n  // STORE A NEW ARTICLE\r\n  const stored: IBbsArticle = await api.functional.bbs.articles.create(\r\n    connection,\r\n    \"general\",\r\n    {\r\n      writer: RandomGenerator.name(),\r\n      title: RandomGenerator.paragraph(3)(),\r\n      body: RandomGenerator.content(8)()(),\r\n      format: \"txt\",\r\n      files: [\r\n        {\r\n          name: \"logo\",\r\n          extension: \"png\",\r\n          url: \"https://somewhere.com/logo.png\",\r\n        },\r\n      ],\r\n      password: v4(),\r\n    },\r\n  );\r\n\r\n  // READ THE DATA AGAIN\r\n  const read: IBbsArticle = await api.functional.bbs.articles.at(\r\n    connection,\r\n    stored.section,\r\n    stored.id,\r\n  );\r\n  TestValidator.equals(\"created\")(stored)(read);\r\n}\nimport { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\r\n\r\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\r\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\r\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/common/IPage\";\r\n\r\nexport async function test_api_bbs_article_index_search(\r\n  connection: api.IConnection,\r\n): Promise<void> {\r\n  // GENERATE 100 ARTICLES\r\n  const section: string = \"general\";\r\n  const articles: IBbsArticle[] = await ArrayUtil.asyncRepeat(100)(() =>\r\n    api.functional.bbs.articles.create(connection, section, {\r\n      writer: RandomGenerator.name(),\r\n      title: RandomGenerator.paragraph(4)(),\r\n      body: RandomGenerator.content(3)()(),\r\n      format: \"txt\",\r\n      files: [],\r\n      password: RandomGenerator.alphabets(8),\r\n    }),\r\n  );\r\n\r\n  // GET ENTIRE DATA\r\n  const total: IPage<IBbsArticle.ISummary> =\r\n    await api.functional.bbs.articles.index(connection, section, {\r\n      limit: articles.length,\r\n      sort: [\"-created_at\"],\r\n    });\r\n\r\n  // PREPARE SEARCH FUNCTION\r\n  const search = TestValidator.search(\"BbsArticleProvider.index()\")(\r\n    async (input: IBbsArticle.IRequest.ISearch) => {\r\n      const page: IPage<IBbsArticle.ISummary> =\r\n        await api.functional.bbs.articles.index(connection, section, {\r\n          limit: articles.length,\r\n          search: input,\r\n          sort: [\"-created_at\"],\r\n        });\r\n      return page.data;\r\n    },\r\n  )(total.data, 10);\r\n\r\n  // SEARCH TITLE\r\n  await search({\r\n    fields: [\"title\"],\r\n    values: (article) => [article.title],\r\n    request: ([title]) => ({ title }),\r\n    filter: (article, [title]) => article.title.includes(title),\r\n  });\r\n\r\n  // SEARCH WRITER\r\n  await search({\r\n    fields: [\"writer\"],\r\n    values: (article) => [article.writer],\r\n    request: ([writer]) => ({ writer }),\r\n    filter: (article, [writer]) => article.writer.includes(writer),\r\n  });\r\n\r\n  // SEARCH BOTH OF THEM\r\n  await search({\r\n    fields: [\"title\", \"writer\"],\r\n    values: (article) => [article.title, article.writer],\r\n    request: ([title, writer]) => ({ title, writer }),\r\n    filter: (article, [title, writer]) =>\r\n      article.title.includes(title) && article.writer.includes(writer),\r\n  });\r\n}\nJust make test functions utillizing SDK library, and export those functions with test_ prefixed names. And then if compose the main program of the test, all of the test functions would be automatically mounted and executed whenever you run the main test program.If you want to experience the test program earlier, visit below playground website.💻 https://stackblitz.com/~/github.com/samchon/nestia-start\n- test_api_bbs_article_at: 149 ms\r\n- test_api_bbs_article_create: 30 ms\r\n- test_api_bbs_article_index_search: 1,312 ms\r\n- test_api_bbs_article_index_sort: 1,110 ms\r\n- test_api_bbs_article_update: 28 m","performance-benchmark#Performance Benchmark":"import { DynamicBenchmarker } from \"@nestia/benchmark\";\r\nimport cliProgress from \"cli-progress\";\r\nimport fs from \"fs\";\r\nimport os from \"os\";\r\nimport { IPointer } from \"tstl\";\r\n\r\nimport { MyBackend } from \"../../src/MyBackend\";\r\nimport { MyConfiguration } from \"../../src/MyConfiguration\";\r\nimport { MyGlobal } from \"../../src/MyGlobal\";\r\nimport { ArgumentParser } from \"../helpers/ArgumentParser\";\r\n\r\ninterface IOptions {\r\n  include?: string[];\r\n  exclude?: string[];\r\n  count: number;\r\n  threads: number;\r\n  simultaneous: number;\r\n}\r\n\r\nconst getOptions = () =>\r\n  ArgumentParser.parse<IOptions>(async (command, prompt, action) => {\r\n    // command.option(\"--mode <string>\", \"target mode\");\r\n    // command.option(\"--reset <true|false>\", \"reset local DB or not\");\r\n    command.option(\"--include <string...>\", \"include feature files\");\r\n    command.option(\"--exclude <string...>\", \"exclude feature files\");\r\n    command.option(\"--count <number>\", \"number of requests to make\");\r\n    command.option(\"--threads <number>\", \"number of threads to use\");\r\n    command.option(\r\n      \"--simultaneous <number>\",\r\n      \"number of simultaneous requests to make\",\r\n    );\r\n    return action(async (options) => {\r\n      // if (typeof options.reset === \"string\")\r\n      //     options.reset = options.reset === \"true\";\r\n      // options.mode ??= await prompt.select(\"mode\")(\"Select mode\")([\r\n      //     \"LOCAL\",\r\n      //     \"DEV\",\r\n      //     \"REAL\",\r\n      // ]);\r\n      // options.reset ??= await prompt.boolean(\"reset\")(\"Reset local DB\");\r\n      options.count = Number(\r\n        options.count ??\r\n          (await prompt.number(\"count\")(\"Number of requests to make\")),\r\n      );\r\n      options.threads = Number(\r\n        options.threads ??\r\n          (await prompt.number(\"threads\")(\"Number of threads to use\")),\r\n      );\r\n      options.simultaneous = Number(\r\n        options.simultaneous ??\r\n          (await prompt.number(\"simultaneous\")(\r\n            \"Number of simultaneous requests to make\",\r\n          )),\r\n      );\r\n      return options as IOptions;\r\n    });\r\n  });\r\n\r\nconst main = async (): Promise<void> => {\r\n  // CONFIGURATIONS\r\n  const options: IOptions = await getOptions();\r\n  MyGlobal.testing = true;\r\n\r\n  // BACKEND SERVER\r\n  const backend: MyBackend = new MyBackend();\r\n  await backend.open();\r\n\r\n  // DO BENCHMARK\r\n  const prev: IPointer<number> = { value: 0 };\r\n  const bar: cliProgress.SingleBar = new cliProgress.SingleBar(\r\n    {},\r\n    cliProgress.Presets.shades_classic,\r\n  );\r\n  bar.start(options.count, 0);\r\n\r\n  const report: DynamicBenchmarker.IReport = await DynamicBenchmarker.master({\r\n    servant: `${__dirname}/servant.js`,\r\n    count: options.count,\r\n    threads: options.threads,\r\n    simultaneous: options.simultaneous,\r\n    filter: (func) =>\r\n      (!options.include?.length ||\r\n        (options.include ?? []).some((str) => func.includes(str))) &&\r\n      (!options.exclude?.length ||\r\n        (options.exclude ?? []).every((str) => !func.includes(str))),\r\n    progress: (value: number) => {\r\n      if (value >= 100 + prev.value) {\r\n        bar.update(value);\r\n        prev.value = value;\r\n      }\r\n    },\r\n    stdio: \"ignore\",\r\n  });\r\n  bar.stop();\r\n\r\n  // DOCUMENTATION\r\n  try {\r\n    await fs.promises.mkdir(`${MyConfiguration.ROOT}/docs/benchmarks`, {\r\n      recursive: true,\r\n    });\r\n  } catch {}\r\n  await fs.promises.writeFile(\r\n    `${MyConfiguration.ROOT}/docs/benchmarks/${os\r\n      .cpus()[0]\r\n      .model.trim()\r\n      .split(\"\\\\\")\r\n      .join(\"\")\r\n      .split(\"/\")\r\n      .join(\"\")}.md`,\r\n    DynamicBenchmarker.markdown(report),\r\n    \"utf8\",\r\n  );\r\n\r\n  // CLOSE\r\n  await backend.close();\r\n};\r\nmain().catch((exp) => {\r\n  console.error(exp);\r\n  process.exit(-1);\r\n});\nimport { DynamicBenchmarker } from \"@nestia/benchmark\";\r\n\r\nimport { MyConfiguration } from \"../../src/MyConfiguration\";\r\n\r\nDynamicBenchmarker.servant({\r\n  connection: {\r\n    host: `http://127.0.0.1:${MyConfiguration.API_PORT()}`,\r\n  },\r\n  location: `${__dirname}/../features`,\r\n  parameters: (connection) => [connection],\r\n  prefix: \"test_api_\",\r\n}).catch((exp) => {\r\n  console.error(exp);\r\n  process.exit(-1);\r\n});\nimport { RandomGenerator, TestValidator } from \"@nestia/e2e\";\r\nimport { v4 } from \"uuid\";\r\n\r\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\r\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\r\n\r\nexport async function test_api_bbs_article_create(\r\n  connection: api.IConnection,\r\n): Promise<void> {\r\n  // STORE A NEW ARTICLE\r\n  const stored: IBbsArticle = await api.functional.bbs.articles.create(\r\n    connection,\r\n    \"general\",\r\n    {\r\n      writer: RandomGenerator.name(),\r\n      title: RandomGenerator.paragraph(3)(),\r\n      body: RandomGenerator.content(8)()(),\r\n      format: \"txt\",\r\n      files: [\r\n        {\r\n          name: \"logo\",\r\n          extension: \"png\",\r\n          url: \"https://somewhere.com/logo.png\",\r\n        },\r\n      ],\r\n      password: v4(),\r\n    },\r\n  );\r\n\r\n  // READ THE DATA AGAIN\r\n  const read: IBbsArticle = await api.functional.bbs.articles.at(\r\n    connection,\r\n    stored.section,\r\n    stored.id,\r\n  );\r\n  TestValidator.equals(\"created\")(stored)(read);\r\n}\nimport { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\r\n\r\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\r\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\r\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/common/IPage\";\r\n\r\nexport async function test_api_bbs_article_index_search(\r\n  connection: api.IConnection,\r\n): Promise<void> {\r\n  // GENERATE 100 ARTICLES\r\n  const section: string = \"general\";\r\n  const articles: IBbsArticle[] = await ArrayUtil.asyncRepeat(100)(() =>\r\n    api.functional.bbs.articles.create(connection, section, {\r\n      writer: RandomGenerator.name(),\r\n      title: RandomGenerator.paragraph(4)(),\r\n      body: RandomGenerator.content(3)()(),\r\n      format: \"txt\",\r\n      files: [],\r\n      password: RandomGenerator.alphabets(8),\r\n    }),\r\n  );\r\n\r\n  // GET ENTIRE DATA\r\n  const total: IPage<IBbsArticle.ISummary> =\r\n    await api.functional.bbs.articles.index(connection, section, {\r\n      limit: articles.length,\r\n      sort: [\"-created_at\"],\r\n    });\r\n\r\n  // PREPARE SEARCH FUNCTION\r\n  const search = TestValidator.search(\"BbsArticleProvider.index()\")(\r\n    async (input: IBbsArticle.IRequest.ISearch) => {\r\n      const page: IPage<IBbsArticle.ISummary> =\r\n        await api.functional.bbs.articles.index(connection, section, {\r\n          limit: articles.length,\r\n          search: input,\r\n          sort: [\"-created_at\"],\r\n        });\r\n      return page.data;\r\n    },\r\n  )(total.data, 10);\r\n\r\n  // SEARCH TITLE\r\n  await search({\r\n    fields: [\"title\"],\r\n    values: (article) => [article.title],\r\n    request: ([title]) => ({ title }),\r\n    filter: (article, [title]) => article.title.includes(title),\r\n  });\r\n\r\n  // SEARCH WRITER\r\n  await search({\r\n    fields: [\"writer\"],\r\n    values: (article) => [article.writer],\r\n    request: ([writer]) => ({ writer }),\r\n    filter: (article, [writer]) => article.writer.includes(writer),\r\n  });\r\n\r\n  // SEARCH BOTH OF THEM\r\n  await search({\r\n    fields: [\"title\", \"writer\"],\r\n    values: (article) => [article.title, article.writer],\r\n    request: ([title, writer]) => ({ title, writer }),\r\n    filter: (article, [title, writer]) =>\r\n      article.title.includes(title) && article.writer.includes(writer),\r\n  });\r\n}\nYou can re-use test functions for the performance benchmark program.Just compose the benchmark's main and servant programs like above pointing the test functions' directory, then the benchmark program would utilize those test functions for the backend server performance measurement. The benchmark program will make multiple worker threads, and let them to make requests to the backend server simultaneously through the test functions.If you want to experience the benchmark program earlier, visit below playground website.💻 https://stackblitz.com/~/github.com/samchon/nestia-start\n? Number of requests to make 1024\r\n? Number of threads to use 4\r\n? Number of simultaneous requests to make 32\r\n████████████████████████████████████████ 100% | ETA: 0s | 3654/1024"}},"/docs/pure":{"title":"Guide Documents > Pure TypeScript Type","data":{"outline#Outline":"nestia can use pure TypeScript type.You know what? NestJS needs triple duplicated DTO schema definitions. The 1st is defining TypeScript type, the 2nd and 3rd are calling decorator functions of class-validator and @nestjs/swagger. It's not only annoying, but also error-prone. If you take any mistake on the 2nd or 3rd, it can't be detected by TypeScript compiler. It will be detected only at runtime. Another words, it is not type safe.Besides, nestia needs only pure TypeScript type. You don't need to define any extra schema like class-validator or @nestjs/swagger. Just define pure TypeScript type only (especially recommend to use interface type), then nestia will do all the rest.","demonstration#Demonstration":"If you're confusing how DTO of NestJS and nestia are different, just see example codes below.At first, look at the first (Triple duplicated NestJS DTO) tab, and find the BbsArticle.files property, enhanced by blue colored blocks. Looking at the files property, how do you feel? Just defining an array object type, you've to call 7 decorator functions. If you take any mistake when using the decorator like omitting isArray property, it would be a critical runtime error.Besides, nestia needs only one line. Click the second (Pure Nestia DTO) tab, and find the IAttachmentFile.files property. Only one line being used, and IBbsArticle and IAttachment types are not even class, but just interface types. Comparing it to the first tab, how do you feel? Isn't it more simple and readable?This is the power of nestia, with pure TypeScript type.\nimport { ApiProperty } from \"@nestjs/swagger\";\r\nimport {\r\n  ArrayNotEmpty,\r\n  Format,\r\n  IsArray,\r\n  IsObject,\r\n  IsOptional,\r\n  IsString,\r\n  Match,\r\n  MaxLength,\r\n  Type,\r\n  ValidateNested,\r\n} from \"class-validator\";\r\n\r\nexport class BbsArticle {\r\n  @ApiProperty({\r\n    format: \"uuid\",\r\n  })\r\n  @IsString()\r\n  id!: string;\r\n\r\n  // DUPLICATED SCHEMA DEFINITION\r\n  // - duplicated function call + property type\r\n  // - have to specify `isArray` and `nullable` props by yourself\r\n  @ApiProperty({\r\n    type: () => AttachmentFile,\r\n    nullable: true,\r\n    isArray: true,\r\n    description: \"List of attached files.\",\r\n  })\r\n  @Type(() => AttachmentFile)\r\n  @IsArray()\r\n  @IsOptional()\r\n  @IsObject({ each: true })\r\n  @ValidateNested({ each: true })\r\n  files!: AttachmentFile[] | null;\r\n\r\n  @ApiProperty({\r\n    type: \"string\",\r\n    nullable: true,\r\n    minLength: 5,\r\n    maxLength: 100,\r\n    description: \"Title of the article.\",\r\n  })\r\n  @IsOptional()\r\n  @IsString()\r\n  title!: string | null;\r\n\r\n  @ApiProperty({\r\n    description: \"Main content body of the article.\",\r\n  })\r\n  @IsString()\r\n  body!: string;\r\n\r\n  @ApiProperty({\r\n    format: \"date-time\",\r\n    description: \"Creation time of article\",\r\n  })\r\n  @IsString()\r\n  created_at!: string;\r\n}\r\n\r\nexport class AttachmentFile {\r\n  @ApiProperty({\r\n    type: \"string\",\r\n    maxLength: 255,\r\n    pattern: \"^[a-zA-Z0-9-_]+$\",\r\n    description: \"File name.\",\r\n  })\r\n  @Matches(/^[a-z0-9]+$/)\r\n  @MaxLength(255)\r\n  @IsString()\r\n  name!: string | null;\r\n\r\n  @ApiProperty({\r\n    type: \"string\",\r\n    nullable: true,\r\n    maxLength: 255,\r\n    pattern: \"^[a-zA-Z0-9-_]+$\",\r\n    description: \"File extension.\",\r\n  })\r\n  @Matches(/^[a-z0-9]+$/)\r\n  @MaxLength(8)\r\n  @IsOptional()\r\n  @IsString()\r\n  extension!: string | null;\r\n\r\n  @ApiProperty({\r\n    format: \"url\",\r\n    description: \"URL of the file.\",\r\n  })\r\n  @Format(\"uri\")\r\n  @IsString()\r\n  url!: string;\r\n}\nimport { tags } from \"typia\";\r\n\r\nexport interface IBbsArticle {\r\n  /**\r\n   * Primary Key.\r\n   */\r\n  id: string & tags.Format<\"uuid\">;\r\n\r\n  /**\r\n   * List of attached files.\r\n   */\r\n  files: null | IAttachmentFile[];\r\n\r\n  /**\r\n   * Title of the article.\r\n   */\r\n  title: null | (string & tags.MinLength<5> & tags.MaxLength<100>);\r\n\r\n  /**\r\n   * Main content body of the article.\r\n   */\r\n  body: string;\r\n\r\n  /**\r\n   * Creation time of article.\r\n   */\r\n  created_at: string & tags.Format<\"date-time\">;\r\n}\r\n\r\nexport interface IAttachmentFile {\r\n  /**\r\n   * File name.\r\n   */\r\n  name: string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<255>;\r\n\r\n  /**\r\n   * File extension.\r\n   */\r\n  extension: null | (string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<8>);\r\n\r\n  /**\r\n   * URL of the file.\r\n   */\r\n  url: string & tags.Format<\"uri\">;\r\n}","aot-compilation#AOT Compilation":"Someone may be suspicious of the phrase \"Pure TypeScript Type\".\n\"As you know, TypeScript types do not have any tangible instance when compiled to JS.However, with only these fictitious TypeScript types, how can nestia validates types at runtime? How nestia builds swagger documents or SDK library with only these types? Are these things really possible without extra schema definition like class-validator or @nestjs/swagger?\"\nMy answer is: \"Yes, it is possible due to nestia analyzes your server code, and performs AOT compilation\".When compiling, nestia travels your NestJS server codes, and analyzes DTO definitions. And then, nestia writes optimal code to the compiled JavaScript file. In the @TypedBody() case, nestia transforms it to optimal validation code for the IBbsArticle.IStore type. Also, nestia transforms @TypedRoute.Post() function to optimal JSON serialization code for the IBbsArticle type.Such compile time optimization is called AOT (Ahead of Time) compilation. And this is the secret why nestia can do everything with only pure TypeScript type. Read below example codes, and just look how JavaScript file being compiled. Then you may understand why nestia is much easier, and furthermore much faster.\nRuntime validator is 20,000x faster than class-validator\nJSON serialization is 200x faster than class-transformer\nimport { tags } from \"typia\";\r\n\r\nexport interface IBbsArticle extends IBbsArticle.ICreate {\r\n  id: string & tags.Format<\"uuid\">;\r\n  created_at: string & tags.Format<\"date-time\">;\r\n}\r\nexport namespace IBbsArticle {\r\n  export interface ICreate {\r\n    title: string & tags.MinLength<3> & tags.MaxLength<50>;\r\n    body: string;\r\n    files: IAttachmentFile[];\r\n  }\r\n}\r\n\r\nexport interface IAttachmentFile {\r\n  name: null | (string & tags.MinLength<1> & tags.MaxLength<255>);\r\n  extension: null | (string & tags.MinLength<1> & tags.MaxLength<8>);\r\n  url: string | (string & tags.Format<\"url\">);\r\n}\nimport { TypedBody, TypedRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\n\r\nimport { IBbsArticle } from \"./IBbsArticle\";\r\n\r\n@Controller(\"bbs/articles\")\r\nexport class BbsArticlesController {\r\n  @TypedRoute.Post() // 200x faster JSON serialization\r\n  public async store(\r\n    // 20,000x faster validation\r\n    @TypedBody() input: IBbsArticle.ICreate,\r\n  ): Promise<IBbsArticle> {\r\n    return {\r\n      ...input,\r\n      id: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\r\n      created_at: \"2023-04-23T12:04:54.168Z\",\r\n    };\r\n  }\r\n}\n\"use strict\";\r\n\"use strict\";\r\nvar __decorate =\r\n  (this && this.__decorate) ||\r\n  function (decorators, target, key, desc) {\r\n    var c = arguments.length,\r\n      r =\r\n        c < 3\r\n          ? target\r\n          : desc === null\r\n          ? (desc = Object.getOwnPropertyDescriptor(target, key))\r\n          : desc,\r\n      d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\r\n      r = Reflect.decorate(decorators, target, key, desc);\r\n    else\r\n      for (var i = decorators.length - 1; i >= 0; i--)\r\n        if ((d = decorators[i]))\r\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n  };\r\nvar __metadata =\r\n  (this && this.__metadata) ||\r\n  function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\r\n      return Reflect.metadata(k, v);\r\n  };\r\nvar __param =\r\n  (this && this.__param) ||\r\n  function (paramIndex, decorator) {\r\n    return function (target, key) {\r\n      decorator(target, key, paramIndex);\r\n    };\r\n  };\r\nvar __awaiter =\r\n  (this && this.__awaiter) ||\r\n  function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) {\r\n      return value instanceof P\r\n        ? value\r\n        : new P(function (resolve) {\r\n            resolve(value);\r\n          });\r\n    }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n      function fulfilled(value) {\r\n        try {\r\n          step(generator.next(value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function rejected(value) {\r\n        try {\r\n          step(generator[\"throw\"](value));\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }\r\n      function step(result) {\r\n        result.done\r\n          ? resolve(result.value)\r\n          : adopt(result.value).then(fulfilled, rejected);\r\n      }\r\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n  };\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BbsArticlesController = void 0;\r\nconst core_1 = require(\"@nestia/core\");\r\nconst common_1 = require(\"@nestjs/common\");\r\nlet BbsArticlesController = class BbsArticlesController {\r\n  store(\r\n    // 20,000x faster validation\r\n    input,\r\n  ) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return Object.assign(Object.assign({}, input), {\r\n        id: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\r\n        created_at: \"2023-04-23T12:04:54.168Z\",\r\n      });\r\n    });\r\n  }\r\n};\r\nexports.BbsArticlesController = BbsArticlesController;\r\n__decorate(\r\n  [\r\n    core_1.TypedRoute.Post({\r\n      type: \"assert\",\r\n      assert: (input) => {\r\n        const assert = (input) => {\r\n          const __is = (input) => {\r\n            const $io0 = (input) =>\r\n              \"string\" === typeof input.id &&\r\n              /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n                input.id,\r\n              ) &&\r\n              \"string\" === typeof input.created_at &&\r\n              !isNaN(new Date(input.created_at).getTime()) &&\r\n              \"string\" === typeof input.title &&\r\n              3 <= input.title.length &&\r\n              input.title.length <= 50 &&\r\n              \"string\" === typeof input.body &&\r\n              Array.isArray(input.files) &&\r\n              input.files.every(\r\n                (elem) =>\r\n                  \"object\" === typeof elem && null !== elem && $io1(elem),\r\n              );\r\n            const $io1 = (input) =>\r\n              (null === input.name ||\r\n                (\"string\" === typeof input.name &&\r\n                  1 <= input.name.length &&\r\n                  input.name.length <= 255)) &&\r\n              (null === input.extension ||\r\n                (\"string\" === typeof input.extension &&\r\n                  1 <= input.extension.length &&\r\n                  input.extension.length <= 8)) &&\r\n              \"string\" === typeof input.url &&\r\n              /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu.test(\r\n                input.url,\r\n              );\r\n            return \"object\" === typeof input && null !== input && $io0(input);\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.TypedRoute.Post.guard;\r\n              const $ao0 = (input, _path, _exceptionable = true) =>\r\n                ((\"string\" === typeof input.id &&\r\n                  (/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n                    input.id,\r\n                  ) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".id\",\r\n                      expected: 'string & Format<\"uuid\">',\r\n                      value: input.id,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".id\",\r\n                    expected: '(string & Format<\"uuid\">)',\r\n                    value: input.id,\r\n                  })) &&\r\n                ((\"string\" === typeof input.created_at &&\r\n                  (!isNaN(new Date(input.created_at).getTime()) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".created_at\",\r\n                      expected: 'string & Format<\"date-time\">',\r\n                      value: input.created_at,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".created_at\",\r\n                    expected: '(string & Format<\"date-time\">)',\r\n                    value: input.created_at,\r\n                  })) &&\r\n                ((\"string\" === typeof input.title &&\r\n                  (3 <= input.title.length ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MinLength<3>\",\r\n                      value: input.title,\r\n                    })) &&\r\n                  (input.title.length <= 50 ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MaxLength<50>\",\r\n                      value: input.title,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".title\",\r\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\r\n                    value: input.title,\r\n                  })) &&\r\n                (\"string\" === typeof input.body ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".body\",\r\n                    expected: \"string\",\r\n                    value: input.body,\r\n                  })) &&\r\n                (((Array.isArray(input.files) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files\",\r\n                    expected: \"Array<IAttachmentFile>\",\r\n                    value: input.files,\r\n                  })) &&\r\n                  input.files.every(\r\n                    (elem, _index1) =>\r\n                      (((\"object\" === typeof elem && null !== elem) ||\r\n                        $guard(_exceptionable, {\r\n                          path: _path + \".files[\" + _index1 + \"]\",\r\n                          expected: \"IAttachmentFile\",\r\n                          value: elem,\r\n                        })) &&\r\n                        $ao1(\r\n                          elem,\r\n                          _path + \".files[\" + _index1 + \"]\",\r\n                          true && _exceptionable,\r\n                        )) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".files[\" + _index1 + \"]\",\r\n                        expected: \"IAttachmentFile\",\r\n                        value: elem,\r\n                      }),\r\n                  )) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files\",\r\n                    expected: \"Array<IAttachmentFile>\",\r\n                    value: input.files,\r\n                  }));\r\n              const $ao1 = (input, _path, _exceptionable = true) =>\r\n                (null === input.name ||\r\n                  (\"string\" === typeof input.name &&\r\n                    (1 <= input.name.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".name\",\r\n                        expected: \"string & MinLength<1>\",\r\n                        value: input.name,\r\n                      })) &&\r\n                    (input.name.length <= 255 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".name\",\r\n                        expected: \"string & MaxLength<255>\",\r\n                        value: input.name,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".name\",\r\n                    expected:\r\n                      \"((string & MinLength<1> & MaxLength<255>) | null)\",\r\n                    value: input.name,\r\n                  })) &&\r\n                (null === input.extension ||\r\n                  (\"string\" === typeof input.extension &&\r\n                    (1 <= input.extension.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".extension\",\r\n                        expected: \"string & MinLength<1>\",\r\n                        value: input.extension,\r\n                      })) &&\r\n                    (input.extension.length <= 8 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".extension\",\r\n                        expected: \"string & MaxLength<8>\",\r\n                        value: input.extension,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".extension\",\r\n                    expected: \"((string & MinLength<1> & MaxLength<8>) | null)\",\r\n                    value: input.extension,\r\n                  })) &&\r\n                ((\"string\" === typeof input.url &&\r\n                  (/^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu.test(\r\n                    input.url,\r\n                  ) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".url\",\r\n                      expected: 'string & Format<\"url\">',\r\n                      value: input.url,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".url\",\r\n                    expected: '(string & Format<\"url\">)',\r\n                    value: input.url,\r\n                  }));\r\n              return (\r\n                (((\"object\" === typeof input && null !== input) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IBbsArticle\",\r\n                    value: input,\r\n                  })) &&\r\n                  $ao0(input, _path + \"\", true)) ||\r\n                $guard(true, {\r\n                  path: _path + \"\",\r\n                  expected: \"IBbsArticle\",\r\n                  value: input,\r\n                })\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        };\r\n        const stringify = (input) => {\r\n          const $io1 = (input) =>\r\n            (null === input.name ||\r\n              (\"string\" === typeof input.name &&\r\n                1 <= input.name.length &&\r\n                input.name.length <= 255)) &&\r\n            (null === input.extension ||\r\n              (\"string\" === typeof input.extension &&\r\n                1 <= input.extension.length &&\r\n                input.extension.length <= 8)) &&\r\n            \"string\" === typeof input.url &&\r\n            /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu.test(\r\n              input.url,\r\n            );\r\n          const $string = core_1.TypedRoute.Post.string;\r\n          const $so0 = (input) =>\r\n            `{\"id\":${$string(input.id)},\"created_at\":${$string(\r\n              input.created_at,\r\n            )},\"title\":${$string(input.title)},\"body\":${$string(\r\n              input.body,\r\n            )},\"files\":${`[${input.files\r\n              .map((elem) => $so1(elem))\r\n              .join(\",\")}]`}}`;\r\n          const $so1 = (input) =>\r\n            `{\"name\":${\r\n              null !== input.name ? $string(input.name) : \"null\"\r\n            },\"extension\":${\r\n              null !== input.extension ? $string(input.extension) : \"null\"\r\n            },\"url\":${$string(input.url)}}`;\r\n          return $so0(input);\r\n        };\r\n        return stringify(assert(input));\r\n      },\r\n    }), // 200x faster JSON serialization\r\n    __param(\r\n      0,\r\n      (0, core_1.TypedBody)({\r\n        type: \"assert\",\r\n        assert: (input) => {\r\n          const __is = (input) => {\r\n            const $io0 = (input) =>\r\n              \"string\" === typeof input.title &&\r\n              3 <= input.title.length &&\r\n              input.title.length <= 50 &&\r\n              \"string\" === typeof input.body &&\r\n              Array.isArray(input.files) &&\r\n              input.files.every(\r\n                (elem) =>\r\n                  \"object\" === typeof elem && null !== elem && $io1(elem),\r\n              );\r\n            const $io1 = (input) =>\r\n              (null === input.name ||\r\n                (\"string\" === typeof input.name &&\r\n                  1 <= input.name.length &&\r\n                  input.name.length <= 255)) &&\r\n              (null === input.extension ||\r\n                (\"string\" === typeof input.extension &&\r\n                  1 <= input.extension.length &&\r\n                  input.extension.length <= 8)) &&\r\n              \"string\" === typeof input.url &&\r\n              /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu.test(\r\n                input.url,\r\n              );\r\n            return \"object\" === typeof input && null !== input && $io0(input);\r\n          };\r\n          if (false === __is(input))\r\n            ((input, _path, _exceptionable = true) => {\r\n              const $guard = core_1.TypedBody.guard;\r\n              const $ao0 = (input, _path, _exceptionable = true) =>\r\n                ((\"string\" === typeof input.title &&\r\n                  (3 <= input.title.length ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MinLength<3>\",\r\n                      value: input.title,\r\n                    })) &&\r\n                  (input.title.length <= 50 ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".title\",\r\n                      expected: \"string & MaxLength<50>\",\r\n                      value: input.title,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".title\",\r\n                    expected: \"(string & MinLength<3> & MaxLength<50>)\",\r\n                    value: input.title,\r\n                  })) &&\r\n                (\"string\" === typeof input.body ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".body\",\r\n                    expected: \"string\",\r\n                    value: input.body,\r\n                  })) &&\r\n                (((Array.isArray(input.files) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files\",\r\n                    expected: \"Array<IAttachmentFile>\",\r\n                    value: input.files,\r\n                  })) &&\r\n                  input.files.every(\r\n                    (elem, _index1) =>\r\n                      (((\"object\" === typeof elem && null !== elem) ||\r\n                        $guard(_exceptionable, {\r\n                          path: _path + \".files[\" + _index1 + \"]\",\r\n                          expected: \"IAttachmentFile\",\r\n                          value: elem,\r\n                        })) &&\r\n                        $ao1(\r\n                          elem,\r\n                          _path + \".files[\" + _index1 + \"]\",\r\n                          true && _exceptionable,\r\n                        )) ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".files[\" + _index1 + \"]\",\r\n                        expected: \"IAttachmentFile\",\r\n                        value: elem,\r\n                      }),\r\n                  )) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".files\",\r\n                    expected: \"Array<IAttachmentFile>\",\r\n                    value: input.files,\r\n                  }));\r\n              const $ao1 = (input, _path, _exceptionable = true) =>\r\n                (null === input.name ||\r\n                  (\"string\" === typeof input.name &&\r\n                    (1 <= input.name.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".name\",\r\n                        expected: \"string & MinLength<1>\",\r\n                        value: input.name,\r\n                      })) &&\r\n                    (input.name.length <= 255 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".name\",\r\n                        expected: \"string & MaxLength<255>\",\r\n                        value: input.name,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".name\",\r\n                    expected:\r\n                      \"((string & MinLength<1> & MaxLength<255>) | null)\",\r\n                    value: input.name,\r\n                  })) &&\r\n                (null === input.extension ||\r\n                  (\"string\" === typeof input.extension &&\r\n                    (1 <= input.extension.length ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".extension\",\r\n                        expected: \"string & MinLength<1>\",\r\n                        value: input.extension,\r\n                      })) &&\r\n                    (input.extension.length <= 8 ||\r\n                      $guard(_exceptionable, {\r\n                        path: _path + \".extension\",\r\n                        expected: \"string & MaxLength<8>\",\r\n                        value: input.extension,\r\n                      }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".extension\",\r\n                    expected: \"((string & MinLength<1> & MaxLength<8>) | null)\",\r\n                    value: input.extension,\r\n                  })) &&\r\n                ((\"string\" === typeof input.url &&\r\n                  (/^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu.test(\r\n                    input.url,\r\n                  ) ||\r\n                    $guard(_exceptionable, {\r\n                      path: _path + \".url\",\r\n                      expected: 'string & Format<\"url\">',\r\n                      value: input.url,\r\n                    }))) ||\r\n                  $guard(_exceptionable, {\r\n                    path: _path + \".url\",\r\n                    expected: '(string & Format<\"url\">)',\r\n                    value: input.url,\r\n                  }));\r\n              return (\r\n                (((\"object\" === typeof input && null !== input) ||\r\n                  $guard(true, {\r\n                    path: _path + \"\",\r\n                    expected: \"IBbsArticle.ICreate\",\r\n                    value: input,\r\n                  })) &&\r\n                  $ao0(input, _path + \"\", true)) ||\r\n                $guard(true, {\r\n                  path: _path + \"\",\r\n                  expected: \"IBbsArticle.ICreate\",\r\n                  value: input,\r\n                })\r\n              );\r\n            })(input, \"$input\", true);\r\n          return input;\r\n        },\r\n      }),\r\n    ),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object]),\r\n    __metadata(\"design:returntype\", Promise),\r\n  ],\r\n  BbsArticlesController.prototype,\r\n  \"store\",\r\n  null,\r\n);\r\nexports.BbsArticlesController = BbsArticlesController = __decorate(\r\n  [(0, common_1.Controller)(\"bbs/articles\")],\r\n  BbsArticlesController,\r\n);\r\n//# sourceMappingURL=BbsArticlesController.js.map\nMeasured on AMD R9-7940HS, Rog Flow X13"}},"/docs/sdk/e2e":{"title":"Guide Documents > S/W Development Kit > E2E Test Functions","data":{"outline#Outline":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nnpx nestia e2e\r\nnpx nestia e2e --config nestia.config.ts --project tsconfig.json\nConfigure nestia.config.ts file and run npx nestia e2e command.Then, @nestia/sdk will analyze your NestJS backend server code, and generate both SDK (Software Development Kit) library for client developers. Also, E2E test functions, utilizing the SDK library, will be automatically generated for corresponding to every API functions.Here is an example of generated E2E test functions:\nimport typia, { Primitive } from \"typia\";\r\n\r\nimport api from \"../../../../src/api\";\r\nimport type { IBbsArticle } from \"../../../../src/api/structures/IBbsArticle\";\r\n\r\nexport const test_api_body_store = async (\r\n  connection: api.IConnection,\r\n): Promise<void> => {\r\n  const output = await api.functional.body.store(\r\n    connection,\r\n    typia.random<Primitive<IBbsArticle.IStore>>(),\r\n  );\r\n  typia.assert(output);\r\n};\nLeft is server code, and right is e2e test code utilizing SDK library","configuration#Configuration":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport type { INestApplication } from \"@nestjs/common\";\r\nimport { OpenApi } from \"@samchon/openapi\";\r\n\r\n/**\r\n * Definition for the `nestia.config.ts` file.\r\n *\r\n * @author Jeongho Nam - https://github.com/samchon\r\n */\r\nexport interface INestiaConfig {\r\n  /**\r\n   * Accessor of controller classes.\r\n   *\r\n   * You can specify it within two ways\r\n   *\r\n   *   - Asynchronous function returning `INestApplication` instance\r\n   *   - Specify the path or directory of controller class files\r\n   */\r\n  input:\r\n    | (() => Promise<INestApplication>)\r\n    | INestiaConfig.IInput\r\n    | string[]\r\n    | string;\r\n\r\n  /**\r\n   * Output directory that SDK would be placed in.\r\n   *\r\n   * If not configured, you can't build the SDK library.\r\n   */\r\n  output?: string;\r\n\r\n  /**\r\n   * Building `swagger.json` is also possible.\r\n   *\r\n   * If not specified, you can't build the `swagger.json`.\r\n   */\r\n  swagger?: INestiaConfig.ISwaggerConfig;\r\n\r\n  /**\r\n   * Target directory that SDK distribution files would be placed in.\r\n   *\r\n   * If you configure this property and runs `npx nestia sdk` command,\r\n   * distribution environments for the SDK library would be generated.\r\n   *\r\n   * After the SDK library generation, move to the `distribute` directory,\r\n   * and runs `npm publish` command, then you can share SDK library with\r\n   * other client (frontend) developers.\r\n   *\r\n   * Recommend to use `\"packages/api\"` value.\r\n   */\r\n  distribute?: string;\r\n\r\n  /**\r\n   * Allow simulation mode.\r\n   *\r\n   * If you configure this property to be `true`, the SDK library would be contain\r\n   * simulation mode. In the simulation mode, the SDK library would not communicate\r\n   * with the real backend server, but just returns random mock-up data\r\n   * with requestion data validation.\r\n   *\r\n   * For reference, random mock-up data would be generated by `typia.random<T>()`\r\n   * function.\r\n   *\r\n   * @default false\r\n   */\r\n  simulate?: boolean;\r\n\r\n  /**\r\n   * Target directory that e2e test functions would be placed in.\r\n   *\r\n   * If you configure this property and runs `npx nestia e2e` command,\r\n   * `@nestia/sdk` will analyze your NestJS backend server code, and\r\n   * generates e2e test functions for every API endpoints.\r\n   *\r\n   * If not configured, you can't run `npx nestia e2e` command.\r\n   */\r\n  e2e?: string;\r\n\r\n  /**\r\n   * Whether to use propagation mode or not.\r\n   *\r\n   * If being configured, interaction functions of the SDK library would\r\n   * perform the propagation mode. The propagation mode means that never\r\n   * throwing exception even when status code is not 200 (or 201), but just\r\n   * returning the {@link IPropagation} typed instance, which can specify its body\r\n   * type through discriminated union determined by status code.\r\n   *\r\n   * @default false\r\n   */\r\n  propagate?: boolean;\r\n\r\n  /**\r\n   * Whether to clone DTO structures or not.\r\n   *\r\n   * If being configured, all of DTOs used in the backend server would be cloned\r\n   * into the `structures` directory, and the SDK library would be refer to the\r\n   * cloned DTOs instead of the original.\r\n   *\r\n   * @default false\r\n   */\r\n  clone?: boolean;\r\n\r\n  /**\r\n   * Whether to wrap DTO by primitive type.\r\n   *\r\n   * If you don't configure this property as `false`, all of DTOs in the\r\n   * SDK library would be automatically wrapped by {@link Primitive} type.\r\n   *\r\n   * For refenrece, if a DTO type be capsuled by the {@link Primitive} type,\r\n   * all of methods in the DTO type would be automatically erased. Also, if\r\n   * the DTO has a `toJSON()` method, the DTO type would be automatically\r\n   * converted to return type of the `toJSON()` method.\r\n   *\r\n   * @default true\r\n   */\r\n  primitive?: boolean;\r\n\r\n  /**\r\n   * Whether to assert parameter types or not.\r\n   *\r\n   * If you configure this property to be `true`, all of the function\r\n   * parameters of SDK library would be checked through\r\n   * [`typia.assert<T>()` function](https://typia.io/docs/validators/assert/).\r\n   *\r\n   * This option would make your SDK library compilation time a little bit slower,\r\n   * but would enahcne the type safety even in the runtime level.\r\n   *\r\n   * @default false\r\n   */\r\n  assert?: boolean;\r\n\r\n  /**\r\n   * Whether to optimize JSON string conversion 10x faster or not.\r\n   *\r\n   * If you configure this property to be `true`, the SDK library would utilize the\r\n   * [`typia.assertStringify<T>() function`](https://github.com/samchon/typia#enhanced-json)\r\n   * to boost up JSON serialization speed and ensure type safety.\r\n   *\r\n   * This option would make your SDK library compilation time a little bit slower,\r\n   * but would enhance JSON serialization speed 10x faster. Also, it can ensure type\r\n   * safety even in the runtime level.\r\n   *\r\n   * @default false\r\n   */\r\n  json?: boolean;\r\n}\r\nexport namespace INestiaConfig {\r\n  /**\r\n   * List of files or directories to include or exclude to specifying the NestJS\r\n   * controllers.\r\n   */\r\n  export interface IInput {\r\n    /**\r\n     * List of files or directories containing the NestJS controller classes.\r\n     */\r\n    include: string[];\r\n\r\n    /**\r\n     * List of files or directories to be excluded.\r\n     */\r\n    exclude?: string[];\r\n  }\r\n\r\n  /**\r\n   * Building `swagger.json` is also possible.\r\n   */\r\n  export interface ISwaggerConfig {\r\n    /**\r\n     * Output path of the `swagger.json`.\r\n     *\r\n     * If you've configured only directory, the file name would be the `swagger.json`.\r\n     * Otherwise you've configured the full path with file name and extension, the\r\n     * `swagger.json` file would be renamed to it.\r\n     */\r\n    output: string;\r\n\r\n    /**\r\n     * OpenAPI version.\r\n     *\r\n     * If you configure this property to be `2.0` or `3.0`, the newly generated\r\n     * `swagger.json` file would follow the specified OpenAPI version. The newly\r\n     * generated `swagger.json` file would be downgraded from the OpenAPI v3.1\r\n     * specification by {@link OpenApi.downgrade} method.\r\n     *\r\n     * @default 3.1\r\n     */\r\n    openapi?: \"2.0\" | \"3.0\" | \"3.1\";\r\n\r\n    /**\r\n     * API information.\r\n     *\r\n     * If omitted, `package.json` content would be used instead.\r\n     */\r\n    info?: Partial<OpenApi.IDocument.IInfo>;\r\n\r\n    /**\r\n     * List of server addresses.\r\n     */\r\n    servers?: OpenApi.IServer[];\r\n\r\n    /**\r\n     * Security schemes.\r\n     *\r\n     * When generating `swagger.json` file through `nestia`, if your controllers or\r\n     * theirs methods have a security key which is not enrolled in here property,\r\n     * it would be an error.\r\n     */\r\n    security?: Record<string, OpenApi.SecurityScheme>;\r\n\r\n    /**\r\n     * List of tag names with description.\r\n     *\r\n     * It is possible to omit this property or skip some tag name even if\r\n     * the tag name is used in the API routes. In that case, the tag name\r\n     * would be used without description.\r\n     *\r\n     * Of course, if you've written a comment like `@tag {name} {description}`,\r\n     * you can entirely replace this property specification.\r\n     */\r\n    tags?: OpenApi.IDocument.ITag[];\r\n\r\n    /**\r\n     * Decompose query DTO.\r\n     *\r\n     * If you configure this property to be `true`, the query DTO would be decomposed\r\n     * into individual query parameters per each property. Otherwise you set it to be\r\n     * `false`, the query DTO would be one object type which contains all of query\r\n     * parameters.\r\n     *\r\n     * @default false\r\n     */\r\n    decompose?: boolean;\r\n\r\n    /**\r\n     * Operation ID generator.\r\n     *\r\n     * @param props Properties of the API endpoint.\r\n     * @returns Operation ID.\r\n     */\r\n    operationId?(props: {\r\n      class: string;\r\n      function: string;\r\n      method: \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\r\n      path: string;\r\n    }): string;\r\n  }\r\n}\nMake nestia.config.ts file and run npx nestia e2e command.At first, create nestia.config.ts file through npx nestia init command. It would be placed on the top level directory of your NestJS backend project. For reference, tsconfig.json file also must be placed in the top level directory, too. After creation, configure the nestia.config.ts file referencing above example code and type definition.At least, you've to configure those three properties:\ninput: Accessor of controller classes\noutput: Path of output directory for SDK library\ne2e: Path of output directory for E2E test functions\nWhen you've completed above configuration, just run npx nestia e2e command. Then, SDK library would be generated into the $config.output directory, and E2E test functions would be generated into the $config.e2e directory, following your nestia.config.ts option.By the way, nestia.config.ts supports alternative options specifying the target controller classes instead of using the Module instance. If your backend application server does not have special configuration like setGlobalPrefix, enableVersioning and RouterModule, it is okay to specifying the target controller classes just by writing their file path like below.\nimport { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\nimport { FastifyAdapter } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule, new FastifyAdapter());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: [\"src/controllers\", \"src/fake/controllers\", \"src/test/controllers\"],\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: \"src/**/*.controller.ts\",\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: {\r\n    include: [\"src/controllers\"],\r\n    exclude: [\"src/**/*.fake.ts\"],\r\n  },\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;","customization#Customization":"import core from \"@nestia/core\";\r\nimport { DynamicExecutor } from \"@nestia/e2e\";\r\n\r\nimport { INestApplication } from \"@nestjs/common\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n\r\nasync function main(): Promise<void> {\r\n  const server: INestApplication = await NestFactory.create(\r\n    await core.DynamicModule.mount({\r\n      // follows your nestia.config.ts setting\r\n      controllers: {\r\n        input: [\"src/controllers\"],\r\n        exclude: [\"src/**/*.fake.ts\"],\r\n      },\r\n    }),\r\n  );\r\n  await server.listen(37_000);\r\n\r\n  const report: DynamicExecutor.IReport = await DynamicExecutor.validate({\r\n    prefix: \"test\",\r\n    parameters: () => [\r\n      {\r\n        host: \"http://127.0.0.1:37000\",\r\n      },\r\n    ],\r\n  })(`${__dirname}/features`);\r\n  await server.close();\r\n\r\n  const exceptions: Error[] = report.executions\r\n    .filter((exec) => exec.error !== null)\r\n    .map((exec) => exec.error!);\r\n  if (exceptions.length === 0) {\r\n    console.log(\"Success\");\r\n    console.log(\"Elapsed time\", report.time.toLocaleString(), `ms`);\r\n  } else {\r\n    for (const exp of exceptions) console.log(exp);\r\n    console.log(\"Failed\");\r\n    console.log(\"Elapsed time\", report.time.toLocaleString(), `ms`);\r\n    process.exit(-1);\r\n  }\r\n}\r\nmain().catch((exp) => {\r\n  console.log(exp);\r\n  process.exit(-1);\r\n});\nNothing be specified, customize by yourself.When you generate e2e test functions through npx nestia e2e command, such index.ts file would be placed into the top level directory of test program. As you can see, the initial e2e test program only opens your NestJS backend server only with path of controllers with port number 37,000.However, it may not fully meet your requirements. For example, you may connect to a database server, and also need to configure DI (Dependency Injection) classes, too. You've to configure those things by yourself. @nestia/sdk can analyzes your backend server in the compilation level, but unable to reproduce such customizations.\nimport { Controller } from \"@nestjs/common\";\r\nimport typia, { tags } from \"typia\";\r\n\r\nimport core from \"@nestia/core\";\r\n\r\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\r\n\r\n@Controller(\"bbs/articles/:section\")\r\nexport class BbsArticlesController {\r\n  /**\r\n   * Store a new article.\r\n   *\r\n   * @param section Section code\r\n   * @param input Content to store\r\n   * @returns Newly archived article\r\n   */\r\n  @core.TypedRoute.Post()\r\n  public async store(\r\n    @core.TypedParam(\"section\") section: string,\r\n    @core.TypedBody() input: IBbsArticle.IStore,\r\n  ): Promise<IBbsArticle> {\r\n    return {\r\n      ...typia.random<IBbsArticle>(),\r\n      section,\r\n      ...input,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Update an article.\r\n   *\r\n   * @param section Section code\r\n   * @param id Target article ID\r\n   * @param input Content to update\r\n   * @returns Updated content\r\n   */\r\n  @core.TypedRoute.Put(\":id\")\r\n  public async update(\r\n    @core.TypedParam(\"section\") section: string,\r\n    @core.TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\r\n    @core.TypedBody() input: IBbsArticle.IStore,\r\n  ): Promise<IBbsArticle> {\r\n    return {\r\n      ...typia.random<IBbsArticle>(),\r\n      id,\r\n      section,\r\n      ...input,\r\n    };\r\n  }\r\n}\n/**\r\n * @packageDocumentation\r\n * @module api.functional.bbs.articles\r\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\r\n */\r\n//================================================================\r\nimport type { IConnection, Primitive } from \"@nestia/fetcher\";\r\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\r\nimport type { Format } from \"typia/lib/tags/Format\";\r\n\r\nimport type { IBbsArticle } from \"../../../structures/IBbsArticle\";\r\n\r\n/**\r\n * Store a new article.\r\n *\r\n * @param section Section code\r\n * @param input Content to store\r\n * @returns Newly archived article\r\n *\r\n * @controller [object Object]\r\n * @path POST /bbs/articles/:section\r\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\r\n */\r\nexport async function store(\r\n  connection: IConnection,\r\n  section: string,\r\n  input: store.Input,\r\n): Promise<store.Output> {\r\n  return PlainFetcher.fetch(\r\n    {\r\n      ...connection,\r\n      headers: {\r\n        ...connection.headers,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n    },\r\n    {\r\n      ...store.METADATA,\r\n      path: store.path(section),\r\n    } as const,\r\n    input,\r\n  );\r\n}\r\nexport namespace store {\r\n  export type Input = Primitive<IBbsArticle.IStore>;\r\n  export type Output = Primitive<IBbsArticle>;\r\n\r\n  export const METADATA = {\r\n    method: \"POST\",\r\n    path: \"/bbs/articles/:section\",\r\n    request: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    response: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    status: null,\r\n  } as const;\r\n\r\n  export const path = (section: string): string => {\r\n    return `/bbs/articles/${encodeURIComponent(section ?? \"null\")}`;\r\n  };\r\n}\r\n\r\n/**\r\n * Update an article.\r\n *\r\n * @param section Section code\r\n * @param id Target article ID\r\n * @param input Content to update\r\n * @returns Updated content\r\n *\r\n * @controller [object Object]\r\n * @path PUT /bbs/articles/:section/:id\r\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\r\n */\r\nexport async function update(\r\n  connection: IConnection,\r\n  section: string,\r\n  id: string & Format<\"uuid\">,\r\n  input: update.Input,\r\n): Promise<update.Output> {\r\n  return PlainFetcher.fetch(\r\n    {\r\n      ...connection,\r\n      headers: {\r\n        ...connection.headers,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n    },\r\n    {\r\n      ...update.METADATA,\r\n      path: update.path(section, id),\r\n    } as const,\r\n    input,\r\n  );\r\n}\r\nexport namespace update {\r\n  export type Input = Primitive<IBbsArticle.IStore>;\r\n  export type Output = Primitive<IBbsArticle>;\r\n\r\n  export const METADATA = {\r\n    method: \"PUT\",\r\n    path: \"/bbs/articles/:section/:id\",\r\n    request: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    response: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    status: null,\r\n  } as const;\r\n\r\n  export const path = (\r\n    section: string,\r\n    id: string & Format<\"uuid\">,\r\n  ): string => {\r\n    return `/bbs/articles/${encodeURIComponent(\r\n      section ?? \"null\",\r\n    )}/${encodeURIComponent(id ?? \"null\")}`;\r\n  };\r\n}\nimport type { IConnection, Primitive } from \"@nestia/fetcher\";\r\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\r\nimport type { Format } from \"typia/lib/tags/Format\";\r\n\r\nimport api from \"../../../../src/api\";\r\nimport type { IBbsArticle } from \"../../../../src/api/structures/IBbsArticle\";\r\n\r\nexport const test_api_bbs_articles_update = async (\r\n  connection: api.IConnection,\r\n): Promise<void> => {\r\n  const output = await api.functional.bbs.articles.update(\r\n    connection,\r\n    typia.random<string>(),\r\n    typia.random<string & Format<\"uuid\">>(),\r\n    typia.random<Primitive<IBbsArticle.IStore>>(),\r\n  );\r\n  typia.assert(output);\r\n};\nYou also need to customize each e2e test functions.When you run npx nestia e2e command, every e2e functions would be placed into $config.e2e/features/api/automated directory. Also, automatically generated e2e test functions are composing parameters through typia.random<T>() function.If your NestJS backend server development has not been completed, and your API functions are in the mock-up level, such random parameter composition would not be problem. Otherwise your API functions are enoughly completed, such random parameter composition may occur logic error.Therefore, you also need to customize automatically generated e2e test functions. Move each e2e test files from the $config.e2e/features/api/automated directory to somewhere else, and customize those e2e test functions to be suitable for your domain logics."}},"/docs/sdk/simulate":{"title":"Guide Documents > S/W Development Kit > Mockup Simulator","data":{"outline#Outline":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n      //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  simulate: true, // supports simulation mode\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nnpx nestia sdk\r\nnpx nestia sdk --config nestia.config.ts --project tsconfig.json\n/**\r\n * Update an article.\r\n *\r\n * @param section Section code\r\n * @param id Target article ID\r\n * @param input Content to update\r\n * @returns Updated content\r\n *\r\n * @controller BbsArticlesController.update()\r\n * @path PUT /bbs/:section/articles/:id\r\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\r\n */\r\nexport async function update(\r\n  connection: IConnection,\r\n  section: string,\r\n  id: string & Format<\"uuid\">,\r\n  input: update.Input,\r\n): Promise<update.Output> {\r\n  return !!connection.simulate\r\n    ? update.simulate(connection, section, id, input)\r\n    : PlainFetcher.fetch(\r\n        {\r\n          ...connection,\r\n          headers: {\r\n            ...connection.headers,\r\n            \"Content-Type\": \"application/json\",\r\n          },\r\n        },\r\n        {\r\n          ...update.METADATA,\r\n          path: update.path(section, id),\r\n        } as const,\r\n        input,\r\n      );\r\n}\r\nexport namespace update {\r\n  export type Input = Primitive<IBbsArticle.IStore>;\r\n  export type Output = Primitive<IBbsArticle>;\r\n\r\n  export const METADATA = {\r\n    method: \"PUT\",\r\n    path: \"/bbs/articles/:section/:id\",\r\n    request: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    response: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    status: null,\r\n  } as const;\r\n\r\n  export const path = (\r\n    section: string,\r\n    id: string & Format<\"uuid\">,\r\n  ): string => {\r\n    return `/bbs/${encodeURIComponent(\r\n      section ?? \"null\",\r\n    )}/articles/${encodeURIComponent(id ?? \"null\")}`;\r\n  };\r\n\r\n  export const random = (g?: Partial<typia.IRandomGenerator>): Output =>\r\n    typia.random<Output>(g);\r\n\r\n  export const simulate = async (\r\n    connection: IConnection,\r\n    section: string,\r\n    id: string & Format<\"uuid\">,\r\n    input: update.Input,\r\n  ): Promise<Output> => {\r\n    const assert = NestiaSimulator.assert({\r\n      method: METHOD,\r\n      host: connection.host,\r\n      path: path(section, id),\r\n    });\r\n    assert.param(\"section\")(\"string\")(() => typia.assert(section));\r\n    assert.param(\"id\")(\"uuid\")(() => typia.assert(id));\r\n    assert.body(() => typia.assert(input));\r\n    return random(\r\n      typeof connection.simulate === \"object\" && connection.simulate !== null\r\n        ? connection.simulate\r\n        : undefined,\r\n    );\r\n  };\r\n}\nNestia SDK library supports Mockup simulator.When generating SDK library, if you configure simulate property of nestia.config.file to be true, newly generated SDK library will support mockup simulation mode for frontend developers. With the mockup simulator, frontend developers can simulate NestJS backend server with internal mock functions, instead of connecting to the real backend server.Therefore, with the mockup simulator, frontend development can be started even when the backend server is not ready yet. Mockup simulator of Nestia SDK will replace the real backend server, validating request data, and returning mockup data as response.Within framework of backend developers, they also do not need to be suffered from the mock-up data composition. Also, as nestia can automatically generate e2e test functions, backend developers can concentrated only on the business logic.","configuration#Configuration":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  simulate: true, // supports simulation mode\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport type { INestApplication } from \"@nestjs/common\";\r\nimport type { OpenApi } from \"@samchon/openapi\";\r\n\r\n/**\r\n * Definition for the `nestia.config.ts` file.\r\n *\r\n * @author Jeongho Nam - https://github.com/samchon\r\n */\r\nexport interface INestiaConfig {\r\n  /**\r\n   * Accessor of controller classes.\r\n   *\r\n   * You can specify it within two ways\r\n   *\r\n   *   - Asynchronous function returning `INestApplication` instance\r\n   *   - Specify the path or directory of controller class files\r\n   */\r\n  input:\r\n    | (() => Promise<INestApplication>)\r\n    | INestiaConfig.IInput\r\n    | string[]\r\n    | string;\r\n\r\n  /**\r\n   * Output directory that SDK would be placed in.\r\n   *\r\n   * If not configured, you can't build the SDK library.\r\n   */\r\n  output?: string;\r\n\r\n  /**\r\n   * Building `swagger.json` is also possible.\r\n   *\r\n   * If not specified, you can't build the `swagger.json`.\r\n   */\r\n  swagger?: INestiaConfig.ISwaggerConfig;\r\n\r\n  /**\r\n   * Target directory that SDK distribution files would be placed in.\r\n   *\r\n   * If you configure this property and runs `npx nestia sdk` command,\r\n   * distribution environments for the SDK library would be generated.\r\n   *\r\n   * After the SDK library generation, move to the `distribute` directory,\r\n   * and runs `npm publish` command, then you can share SDK library with\r\n   * other client (frontend) developers.\r\n   *\r\n   * Recommend to use `\"packages/api\"` value.\r\n   */\r\n  distribute?: string;\r\n\r\n  /**\r\n   * Allow simulation mode.\r\n   *\r\n   * If you configure this property to be `true`, the SDK library would be contain\r\n   * simulation mode. In the simulation mode, the SDK library would not communicate\r\n   * with the real backend server, but just returns random mock-up data\r\n   * with requestion data validation.\r\n   *\r\n   * For reference, random mock-up data would be generated by `typia.random<T>()`\r\n   * function.\r\n   *\r\n   * @default false\r\n   */\r\n  simulate?: boolean;\r\n\r\n  /**\r\n   * Target directory that e2e test functions would be placed in.\r\n   *\r\n   * If you configure this property and runs `npx nestia e2e` command,\r\n   * `@nestia/sdk` will analyze your NestJS backend server code, and\r\n   * generates e2e test functions for every API endpoints.\r\n   *\r\n   * If not configured, you can't run `npx nestia e2e` command.\r\n   */\r\n  e2e?: string;\r\n\r\n  /**\r\n   * Whether to use propagation mode or not.\r\n   *\r\n   * If being configured, interaction functions of the SDK library would\r\n   * perform the propagation mode. The propagation mode means that never\r\n   * throwing exception even when status code is not 200 (or 201), but just\r\n   * returning the {@link IPropagation} typed instance, which can specify its body\r\n   * type through discriminated union determined by status code.\r\n   *\r\n   * @default false\r\n   */\r\n  propagate?: boolean;\r\n\r\n  /**\r\n   * Whether to clone DTO structures or not.\r\n   *\r\n   * If being configured, all of DTOs used in the backend server would be cloned\r\n   * into the `structures` directory, and the SDK library would be refer to the\r\n   * cloned DTOs instead of the original.\r\n   *\r\n   * @default false\r\n   */\r\n  clone?: boolean;\r\n\r\n  /**\r\n   * Whether to wrap DTO by primitive type.\r\n   *\r\n   * If you don't configure this property as `false`, all of DTOs in the\r\n   * SDK library would be automatically wrapped by {@link Primitive} type.\r\n   *\r\n   * For refenrece, if a DTO type be capsuled by the {@link Primitive} type,\r\n   * all of methods in the DTO type would be automatically erased. Also, if\r\n   * the DTO has a `toJSON()` method, the DTO type would be automatically\r\n   * converted to return type of the `toJSON()` method.\r\n   *\r\n   * @default true\r\n   */\r\n  primitive?: boolean;\r\n\r\n  /**\r\n   * Whether to assert parameter types or not.\r\n   *\r\n   * If you configure this property to be `true`, all of the function\r\n   * parameters of SDK library would be checked through\r\n   * [`typia.assert<T>()` function](https://typia.io/docs/validators/assert/).\r\n   *\r\n   * This option would make your SDK library compilation time a little bit slower,\r\n   * but would enahcne the type safety even in the runtime level.\r\n   *\r\n   * @default false\r\n   */\r\n  assert?: boolean;\r\n\r\n  /**\r\n   * Whether to optimize JSON string conversion 10x faster or not.\r\n   *\r\n   * If you configure this property to be `true`, the SDK library would utilize the\r\n   * [`typia.assertStringify<T>() function`](https://github.com/samchon/typia#enhanced-json)\r\n   * to boost up JSON serialization speed and ensure type safety.\r\n   *\r\n   * This option would make your SDK library compilation time a little bit slower,\r\n   * but would enhance JSON serialization speed 10x faster. Also, it can ensure type\r\n   * safety even in the runtime level.\r\n   *\r\n   * @default false\r\n   */\r\n  json?: boolean;\r\n}\r\nexport namespace INestiaConfig {\r\n  /**\r\n   * List of files or directories to include or exclude to specifying the NestJS\r\n   * controllers.\r\n   */\r\n  export interface IInput {\r\n    /**\r\n     * List of files or directories containing the NestJS controller classes.\r\n     */\r\n    include: string[];\r\n\r\n    /**\r\n     * List of files or directories to be excluded.\r\n     */\r\n    exclude?: string[];\r\n  }\r\n\r\n  /**\r\n   * Building `swagger.json` is also possible.\r\n   */\r\n  export interface ISwaggerConfig {\r\n    /**\r\n     * Output path of the `swagger.json`.\r\n     *\r\n     * If you've configured only directory, the file name would be the `swagger.json`.\r\n     * Otherwise you've configured the full path with file name and extension, the\r\n     * `swagger.json` file would be renamed to it.\r\n     */\r\n    output: string;\r\n\r\n    /**\r\n     * OpenAPI version.\r\n     *\r\n     * If you configure this property to be `2.0` or `3.0`, the newly generated\r\n     * `swagger.json` file would follow the specified OpenAPI version. The newly\r\n     * generated `swagger.json` file would be downgraded from the OpenAPI v3.1\r\n     * specification by {@link OpenApi.downgrade} method.\r\n     *\r\n     * @default 3.1\r\n     */\r\n    openapi?: \"2.0\" | \"3.0\" | \"3.1\";\r\n\r\n    /**\r\n     * API information.\r\n     *\r\n     * If omitted, `package.json` content would be used instead.\r\n     */\r\n    info?: Partial<OpenApi.IDocument.IServer>;\r\n\r\n    /**\r\n     * List of server addresses.\r\n     */\r\n    servers?: OpenApi.IServer[];\r\n\r\n    /**\r\n     * Security schemes.\r\n     *\r\n     * When generating `swagger.json` file through `nestia`, if your controllers or\r\n     * theirs methods have a security key which is not enrolled in here property,\r\n     * it would be an error.\r\n     */\r\n    security?: Record<string, OpenApi.ISecurityScheme>;\r\n\r\n    /**\r\n     * List of tag names with description.\r\n     *\r\n     * It is possible to omit this property or skip some tag name even if\r\n     * the tag name is used in the API routes. In that case, the tag name\r\n     * would be used without description.\r\n     *\r\n     * Of course, if you've written a comment like `@tag {name} {description}`,\r\n     * you can entirely replace this property specification.\r\n     */\r\n    tags?: OpenApi.IDocument.ITag[];\r\n\r\n    /**\r\n     * Decompose query DTO.\r\n     *\r\n     * If you configure this property to be `true`, the query DTO would be decomposed\r\n     * into individual query parameters per each property. Otherwise you set it to be\r\n     * `false`, the query DTO would be one object type which contains all of query\r\n     * parameters.\r\n     *\r\n     * @default false\r\n     */\r\n    decompose?: boolean;\r\n\r\n    /**\r\n     * Operation ID generator.\r\n     *\r\n     * @param props Properties of the API endpoint.\r\n     * @returns Operation ID.\r\n     */\r\n    operationId?(props: {\r\n      class: string;\r\n      function: string;\r\n      method: \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\r\n      path: string;\r\n    }): string;\r\n  }\r\n}\nMake nestia.config.ts file and run npx nestia sdk command.At first, create nestia.config.ts file through npx nestia init command. It would be placed on the top level directory of your NestJS backend project. For reference, tsconfig.json file also must be placed in the top level directory, too. After creation, configure the nestia.config.ts file referencing above example code and type definition.At least, you've to configure those three properties. Also, if you've decided to support mockup simulator for frontend developers, I recommend you to configure two properties more, for automatic e2e functions generation and SDK library distribution.\nEssential\ninput: Accessor of controller classes\noutput: Path of output directory for SDK library\nsimulate: Whether to support simulator or not\nRecommended\ne2e: Path of output directory for E2E test functions\ndistribute: Target directory for SDK library distribution\nWhen you've completed above configuration, just run npx nestia sdk command. Then, SDK library would be generated into the $config.output directory, with simulation mode supporting. If you want to generate e2e functions automatically, run npx nestia e2e command after.By the way, nestia.config.ts supports alternative options specifying the target controller classes instead of using the Module instance. If your backend application server does not have special configuration like setGlobalPrefix, enableVersioning and RouterModule, it is okay to specifying the target controller classes just by writing their file path like below.\nimport { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  simulate: true,\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\nimport { FastifyAdapter } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule, new FastifyAdpator());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  simulate: true,\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: [\"src/controllers\", \"src/fake/controllers\", \"src/test/controllers\"],\r\n  output: \"src/api\",\r\n  simulate: true,\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: \"src/**/*.controller.ts\",\r\n  output: \"src/api\",\r\n  simulate: true,\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport { INestiaConfig } from \"@nestia/sdk\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: {\r\n    include: [\"src/controllers\"],\r\n    exclude: [\"src/**/*.fake.ts\"],\r\n  },\r\n  output: \"src/api\",\r\n  simulate: true,\r\n  distribute: \"packages/api\",\r\n  e2e: \"test\",\r\n};\r\nexport default NESTIA_CONFIG;","code-analysis#Code Analysis":"/**\r\n * Update an article.\r\n *\r\n * @param section Section code\r\n * @param id Target article ID\r\n * @param input Content to update\r\n * @returns Updated content\r\n *\r\n * @controller BbsArticlesController.update()\r\n * @path PUT /bbs/:section/articles/:id\r\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\r\n */\r\nexport async function update(\r\n  connection: IConnection,\r\n  section: string,\r\n  id: string & Format<\"uuid\">,\r\n  input: update.Input,\r\n): Promise<update.Output> {\r\n  return !!connection.simulate\r\n    ? update.simulate(connection, section, id, input)\r\n    : PlainFetcher.fetch(\r\n        {\r\n          ...connection,\r\n          headers: {\r\n            ...connection.headers,\r\n            \"Content-Type\": \"application/json\",\r\n          },\r\n        },\r\n        {\r\n          ...update.METADATA,\r\n          path: update.path(section, id),\r\n        } as const,\r\n        input,\r\n      );\r\n}\r\nexport namespace update {\r\n  export type Input = Primitive<IBbsArticle.IStore>;\r\n  export type Output = Primitive<IBbsArticle>;\r\n\r\n  export const METADATA = {\r\n    method: \"PUT\",\r\n    path: \"/bbs/articles/:section/:id\",\r\n    request: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    response: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    status: null,\r\n  } as const;\r\n\r\n  export const path = (\r\n    section: string,\r\n    id: string & Format<\"uuid\">,\r\n  ): string => {\r\n    return `/bbs/${encodeURIComponent(\r\n      section ?? \"null\",\r\n    )}/articles/${encodeURIComponent(id ?? \"null\")}`;\r\n  };\r\n\r\n  export const random = (g?: Partial<typia.IRandomGenerator>): Output =>\r\n    typia.random<Output>(g);\r\n\r\n  export const simulate = async (\r\n    connection: IConnection,\r\n    section: string,\r\n    id: string & Format<\"uuid\">,\r\n    input: update.Input,\r\n  ): Promise<Output> => {\r\n    const assert = NestiaSimulator.assert({\r\n      method: METHOD,\r\n      host: connection.host,\r\n      path: path(section, id),\r\n    });\r\n    assert.param(\"section\")(() => typia.assert(section));\r\n    assert.param(\"id\")(() => typia.assert(id));\r\n    assert.body(() => typia.assert(input));\r\n    return random(\r\n      typeof connection.simulate === \"object\" && connection.simulate !== null\r\n        ? connection.simulate\r\n        : undefined,\r\n    );\r\n  };\r\n}\nimport { HttpError } from \"@nestia/fetcher\";\r\n\r\nimport typia from \"typia\";\r\n\r\nexport namespace NestiaSimulator {\r\n  export interface IProps {\r\n    host: string;\r\n    path: string;\r\n    method: \"GET\" | \"POST\" | \"PATCH\" | \"PUT\" | \"DELETE\";\r\n    contentType: string;\r\n  }\r\n\r\n  export const assert = (props: IProps) => {\r\n    return {\r\n      param: param(props),\r\n      query: query(props),\r\n      body: body(props),\r\n    };\r\n  };\r\n  const param =\r\n    (props: IProps) =>\r\n    (name: string) =>\r\n    <T>(task: () => T): void => {\r\n      validate((exp) => `URL parameter \"${name}\" is not ${exp.expected} type.`)(\r\n        props,\r\n      )(task);\r\n    };\r\n\r\n  const query =\r\n    (props: IProps) =>\r\n    <T>(task: () => T): void =>\r\n      validate(\r\n        () => \"Request query parameters are not following the promised type.\",\r\n      )(props)(task);\r\n\r\n  const body =\r\n    (props: IProps) =>\r\n    <T>(task: () => T): void =>\r\n      validate(() => \"Request body is not following the promised type.\")(props)(\r\n        task,\r\n      );\r\n\r\n  const validate =\r\n    (message: (exp: typia.TypeGuardError) => string, path?: string) =>\r\n    (props: IProps) =>\r\n    <T>(task: () => T): void => {\r\n      try {\r\n        task();\r\n      } catch (exp) {\r\n        if (typia.is<typia.TypeGuardError>(exp))\r\n          throw new HttpError(\r\n            props.method,\r\n            props.host + props.path,\r\n            400,\r\n            {\r\n              \"Content-Type\": props.contentType,\r\n            },\r\n            JSON.stringify({\r\n              method: exp.method,\r\n              path: path ?? exp.path,\r\n              expected: exp.expected,\r\n              value: exp.value,\r\n              message: message(exp),\r\n            }),\r\n          );\r\n        throw exp;\r\n      }\r\n    };\r\n}\nLet's read generated SDK library code, and understand which features are supportedAt first, you can find that mock-up data is composed by typia.random<T>() function. Also, simulator function validates path parameters and request body data through typia.assert<T>() function. If the validation fails, 400 status error would be thrown.At last, if frontend developer turns off simulation mode by configuring IConnection.simulate value to be false, the SDK library stops NestJS backend server simulating, and just start communicating with the real backend server."}},"/docs/sdk":{"title":"Guide Documents > S/W Development Kit","data":{"outline#Outline":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n};\r\nexport default NESTIA_CONFIG;\nnpx nestia sdk\n/**\r\n * Update an article.\r\n *\r\n * @param section Section code\r\n * @param id Target article ID\r\n * @param input Content to update\r\n * @returns Updated content\r\n *\r\n * @controller BbsArticlesController.update()\r\n * @path PUT /bbs/:section/articles/:id\r\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\r\n */\r\nexport async function update(\r\n  connection: IConnection,\r\n  section: string,\r\n  id: string & Format<\"uuid\">,\r\n  input: update.Input,\r\n): Promise<update.Output> {\r\n  return PlainFetcher.fetch(\r\n    {\r\n      ...connection,\r\n      headers: {\r\n        ...connection.headers,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n    },\r\n    {\r\n      ...update.METADATA,\r\n      path: update.path(section, id),\r\n    } as const,\r\n    input,\r\n  );\r\n}\r\nexport namespace update {\r\n  export type Input = Primitive<IBbsArticle.IStore>;\r\n  export type Output = Primitive<IBbsArticle>;\r\n\r\n  export const METADATA = {\r\n    method: \"PUT\",\r\n    path: \"/bbs/articles/:section/:id\",\r\n    request: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    response: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    status: null,\r\n  } as const;\r\n\r\n  export const path = (\r\n    section: string,\r\n    id: string & Format<\"uuid\">,\r\n  ): string => {\r\n    return `/bbs/articles/${encodeURIComponent(\r\n      section ?? \"null\",\r\n    )}/${encodeURIComponent(id ?? \"null\")}`;\r\n  };\r\n}\nCollection of typed fetch functions with DTO structures.Configure nestia.config.ts file and run npx nestia sdk command.Then, @nestia/sdk will analyze your NestJS backend server code, and generate SDK (Software Development Kit) library composed with. The newly generated SDK library would be composed with DTO and fetch functions with type definitions following your NestJS server.With the SDK library composed with RPC (Remote Procedure Call) functions, you can easily develop e2e test program. Also, frontend developers can utilize the SDK library to interact with your NestJS backend server, much safely and conveniently.If you can't imagine how the SDK library works, then look at the gif image of below. Left side is the NestJS backend server program, and right side is the Frontend program interacting with your server. Isn't it look like much more convenient and safer than before Swagger Documents case?\nLeft is NestJS server code, and right is client (frontend) code utilizing SDK","application-module#Application Module":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  distribute: \"packages/api\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport type { INestApplication } from \"@nestjs/common\";\r\nimport type { OpenApi } from \"@samchon/openapi\";\r\n\r\n/**\r\n * Definition for the `nestia.config.ts` file.\r\n *\r\n * @author Jeongho Nam - https://github.com/samchon\r\n */\r\nexport interface INestiaConfig {\r\n  /**\r\n   * Accessor of controller classes.\r\n   *\r\n   * You can specify it within two ways\r\n   *\r\n   *   - Asynchronous function returning `INestApplication` instance\r\n   *   - Specify the path or directory of controller class files\r\n   */\r\n  input:\r\n    | (() => Promise<INestApplication>)\r\n    | INestiaConfig.IInput\r\n    | string[]\r\n    | string;\r\n\r\n  /**\r\n   * Output directory that SDK would be placed in.\r\n   *\r\n   * If not configured, you can't build the SDK library.\r\n   */\r\n  output?: string;\r\n\r\n  /**\r\n   * Building `swagger.json` is also possible.\r\n   *\r\n   * If not specified, you can't build the `swagger.json`.\r\n   */\r\n  swagger?: INestiaConfig.ISwaggerConfig;\r\n\r\n  /**\r\n   * Target directory that SDK distribution files would be placed in.\r\n   *\r\n   * If you configure this property and runs `npx nestia sdk` command,\r\n   * distribution environments for the SDK library would be generated.\r\n   *\r\n   * After the SDK library generation, move to the `distribute` directory,\r\n   * and runs `npm publish` command, then you can share SDK library with\r\n   * other client (frontend) developers.\r\n   *\r\n   * Recommend to use `\"packages/api\"` value.\r\n   */\r\n  distribute?: string;\r\n\r\n  /**\r\n   * Allow simulation mode.\r\n   *\r\n   * If you configure this property to be `true`, the SDK library would be contain\r\n   * simulation mode. In the simulation mode, the SDK library would not communicate\r\n   * with the real backend server, but just returns random mock-up data\r\n   * with requestion data validation.\r\n   *\r\n   * For reference, random mock-up data would be generated by `typia.random<T>()`\r\n   * function.\r\n   *\r\n   * @default false\r\n   */\r\n  simulate?: boolean;\r\n\r\n  /**\r\n   * Target directory that e2e test functions would be placed in.\r\n   *\r\n   * If you configure this property and runs `npx nestia e2e` command,\r\n   * `@nestia/sdk` will analyze your NestJS backend server code, and\r\n   * generates e2e test functions for every API endpoints.\r\n   *\r\n   * If not configured, you can't run `npx nestia e2e` command.\r\n   */\r\n  e2e?: string;\r\n\r\n  /**\r\n   * Whether to use propagation mode or not.\r\n   *\r\n   * If being configured, interaction functions of the SDK library would\r\n   * perform the propagation mode. The propagation mode means that never\r\n   * throwing exception even when status code is not 200 (or 201), but just\r\n   * returning the {@link IPropagation} typed instance, which can specify its body\r\n   * type through discriminated union determined by status code.\r\n   *\r\n   * @default false\r\n   */\r\n  propagate?: boolean;\r\n\r\n  /**\r\n   * Whether to clone DTO structures or not.\r\n   *\r\n   * If being configured, all of DTOs used in the backend server would be cloned\r\n   * into the `structures` directory, and the SDK library would be refer to the\r\n   * cloned DTOs instead of the original.\r\n   *\r\n   * @default false\r\n   */\r\n  clone?: boolean;\r\n\r\n  /**\r\n   * Whether to wrap DTO by primitive type.\r\n   *\r\n   * If you don't configure this property as `false`, all of DTOs in the\r\n   * SDK library would be automatically wrapped by {@link Primitive} type.\r\n   *\r\n   * For refenrece, if a DTO type be capsuled by the {@link Primitive} type,\r\n   * all of methods in the DTO type would be automatically erased. Also, if\r\n   * the DTO has a `toJSON()` method, the DTO type would be automatically\r\n   * converted to return type of the `toJSON()` method.\r\n   *\r\n   * @default true\r\n   */\r\n  primitive?: boolean;\r\n\r\n  /**\r\n   * Whether to assert parameter types or not.\r\n   *\r\n   * If you configure this property to be `true`, all of the function\r\n   * parameters of SDK library would be checked through\r\n   * [`typia.assert<T>()` function](https://typia.io/docs/validators/assert/).\r\n   *\r\n   * This option would make your SDK library compilation time a little bit slower,\r\n   * but would enahcne the type safety even in the runtime level.\r\n   *\r\n   * @default false\r\n   */\r\n  assert?: boolean;\r\n\r\n  /**\r\n   * Whether to optimize JSON string conversion 10x faster or not.\r\n   *\r\n   * If you configure this property to be `true`, the SDK library would utilize the\r\n   * [`typia.assertStringify<T>() function`](https://github.com/samchon/typia#enhanced-json)\r\n   * to boost up JSON serialization speed and ensure type safety.\r\n   *\r\n   * This option would make your SDK library compilation time a little bit slower,\r\n   * but would enhance JSON serialization speed 10x faster. Also, it can ensure type\r\n   * safety even in the runtime level.\r\n   *\r\n   * @default false\r\n   */\r\n  json?: boolean;\r\n}\r\nexport namespace INestiaConfig {\r\n  /**\r\n   * List of files or directories to include or exclude to specifying the NestJS\r\n   * controllers.\r\n   */\r\n  export interface IInput {\r\n    /**\r\n     * List of files or directories containing the NestJS controller classes.\r\n     */\r\n    include: string[];\r\n\r\n    /**\r\n     * List of files or directories to be excluded.\r\n     */\r\n    exclude?: string[];\r\n  }\r\n\r\n  /**\r\n   * Building `swagger.json` is also possible.\r\n   */\r\n  export interface ISwaggerConfig {\r\n    /**\r\n     * Output path of the `swagger.json`.\r\n     *\r\n     * If you've configured only directory, the file name would be the `swagger.json`.\r\n     * Otherwise you've configured the full path with file name and extension, the\r\n     * `swagger.json` file would be renamed to it.\r\n     */\r\n    output: string;\r\n\r\n    /**\r\n     * OpenAPI version.\r\n     *\r\n     * If you configure this property to be `2.0` or `3.0`, the newly generated\r\n     * `swagger.json` file would follow the specified OpenAPI version. The newly\r\n     * generated `swagger.json` file would be downgraded from the OpenAPI v3.1\r\n     * specification by {@link OpenApi.downgrade} method.\r\n     *\r\n     * @default 3.1\r\n     */\r\n    openapi?: \"2.0\" | \"3.0\" | \"3.1\";\r\n\r\n    /**\r\n     * API information.\r\n     *\r\n     * If omitted, `package.json` content would be used instead.\r\n     */\r\n    info?: Partial<OpenApi.IDocument.IInfo>;\r\n\r\n    /**\r\n     * List of server addresses.\r\n     */\r\n    servers?: OpenApi.IServer[];\r\n\r\n    /**\r\n     * Security schemes.\r\n     *\r\n     * When generating `swagger.json` file through `nestia`, if your controllers or\r\n     * theirs methods have a security key which is not enrolled in here property,\r\n     * it would be an error.\r\n     */\r\n    security?: Record<string, OpenApi.ISecurityScheme>;\r\n\r\n    /**\r\n     * List of tag names with description.\r\n     *\r\n     * It is possible to omit this property or skip some tag name even if\r\n     * the tag name is used in the API routes. In that case, the tag name\r\n     * would be used without description.\r\n     *\r\n     * Of course, if you've written a comment like `@tag {name} {description}`,\r\n     * you can entirely replace this property specification.\r\n     */\r\n    tags?: OpenApi.IDocument.ITag[];\r\n\r\n    /**\r\n     * Decompose query DTO.\r\n     *\r\n     * If you configure this property to be `true`, the query DTO would be decomposed\r\n     * into individual query parameters per each property. Otherwise you set it to be\r\n     * `false`, the query DTO would be one object type which contains all of query\r\n     * parameters.\r\n     *\r\n     * @default false\r\n     */\r\n    decompose?: boolean;\r\n\r\n    /**\r\n     * Operation ID generator.\r\n     *\r\n     * @param props Properties of the API endpoint.\r\n     * @returns Operation ID.\r\n     */\r\n    operationId?(props: {\r\n      class: string;\r\n      function: string;\r\n      method: \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\r\n      path: string;\r\n    }): string;\r\n  }\r\n}\nMake nestia.config.ts file and run npx nestia sdk command.At first, create nestia.config.ts file through npx nestia init command. It would be placed on the top level directory of your NestJS backend project. For reference, tsconfig.json file also must be placed in the top level directory, too. After creation, configure the nestia.config.ts file referencing above example code and type definition.At least, you've to configure those two properties:\ninput: Accessor of controller classes\noutput: Path of output directory for SDK library\nWhen you've completed above configuration, just run npx nestia sdk command. Then, SDK library would be newly generated, and placed into the $config.output directory following your nestia.config.ts configuration.","clone-mode#Clone Mode":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\r\n \r\nimport { YourModule } from \"./src/YourModule\";\r\n \r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  clone: true,\r\n  distribute: \"packages/api\",\r\n};\r\nexport default NESTIA_CONFIG;\nimport core from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport typia, { tags } from \"typia\";\r\n\r\n@Controller(\"bbs/articles/:section\")\r\nexport class TypedBodyControlleer {\r\n  @core.TypedRoute.Get()\r\n  public async index(\r\n    @core.TypedParam(\"section\") section: string,\r\n    @core.TypedQuery() query: IPage.IRequest,\r\n  ): Promise<IPage<IBbsArticle.ISummary>> {\r\n    const limit: number = query.limit ?? 100;\r\n    const current: number = query.page ?? 1;\r\n    const records: number = limit * (current + 3) + 5;\r\n\r\n    return {\r\n      pagination: {\r\n        current,\r\n        limit,\r\n        records,\r\n        pages: Math.ceil(records / limit),\r\n      },\r\n      data: new Array(limit).fill(\"\").map(() => ({\r\n        ...typia.random<IBbsArticle.ISummary>(),\r\n        section,\r\n      })),\r\n    };\r\n  }\r\n}\r\ninterface IPage<T> {\r\n  data: T[];\r\n  pagination: IPage.IPagination;\r\n}\r\nnamespace IPage {\r\n  export interface IRequest {\r\n    page?: null | (number & tags.Type<\"uint32\">);\r\n    limit?: null | (number & tags.Type<\"uint32\">);\r\n  }\r\n  export interface IPagination {\r\n    current: number & tags.Type<\"uint32\">;\r\n    limit: number & tags.Type<\"uint32\">;\r\n    records: number & tags.Type<\"uint32\">;\r\n    pages: number & tags.Type<\"uint32\">;\r\n  }\r\n}\r\n\r\nnamespace IBbsArticle {\r\n  export interface ISummary {\r\n    id: string & tags.Format<\"uuid\">;\r\n    section: string;\r\n    writer: string;\r\n    title: string & tags.MinLength<3> & tags.MaxLength<50>;\r\n    created_at: string & tags.Format<\"date-time\">;\r\n    /**\r\n     * @format date-time\r\n     */\r\n    updated_at: string;\r\n  }\r\n}\nexport namespace IPageIBbsArticle {\r\n  export type ISummary = {\r\n    data: IBbsArticle.ISummary[];\r\n    pagination: IPage.IPagination;\r\n  };\r\n}\r\nexport namespace IPage {\r\n  export type IRequest = {\r\n    page?: null | undefined | (number & Type<\"uint32\">);\r\n    limit?: null | undefined | (number & Type<\"uint32\">);\r\n  };\r\n  export type IPagination = {\r\n    current: number & Type<\"uint32\">;\r\n    limit: number & Type<\"uint32\">;\r\n    records: number & Type<\"uint32\">;\r\n    pages: number & Type<\"uint32\">;\r\n  };\r\n}\r\n\r\nexport namespace IBbsArticle {\r\n  export type ISummary = {\r\n    id: string & Format<\"uuid\">;\r\n    section: string;\r\n    writer: string;\r\n    title: string & MinLength<3> & MaxLength<50>;\r\n    created_at: string & Format<\"date-time\">;\r\n    updated_at: string & Format<\"date-time\">;\r\n  };\r\n}\nIf you configure clone property to be true in the nestia.config.ts file, all of DTO structures used in the backend server would be cloned into the structures directory, and the SDK library would be refer to the cloned DTO structures instead of the original.This clone mode is useful when you'd not separated DTO structures from the ORM models. When you're using TypeORM or Prisma, and returning the ORM generated instance directly in the controller without independent DTO structure definition, your SDK library requires the TypeORM or Prisma dependency install. By the dependency, client (frontend) developers may install the ORM library that they never need.In that case, it would better to remove the dependency by using this clone mode.","propagation-mode#Propagation Mode":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst config: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  output: \"src/api\",\r\n  propagate: true,\r\n  distribute: \"packages/api\",\r\n};\r\nexport default config;\nimport { Primitive } from \"./Primitive\";\r\n\r\n/**\r\n * Propagation type.\r\n *\r\n * `IPropagation` is a type gathering all possible status codes and their body\r\n * data types as a discriminated union type. You can specify the status code and\r\n * its body data type just by using conditional statement like below.\r\n *\r\n * ```typescript\r\n * type Output = IPropagation<{\r\n *    200: ISeller.IAuthorized;\r\n *    400: TypeGuardError.IProps;\r\n * >};\r\n *\r\n * const output: Output = await sdk.sellers.authenticate.join(input);\r\n * if (output.success) {\r\n *     // automatically casted to \"ISeller.IAuthorized\" type\r\n *     const authorized: ISeller.IAuthorized = output.data;\r\n * } else if (output.status === 400) {\r\n *     // automatically casted to \"TypeGuardError.IProps\" type\r\n *     const error: TypeGuardError.IProps = output.data;\r\n * } else {\r\n *     // unknown type when out of pre-defined status codes\r\n *     const result: unknown = output.data;\r\n * }\r\n * ```\r\n *\r\n * For reference, this `IPropagation` type is utilized by SDK library generated by\r\n * `@nestia/sdk`, when you've configured {@link INestiaConfig.propagate} to be `true`.\r\n * In that case, SDK functions generated by `@nestia/sdk` no more returns response DTO\r\n * typed data directly, but returns this `IPropagation` typed object instead.\r\n *\r\n * @template StatusMap Map of status code and its body data type.\r\n * @template Success Default success status code.\r\n * @author Jeongho Nam - https://github.com/samchon\r\n */\r\nexport type IPropagation<\r\n  StatusMap extends {\r\n    [P in IPropagation.Status]?: any;\r\n  },\r\n  Success extends number = 200 | 201,\r\n> =\r\n  | {\r\n      [P in keyof StatusMap]: IPropagation.IBranch<\r\n        P extends Success ? true : false,\r\n        P,\r\n        StatusMap[P]\r\n      >;\r\n    }[keyof StatusMap]\r\n  | IPropagation.IBranch<false, unknown, unknown>;\r\nexport namespace IPropagation {\r\n  /**\r\n   * Type of configurable status codes.\r\n   *\r\n   * The special characters like `2XX`, `3XX`, `4XX`, `5XX` are meaning the range\r\n   * of status codes. If `5XX` is specified, it means the status code is in the\r\n   * range of `500` to `599`.\r\n   */\r\n  export type Status = number | \"2XX\" | \"3XX\" | \"4XX\" | \"5XX\";\r\n\r\n  /**\r\n   * Branch type of propagation.\r\n   *\r\n   * `IPropagation.IBranch` is a branch type composing `IPropagation` type,\r\n   * which is gathering all possible status codes and their body data types\r\n   * as a union type.\r\n   */\r\n  export interface IBranch<Success extends boolean, StatusValue, BodyData> {\r\n    success: Success;\r\n    status: StatusValue extends \"2XX\" | \"3XX\" | \"4XX\" | \"5XX\"\r\n      ? StatusRange<StatusValue>\r\n      : StatusValue extends number\r\n      ? StatusValue\r\n      : never;\r\n    data: Primitive<BodyData>;\r\n    headers: Record<string, string | string[]>;\r\n  }\r\n\r\n  /**\r\n   * Range of status codes by the first digit.\r\n   */\r\n  export type StatusRange<T extends \"2XX\" | \"3XX\" | \"4XX\" | \"5XX\"> = T extends 0\r\n    ? IntRange<200, 299>\r\n    : T extends 3\r\n    ? IntRange<300, 399>\r\n    : T extends 4\r\n    ? IntRange<400, 499>\r\n    : IntRange<500, 599>;\r\n\r\n  type IntRange<F extends number, T extends number> = Exclude<\r\n    Enumerate<T>,\r\n    Enumerate<F>\r\n  >;\r\n\r\n  type Enumerate<\r\n    N extends number,\r\n    Acc extends number[] = [],\r\n  > = Acc[\"length\"] extends N\r\n    ? Acc[number]\r\n    : Enumerate<N, [...Acc, Acc[\"length\"]]>;\r\n}\nReturns IPropagation typed instance instead of throwing exception.When you configure propagate property of nestia.config.ts file, all of SDK functions generated by @nestia/sdk will perform propagation mode. The propagation mode means that never throwing exception (HttpError) even when response status code is not 200 (or 201), but just returning the IPropagation typed object, which can specify its body data type through discriminated union determined by status code.Looking at below code tabs one by one, then you may understand exactly, what the propagation mode is. As you can see from below example code, @TypedException() decorator function can be utilized to define the failure type with specific status code. Also, if returned status code is out of pre-defined, the IPropagation.data type would be automatically casted to unknown type.\nimport core from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport typia, { tags } from \"typia\";\r\n\r\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\r\n\r\n@Controller(\"bbs/articles/:section\")\r\nexport class BbsArticlesController {\r\n  /**\r\n   * Update an article.\r\n   *\r\n   * @param section Section code\r\n   * @param id Target article ID\r\n   * @param input Content to update\r\n   * @returns Updated content\r\n   */\r\n  @core.TypedException<TypeGuardError.IProps>(400)\r\n  @core.TypedRoute.Put(\":id\")\r\n  public async update(\r\n    @core.TypedParam(\"section\") section: string,\r\n    @core.TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\r\n    @core.TypedBody() input: IBbsArticle.IStore,\r\n  ): Promise<IBbsArticle> {\r\n    return {\r\n      ...typia.random<IBbsArticle>(),\r\n      id,\r\n      section,\r\n      ...input,\r\n    };\r\n  }\r\n}\n/**\r\n * Update an article.\r\n *\r\n * @param section Section code\r\n * @param id Target article ID\r\n * @param input Content to update\r\n * @returns Updated content\r\n *\r\n * @controller BbsArticlesController.update()\r\n * @path PUT /bbs/:section/articles/:id\r\n * @nestia Generated by Nestia - https://github.com/samchon/nestia\r\n */\r\nexport async function update(\r\n  connection: IConnection,\r\n  section: string,\r\n  id: string & Format<\"uuid\">,\r\n  input: update.Input,\r\n): Promise<update.Output> {\r\n  return PlainFetcher.propagate(\r\n    {\r\n      ...connection,\r\n      headers: {\r\n        ...connection.headers,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n    },\r\n    {\r\n      ...update.METADATA,\r\n      path: update.path(section, id),\r\n    } as const,\r\n    input,\r\n  );\r\n}\r\nexport namespace update {\r\n  export type Input = Primitive<IBbsArticle.IStore>;\r\n  export type Output = IPropagation<\r\n    {\r\n      200: IBbsArticle;\r\n      400: TypeGuardError.IProps;\r\n    },\r\n    200\r\n  >;\r\n\r\n  export const METADATA = {\r\n    method: \"PUT\",\r\n    path: \"/bbs/articles/:section/:id\",\r\n    request: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    response: {\r\n      type: \"application/json\",\r\n      encrypted: false,\r\n    },\r\n    status: null,\r\n  } as const;\r\n\r\n  export const path = (\r\n    section: string,\r\n    id: string & Format<\"uuid\">,\r\n  ): string => {\r\n    return `/bbs/articles/${encodeURIComponent(\r\n      section ?? \"null\",\r\n    )}/${encodeURIComponent(id ?? \"null\")}`;\r\n  };\r\n}\nconst output = await api.functional.bbs.articles.update(section, id, input);\r\nif (output.success) {\r\n  // automatically casted to \"IBbsArticle\" when status 200 (success)\r\n  const article: IBbsArticle = output.data;\r\n} else if (output.status === 400) {\r\n  // casted to \"TypeGuardError.IProps\" when status 400\r\n  const error: TypeGuardError.IProps = output.data;\r\n} else {\r\n  // casted to \"unknown\" when out of pre-defined status codes\r\n  const result: unknown = output.data;\r\n}","cli-arguments#CLI Arguments":"npx nestia sdk\r\nnpx nestia sdk --config nestia2.config.ts\r\nnpx nestia sdk --project tsconfig2.json\r\nnpx nestia sdk --config nestia3.config.ts --project tsconfig3.tsconfig.json\nIf you have a special configuration file that its file name is not nestia.config.ts or the configuration file is not placed on the root directory of the project, you can specify it with --config option like npx nestia sdk --config another.config.ts.Also, if you have a special tsconfig.json file or the project file is not located in the root directory of the project, you can specify it with --project argument like npx nestia sdk --project another.tsconfig.json, too."}},"/docs/swagger/chat":{"title":"Guide Documents > Swagger Document > AI Chatbot Development","data":{"agentica#Agentica":"https://github.com/wrtnlabs/agenticaThe simplest Agentic AI framework, specialized in LLM Function Calling.With @agentica, you can build Agentic AI chatbot only with Swagger document built by @nestia/sdk. Complex agent workflows and graphs required in conventional AI agent development are not necessary in @agentica. Only with the Swagger document, @agentica will do everything with the function calling.Look at below demonstration, and feel how @agentica is powerful. Now, you can let users to search and purchase products only with conversation texts. The backend API functions would be adequately called in the AI chatbot with LLM function calling.\n@nestia/agent had been migrated to @agentica/* for enhancements and separation to multiple packages extending the functionalities.\nimport { Agentica } from \"@agentica/core\";\r\nimport typia from \"typia\";\r\n\r\nconst agent = new Agentica({\r\n  controllers: [\r\n    await fetch(\r\n      \"https://shopping-be.wrtn.ai/editor/swagger.json\",\r\n    ).then(r => r.json()),\r\n    typia.llm.application<ShoppingCounselor>(),\r\n    typia.llm.application<ShoppingPolicy>(),\r\n    typia.llm.application<ShoppingSearchRag>(),\r\n  ],\r\n});\r\nawait agent.conversate(\"I wanna buy MacBook Pro\");\nimport { Agentica } from \"@agentica/core\";\r\nimport { OpenApi, HttpLlm } from \"@samchon/openapi\";\r\nimport typia from \"typia\";\r\n\r\nconst main = async (): Promise<void> => {\r\n  const agent = new Agentica({\r\n    model: \"chatgpt\",\r\n    vendor: {\r\n      api: new OpenAI({ apiKey: \"*****\" }),\r\n      model: \"gpt-4o-mini\",\r\n    },\r\n    controllers: [\r\n      {\r\n        protocol: \"http\",\r\n        name: \"shopping\",\r\n        application: HttpLlm.application({\r\n          model: \"chatgpt\",\r\n          document: OpenApi.convert(\r\n            await fetch(\r\n              \"https://shopping-be.wrtn.ai/editor/swagger.json\",\r\n            ).then(r => r.json()),\r\n          ),\r\n        }),\r\n        connection: {\r\n          host: \"https://shopping-be.wrtn.ai\",\r\n          headers: {\r\n            Authorization: \"Bearer *****\",\r\n          },\r\n        },\r\n      },\r\n      {\r\n        protocol: \"class\",\r\n        name: \"counselor\",\r\n        application: \r\n          typia.llm.application<ShoppingCounselor, \"chatgpt\">(),\r\n        execute: new ShoppingCounselor(),\r\n      },\r\n      {\r\n        protocol: \"class\",\r\n        name: \"policy\",\r\n        application: \r\n          typia.llm.application<ShoppingPolicy, \"chatgpt\">(),\r\n        execute: new ShoppingPolicy(),\r\n      },\r\n      {\r\n        protocol: \"class\",\r\n        name: \"rag\",\r\n        application: \r\n          typia.llm.application<ShoppingSearchRag, \"chatgpt\">(),\r\n        execute: new ShoppingSearchRag(),\r\n      },\r\n    ],\r\n  });\r\n  await agent.conversate(\"I wanna buy MacBook Pro\");\r\n};\r\nmain().catch(console.error);\nShopping A.I. Chatbot Application: https://nestia.io/chat/shopping\nShopping Backend Repository: https://github.com/samchon/shopping-backend\nShopping Swagger Document (@nestia/editor): https://nestia.io/editor/?url=...","playground#Playground":"You can test your backend server's A.I. chatbot with the following playground.Upload your Swagger document file to the playground website, and start conversation with your backend server. If your backend server's documentation is well written so that the A.I. chatbot quality is satisfiable, you can start your own A.I. chatbot development with @agentica.","backend-development#Backend Development":"","setup#Setup":"npm install @agentica/core @agentica/rpc @samchon/openapi tgrid\nInstall above packages on your NestJS project.The first package @agentica/core is the core package of @agentica framework. It provides Agentic AI that is based on the LLM function calling. And @agentica/rpc is the package for the WebSocket RPC (Remote Procedure Call) combining with TGrid.The last package @samchon/openapi is a library for converting OpenAPI document to LLM functioni calling schema.","bootstrap#Bootstrap":"const app: INestApplication = await NestFactory.create(AppModule);\r\nawait WebSocketAdaptor.upgrade(app);\nCall WebSocketAdaptor.upgrade() function to the NestJS application instance.It will upgrade the NestJS backend server to be compatible with WebSocet protocol.","api-controller#API Controller":"import { AgenticaRpcService, IAgenticaRpcListener } from \"@agentica/rpc\";\r\nimport { WebSocketRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport { WebSocketAcceptor } from \"tgrid\";\r\n\r\n@Controller(\"chat\")\r\nexport class ChatController {\r\n  @WebSocketRoute()\r\n  public async start(\r\n    @WebSocketRoute.Acceptor()\r\n    acceptor: WebSocketAcceptor<\r\n      null, // header\r\n      AgenticaRpcService,\r\n      IAgenticaRpcListener\r\n    >,\r\n  ): Promise<void> {\r\n    const agent = new Agentica({ ... })\r\n    await acceptor.accept(\r\n      new AgenticaRpcService({\r\n        agent,\r\n        listener: acceptor.getDriver(),\r\n      }),\r\n    );\r\n  }\r\n}\nAt last, define a WebSocket route to a specific controller function.When a client connects to the server with ws://localhost:3001/chat like URL, Agentica made chatbot would be composed and Super AI cahtbot conversation will be started.And following the guide of @WebSocketRoute document, build SDK (Software Development Kit) library for the client, so that complete the AI chatbot development.","principles#Principles":"","agent-strategy#Agent Strategy":"When user says, @agentica/core delivers the conversation text to the selector agent, and let the selector agent to find (or cancel) candidate functions from the context. If the selector agent could not find any candidate function to call and there is not any candidate function previously selected either, the selector agent will work just like a plain ChatGPT.And @agentica/core enters to a loop statement until the candidate functions to be empty. In the loop statement, caller agent tries to LLM function calling by analyzing the user's conversation text. If context is enough to compose arguments of candidate functions, the caller agent actually calls the target functions, and let decriber agent to explain the function calling results. Otherwise the context is not enough to compose arguments, caller agent requests more information to user.Such LLM (Large Language Model) function calling strategy separating selector, caller, and describer is the key logic of @agentica/core.","validation-feedback#Validation Feedback":"import { FunctionCall } from \"pseudo\";\r\nimport { ILlmFunction, IValidation } from \"typia\";\r\n\r\nexport const correctFunctionCall = (p: {\r\n  call: FunctionCall;\r\n  functions: Array<ILlmFunction<\"chatgpt\">>;\r\n  retry: (reason: string, errors?: IValidation.IError[]) => Promise<unknown>;\r\n}): Promise<unknown> => {\r\n  // FIND FUNCTION\r\n  const func: ILlmFunction<\"chatgpt\"> | undefined =\r\n    p.functions.find((f) => f.name === p.call.name);\r\n  if (func === undefined) {\r\n    // never happened in my experience\r\n    return p.retry(\r\n      \"Unable to find the matched function name. Try it again.\",\r\n    );\r\n  }\r\n\r\n  // VALIDATE\r\n  const result: IValidation<unknown> = func.validate(p.call.arguments);\r\n  if (result.success === false) {\r\n    // 1st trial: 50% (gpt-4o-mini in shopping mall chatbot)\r\n    // 2nd trial with validation feedback: 99%\r\n    // 3nd trial with validation feedback again: never have failed\r\n    return p.retry(\r\n      \"Type errors are detected. Correct it through validation errors\",\r\n      {\r\n        errors: result.errors,\r\n      },\r\n    );\r\n  }\r\n  return result.data;\r\n}\nIs LLM function calling perfect?The answer is not, and LLM (Large Language Model) vendors like OpenAI take a lot of type level mistakes when composing the arguments of the target function to call. Even though an LLM function calling schema has defined an Array<string> type, LLM often fills it just by a string typed value.Therefore, when developing an LLM function calling agent, the validation feedback process is essentially required. If LLM takes a type level mistake on arguments composition, the agent must feedback the most detailed validation errors, and let the LLM to retry the function calling referencing the validation errors.About the validation feedback, @agentica/core is utilizing typia.validate<T>() and typia.llm.application<Class, Model>() functions. They construct validation logic by analyzing TypeScript source codes and types in the compilation level, so that detailed and accurate than any other validators like below.Such validation feedback strategy and combination with typia runtime validator, @agentica/core has achieved the most ideal LLM function calling. In my experience, when using OpenAI's gpt-4o-mini model, it tends to construct invalid function calling arguments at the first trial about 50% of the time. By the way, if correct it through validation feedback with typia, success rate soars to 99%. And I've never had a failure when trying validation feedback twice.\nComponents\ttypia\tTypeBox\tajv\tio-ts\tzod\tC.V.\tEasy to use\t✅\t❌\t❌\t❌\t❌\t❌\tObject (simple)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (recursive)\t✔\t❌\t✔\t✔\t✔\t✔\t✔\tObject (union, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tObject (union, explicit)\t✔\t✔\t✔\t✔\t✔\t❌\tObject (additional tags)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (template literal types)\t✔\t✔\t✔\t❌\t❌\t❌\tObject (dynamic properties)\t✔\t✔\t✔\t❌\t❌\t❌\tArray (rest tuple)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tArray (recursive)\t✔\t✔\t✔\t✔\t✔\t❌\tArray (recursive, union)\t✔\t✔\t❌\t✔\t✔\t❌\tArray (R+U, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (repeated)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (repeated, union)\t✅\t❌\t❌\t❌\t❌\t❌\tUltimate Union Type\t✅\t❌\t❌\t❌\t❌\t❌\t\nC.V. means class-validator","openapi-specification#OpenAPI Specification":"@agentica/core obtains LLM function calling schemas from both Swagger/OpenAPI documents and TypeScript class types. The TypeScript class type can be converted to LLM function calling schema by typia.llm.application<Class, Model>() function. Then how about OpenAPI document? How Swagger document can be LLM function calling schema.The secret is in the above diagram.In the OpenAPI specification, there are three versions with different definitions. And even in the same version, there are too much ambiguous and duplicated expressions. To resolve these problems, @samchon/openapi is transforming every OpenAPI documents to v3.1 emended specification. The @samchon/openapi's emended v3.1 specification has removed every ambiguous and duplicated expressions for clarity.With the v3.1 emended OpenAPI document, @samchon/openapi converts it to a migration schema that is near to the function structure. And as the last step, the migration schema will be transformed to a specific LLM vendor's function calling schema. LLM function calling schemas are composed like this way.\nWhy do not directly convert, but intermediate?If directly convert from each version of OpenAPI specification to specific LLM's function calling schema, I have to make much more converters increased by cartesian product. In current models, number of converters would be 12 = 3 x 4.However, if define intermediate schema, number of converters are shrunk to plus operation. In current models, I just need to develop only (7 = 3 + 4) converters, and this is the reason why I've defined intermediate specification. This way is economic."}},"/docs/setup":{"title":"Guide Documents > Setup","data":{"boilerplate#Boilerplate":"npx nestia start <directory>\nJust run above npx nestia start <directory> command.Boilerplate would be automatically constructed in the <directory>. For reference, this is a minimal boilerplate project concentrating only on the SDK generation from the NestJS server. It does not contain the database connection.If you want to construct much detailed boilerplate project, visit @samchon/backend or run below command. Below boilerplate project is using Prisma ORM and PostgresSQL database. Also, it guides how to utilize FP (Functional Programming) and TDD (Test Driven Development) in the NestJS backend development.\nnpx nestia template <directory>","setup-wizard#Setup Wizard":"npx nestia setup\nnpx nestia setup --manager pnpm\nYarn berry is not supported.\nnpx nestia setup --manager yarn\nWhen you want to setup nestia in existing project, just run above npx nestia setup command.Setup Wizard will install and configure everything automatically.During the setup process, the prompt will ask you to whether configure runtime swagger or not. If you hope to build Swagger Document in the runtime, you have to choose true option. Otherwise, just select the false option please.\nnpm install --save-dev nestia@latest\r\nnpx nestia setup\r\n\r\n----------------------------------------\r\n Nestia Setup Wizard\r\n----------------------------------------\r\n? Package Manager (Use arrow keys)\r\n> npm\r\n  pnpm\r\n  yarn (berry is not supported)\r\n? Transform Runtime Swagger (Use arrow keys)\r\n> true\r\n  false","webpack#Webpack":"","with-node_modules#With node_modules":"# SETUP NESTIA\r\nnpx nestia setup\r\n\r\n# INSTALL TS-LOADER & WEBPACK\r\nnpm install --save-dev ts-loader\r\nnpm install --save-dev webpack webpack-cli webpack-node-externals \n# SETUP NESTIA\r\nnpx nestia setup --manager pnpm\r\n\r\n# INSTALL TS-LOADER & WEBPACK\r\npnpm install --save-dev ts-loader\r\npnpm install --save-dev webpack webpack-cli webpack-node-externals \nYarn berry is not supported.\n# SETUP NESTIA\r\nnpx nestia setup --manager yarn\r\n\r\n# INSTALL TS-LOADER & WEBPACK\r\nyarn add -D ts-loader\r\nyarn add -D webpack webpack-cli webpack-node-externals \nWhen you want to bundle your NestJS project into a single file, you have to install webpack manually.Never run nest build --webpack command of @nestjs/cli, because it is not compatible with nestia.\nconst path = require(\"path\");\r\nconst nodeExternals = require(\"webpack-node-externals\");\r\n\r\nmodule.exports = {\r\n  // CUSTOMIZE HERE\r\n  entry: {\r\n    server: \"./src/executable/server.ts\",\r\n  },\r\n  output: {\r\n    path: path.join(__dirname, \"dist\"),\r\n    filename: \"[name].js\",\r\n  },\r\n  optimization: {\r\n    minimize: false,\r\n  },\r\n\r\n  // JUST KEEP THEM\r\n  externals: [nodeExternals()],\r\n  mode: \"development\",\r\n  target: \"node\",\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.ts$/,\r\n        exclude: /node_modules/,\r\n        loader: \"ts-loader\",\r\n      },\r\n    ],\r\n  },\r\n  resolve: {\r\n    extensions: [\".tsx\", \".ts\", \".js\"],\r\n  },\r\n};\nAfter installing both nestia and webpack, configure webpack.config.js file like above.From now on, you can build the single JS file just by running the npx webpack command. By the way, when removing devDependencies for --production install, never forget to add the --ignore-scripts option to prevent the prepare script.\nnpx webpack\r\nnpm ci --omit=dev --ignore-scripts\npnpm webpack\r\npnpm install --production --ignore-scripts\nyarn webpack\r\nrm -rf node_modules\r\nyarn install --production --ignore-scripts --immutable","single-js-file-only#Single JS file only":"If you can build your NestJS project into a singile JS file, and that JS file even does not require the node_modules directory, it would be useful for building a serverless environment. Also, as it does not need to perform the pruning process (represented by pnpm install --production --ignore-scripts command), it would be much convenient and faster than the above method.To accomplish the light JS bundling, install special dependencies like below.\n# SETUP NESTIA\r\nnpx nestia setup\r\n\r\n# INSTALL SPECIAL DEPENDENCIES\r\nnpm install --save-dev ts-loader\r\nnpm install --save-dev webpack webpack-cli\r\nnpm install --save-dev copy-webpack-plugin write-file-webpack-plugin\n# SETUP NESTIA\r\nnpx nestia setup --manager pnpm\r\n\r\n# INSTALL SPECIAL DEPENDENCIES\r\npnpm install --save-dev ts-loader\r\npnpm install --save-dev webpack webpack-cli\r\npnpm install --save-dev copy-webpack-plugin write-file-webpack-plugin\nYarn berry is not supported.\n# SETUP NESTIA\r\nnpx nestia setup --manager yarn\r\n\r\n# INSTALL SPECIAL DEPENDENCIES\r\nyarn add -D ts-loader\r\nyarn add -D webpack webpack-cli\r\nyarn add -D copy-webpack-plugin write-file-webpack-plugin\nAlso, configure webpack.config.js file like below, considering options.For example, if your NestJS backend server is utilizing the Prisma ORM, uncomment the CopyWebpackPlugin.patterns block to copy the Prisma engine files (node_modules/**/.prisma/client/*.node) into the output dist directory.After that, just run npx webpack command. Then the light JS file(s) would be bundled into the dist directory, and you don't need to perform the pruning process (represented by pnpm install --production --ignore-scripts command) for the distribution. Just deploy the dist directory to the target server.\nconst path = require(\"path\");\r\n\r\nconst CopyWebpackPlugin = require(\"copy-webpack-plugin\");\r\nconst WriteFilePlugin = require(\"write-file-webpack-plugin\");\r\nconst { IgnorePlugin } = require(\"webpack\");\r\n\r\nconst lazyImports = [\r\n  \"@fastify/static\",\r\n  \"@fastify/view\",\r\n  \"@nestjs/microservices\",\r\n  \"@nestjs/websockets\",\r\n  \"class-transformer\",\r\n  \"class-validator\",\r\n];\r\n\r\n// @reference https://tech-blog.s-yoshiki.com/entry/297\r\nmodule.exports = {\r\n  // CUSTOMIZE HERE\r\n  entry: {\r\n    server: \"./src/executable/server.ts\",\r\n  },\r\n  output: {\r\n    path: path.join(__dirname, \"dist\"),\r\n    filename: \"[name].js\",\r\n    chunkFormat: false,\r\n  },\r\n  optimization: {\r\n    minimize: true,\r\n  },\r\n\r\n  // JUST KEEP THEM\r\n  mode: \"production\",\r\n  target: \"node\",\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.ts$/,\r\n        exclude: /node_modules/,\r\n        loader: \"ts-loader\",\r\n      },\r\n    ],\r\n  },\r\n  resolve: {\r\n    extensions: [\".tsx\", \".ts\", \".js\"],\r\n  },\r\n  plugins: [\r\n    new CopyWebpackPlugin({\r\n      patterns: [\r\n        {\r\n          from: \".env\",\r\n          to: \"[name][ext]\",\r\n        },\r\n        {\r\n          from: \"package.json\",\r\n          to: \"[name][ext]\",\r\n        },\r\n        // {\r\n        //   from: \"node_modules/**/.prisma/client/*.node\",\r\n        //   to: () => Promise.resolve(\"[path][name][ext]\"),\r\n        //   globOptions: {\r\n        //     dot: true,\r\n        // },\r\n      ],\r\n    }),\r\n    new WriteFilePlugin(),\r\n    new IgnorePlugin({\r\n      checkResource: (resource) => {\r\n        if (lazyImports.some((modulo) => resource.startsWith(modulo))) {\r\n          try {\r\n            require.resolve(resource);\r\n          } catch (err) {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      },\r\n    }),\r\n  ],\r\n};","nx#NX":"npx nestia setup\nnpx nestia setup --manager pnpm\nnpx nestia setup --manager yarn\nAfter installing nestia like above, and ensuring the prepare script is something similar to ts-patch install you have to modify the tsconfig.lib.json on each package to be similar to the below.\n{\r\n  \"extends\": \"./tsconfig.json\",\r\n  \"compilerOptions\": {\r\n    \"outDir\": \"../../dist/out-tsc\",\r\n    \"declaration\": true,\r\n    \"types\": [],\r\n    \"plugins\": [\r\n      { \"transform\": \"typia/lib/transform\" },\r\n      { \r\n        \"transform\": \"@nestia/core/lib/transform\",\r\n        \"validate\": \"validate\",\r\n        \"stringify\": \"assert\", \r\n      },\r\n      { \"transform\": \"@nestia/sdk/lib/transform\" }, // for runtime swagger composition\r\n    ],\r\n  },\r\n  \"include\": [\"**/*.ts\"],\r\n  \"exclude\": [\"jest.config.ts\", \"**/*.spec.ts\", \"**/*.test.ts\"]\r\n}\nAfter this, when running nx <package-name>:build it should now output with the Nestia transforms applied. But if Nestia fails for any reasons (for example it considers some type you have to be invalid), this error is not reported back via Nx. Nx will silent swallow these errors from ts-patch/nestia, and you will just not get the output you expect. To debug this, you can create a new task in your project.json file similar to the below.\n \"targets\": {\r\n    \"build:validate:nestia\": {\r\n      \"executor\": \"nx:run-commands\",\r\n      \"options\": {\r\n        \"commands\": [\r\n          \"tsc --project packages/<package-name>/tsconfig.lib.json --outDir dist/packages/nestiaTest\"\r\n        ],\r\n      }\r\n    },\r\n    ...\r\n }\nRunning this task will show you the errors from Nestia, and allow you to correct them, meaning that using the standard nx <package-name>:build task should now work the way you expect.Note: While Nx has a transformers feature on certain plugins, that won't work with Nestia. The reason is because Nx is expecting a transformer to export a before hook, which Nx then plugs directly into TypeScript via the compiler API. Nestia doesn't export that kind of hook, because Nestia only works with ts-patch, which abstracts the need for creating a specific before hook in the way Nx wants.","manual-setup#Manual Setup":"# COMPILERS\r\nnpm install --save-dev typescript\r\nnpm install --save-dev ts-node\r\nnpm install --save-dev ts-patch\r\n\r\n# NESTIA\r\nnpm install --save-dev nestia\r\nnpm install --save @nestia/core\r\nnpm install --save @nestia/e2e\r\nnpm install --save @nestia/sdk\r\nnpm install --save typia\n# COMPILERS\r\npnpm install --save-dev typescript\r\npnpm install --save-dev ts-node\r\npnpm install --save-dev ts-patch\r\n\r\n# NESTIA\r\npnpm install --save-dev nestia\r\npnpm install --save-dev @nestia/sdk\r\npnpm install --save @nestia/core\r\npnpm install --save @nestia/e2e\r\npnpm install --save typia\n# COMPILERS\r\nyarn add -D typescript\r\nyarn add -D ts-node\r\nyarn add -D ts-patch\r\n\r\n# NESTIA\r\nyarn add -D nestia\r\nyarn add -D @nestia/sdk\r\nyarn add @nestia/core\r\nyarn add @nestia/e2e\r\nyarn add typia\nIf you want to install nestia manually, you have to install ts-node and ts-patch modules as well as typescript. After installing those compilers, install nestia libraries like above.\n{\r\n  \"strict\": true,\r\n  \"strictNullChecks\": true,\r\n  \"compilerOptions\": {\r\n    \"plugins\": [\r\n      { \"transform\": \"typia/lib/transform\" },\r\n      { \r\n        \"transform\": \"@nestia/core/lib/transform\",\r\n        \"validate\": \"validate\",\r\n        \"stringify\": \"assert\", \r\n      },\r\n      { \"transform\": \"@nestia/sdk/lib/transform\" }, // for runtime swagger composition\r\n    ],\r\n  },\r\n}\nAfter that, configure tsconfig.json file like above.As @nestia/core and typia are generating optimal validation and JSON serialization code through transformation, you've to configure them as plugins. For reference, you can choose which typia functions to be used in validation and JSON serialization.\nConfigurable values both on validate and stringify\nis: check validation only, and do not reveal the reason why\nassert: find the 1st type error with reason\nvalidate: find every type errors with detailed reasons\nOnly for validate\nequals: do not allow extra properties\nassertEquals\nvalidateEquals\nassertPrune or validatePrune: prune extra properties with type checking\nassertClone or validateClone: deep clone with type checking for faster pruning\nOnly for stringify\nvalidate.log: check response data, but do not throw error and just log it\nAlso, never forget to configure strict (or strictNullChecks) as true. It is essential option for modern TypeScript development.\n{\r\n  \"scripts\": {\r\n    \"prepare\": \"ts-patch install && typia patch\"\r\n  }\r\n}\nnpm run prepare\npnpm run prepare\nyarn run prepare\nAt last, configure npm run prepare command like above.Of course, you've to run the npm run prepare command after configuration.For reference, ts-patch is an helper library of TypeScript compiler that supporting custom transformations by plugins. With the ts-patch setup and plugin configurations, whenever you run tsc command, your @nestia/core decorator function call statements would be transformed to the optimal operation codes in the compiled JavaScript files.\nnpx typia patch\nSince TypeScript v5.3 update, tsc no more parses JSDocComments. Therefore, (@nestia/core) typia also cannot utilize those JSDocComment related features too, especially \"Comment Tags\" and \"JSON schema generator\".The npx typia patch command has been developed to revive the JSDocComment parsing feature of tsc. It is temporary solution for the TypeScript v5.3 update instead of ts-patch, and will be disabled after ts-patch starts supporting such TypeScript v5.3 update.Of course, if you don't use any \"Comment Tags\" and \"JSON schema generator\", you don't need to run npx typia patch command. This is not mandatory command, but just optional command.","standard-typescript-only#Standard TypeScript Only":"If you're using @nestia/core module, you've to use only standard TypeScript compiler.Do you remember? @nestia/core boosts up runtime validation and JSON serialization through AOT compilation. By the way, @nestia/core performs the AOT compilation through standard TypeScript compiler API. Therefore, if you want to utilize those superfast decorators of @nestia/core module, you have to use only standard TypeScript compiler.I also know that non-standard compilers are faster than standard. However, all of them are erasing type information, and skipping type checking for rapid compilation. By the way, without type information, @nestia/core can't do anything. It is the reason why @nestia/core does not support them.\nStandard TypeScript Compiler (keep type info)\nMicrosoft/TypeScript\nNon-standard TypeScript Compilers (erase type info)\nSWC\nESBuild\nBabel"}},"/docs/swagger":{"title":"Guide Documents > Swagger Document","data":{"outline#Outline":"import { NestiaSwaggerComposer } from \"@nestia/sdk\";\r\nimport { INestApplication } from \"@nestjs/common\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\nimport { SwaggerModule } from \"@nestjs/swagger\";\r\n\r\nconst main = async (): Promise<void> => {\r\n  const app: INestApplication = await NestFactory.create(ApplicationModule);\r\n  const document = await NestiaSwaggerComposer.document(app, {});\r\n  SwaggerModule.setup(\"api\", app, document as any);\r\n  await app.listen(3_000);\r\n};\r\nmain().catch(console.error);\n{\r\n  \"compilerOptions\": {\r\n    \"strict\": true,\r\n    \"plugins\": [\r\n      { \"transform\": \"typia/lib/transform\" },\r\n      { \"transform\": \"@nestia/core/lib/transform\" },\r\n      { \"transform\": \"@nestia/sdk/lib/transform\" }, // essential\r\n    ],\r\n  },\r\n}\nIf you want to build Swagger Document in runtime, compose it like above.By the way, it needs plugin configuration on the tsconfig.json file.\nimport { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  swagger: {\r\n    openapi: \"3.1\",\r\n    output: \"dist/swagger.json\",\r\n    security: {\r\n      bearer: {\r\n        type: \"apiKey\",\r\n        name: \"Authorization\",\r\n        in: \"header\",\r\n      },\r\n    },\r\n    servers: [\r\n      {\r\n        url: \"http://localhost:3000\",\r\n        description: \"Local Server\",\r\n      },\r\n    ],\r\n    beautify: true,\r\n  },\r\n};\r\nexport default NESTIA_CONFIG;\n# BUILD SWAGGER DOCUUMET ONLY\r\nnpx nestia swagger\r\n\r\n# BUILD SWAGGER/SDK/E2E AT THE SAME TIME\r\nnpx nestia all\nOtherwise you want to generate a swagger file by CLI (Command Line Interface), configure nestia.config.ts file and run the npx nestia swagger command. Then, @nestia/sdk will analyze your NestJS backend server code, and generate swagger.json file.When you want to build not only Swagger Document file, but also SDK (Software Development Kit) library and automated E2E (End-to-End) test functions at the same time, run npx nestia all command instead.","runtime-composition#Runtime Composition":"","bootstrap#Bootstrap":"import { NestiaSwaggerComposer } from \"@nestia/sdk\";\r\nimport { INestApplication } from \"@nestjs/common\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\nimport { SwaggerModule } from \"@nestjs/swagger\";\r\n\r\nconst main = async (): Promise<void> => {\r\n  const app: INestApplication = await NestFactory.create(ApplicationModule);\r\n  const document = await NestiaSwaggerComposer.document(app, {\r\n    openapi: \"3.1\",\r\n    servers: [\r\n      {\r\n        url: \"http://localhost:3000\",\r\n        description: \"Localhost\"\r\n      }\r\n    ]\r\n  });\r\n  SwaggerModule.setup(\"api\", app, document as any);\r\n  await app.listen(3_000);\r\n};\r\nmain().catch(console.error);\nCall NestiaSwaggerComposer.document() function.To compose Swagger Document in runtime and serve it through the Swagger UI in the NestJS application, import NestiaSwaggerComposer module from @nestia/sdk and call the NestiaSwaggerComposer.document() function with the INestApplication instance.When you call the NestiaSwaggerComposer.document() function, @nestia/sdk will analyze your NestJS backed server code in the compilation level rapidly, and generate the Swagger Document object in the runtime. If you want to specify the OpenAPI version or server address(es), configure the second parameter of the NestiaSwaggerComposer.document() function.After that, deliver the generated Swagger Document object to the SwaggerModule.setup() function of the @nestjs/swagger module. Then, the Swagger UI would be served in the http://localhost:3000/api address, and the swagger.json file would be placed on the http://localhost:3000/api-json location. Note that, as the NestJS core team and SwaggerModule.setup() function have not defined the exact OpenAPI document types, you've to cast the document object to any type.","plugin-configuration#Plugin Configuration":"{\r\n  \"compilerOptions\": {\r\n    \"strict\": true,\r\n    \"plugins\": [\r\n      { \"transform\": \"typia/lib/transform\" },\r\n      { \"transform\": \"@nestia/core/lib/transform\" },\r\n      { \"transform\": \"@nestia/sdk/lib/transform\" }, // essential\r\n    ],\r\n  },\r\n}\nConfigure plugin property of tsconfig.json file like above.To activate the runtime swagger composer by NestiaSwaggerComposer.document() function, you have to configure the plugin on the tsconfig.json file. If you've not done it yet, open the tsconfig.json file and configure like above. If you don't do that, the runtime swagger composer cannot find any API operations, so that the Swagger Document would be empty.\nnpm install --save-dev nestia@latest\r\nnpx nestia setup --runtime true\nnpm install --save-dev nestia@latest\r\nnpx nestia setup\r\n\r\n----------------------------------------\r\n Nestia Setup Wizard\r\n----------------------------------------\r\n? Package Manager (Use arrow keys)\r\n> npm\r\n  pnpm\r\n  yarn (berry is not supported)\r\n? Transform Runtime Swagger (Use arrow keys)\r\n> true\r\n  false\nIf you feel the tsconfig.json file configuration annoying, you can do it with CLI command of nestia. Just run the npx nestia setup --runtime true command, then the tsconfig.json file would be automatically configured with the plugin property.If you do not specify the --runtime true argument, so that run only the npx nestia setup command, the CLI prompt will ask you whether to configure the runtime argument or not. Answer as yes to configure it.","file-generation#File Generation":"","application-module#Application Module":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n// import { FastifyAdapter } from \"@nestjs/platform-fastify\";\r\n\r\nimport { YourModule } from \"./src/YourModule\";\r\n\r\nconst NESTIA_CONFIG: INestiaConfig = {\r\n  input: async () => {\r\n    const app = await NestFactory.create(YourModule);\r\n    // const app = await NestFactory.create(YourModule, new FastifyAdapter());\r\n    // app.setGlobalPrefix(\"api\");\r\n    // app.enableVersioning({\r\n    //     type: VersioningType.URI,\r\n    //     prefix: \"v\",\r\n    // })\r\n    return app;\r\n  },\r\n  swagger: {\r\n    openapi: \"3.1\",\r\n    output: \"dist/swagger.json\",\r\n    security: {\r\n      bearer: {\r\n        type: \"apiKey\",\r\n        name: \"Authorization\",\r\n        in: \"header\",\r\n      },\r\n    },\r\n    servers: [\r\n      {\r\n        url: \"http://localhost:3000\",\r\n        description: \"Local Server\",\r\n      },\r\n    ],\r\n    beautify: true,\r\n  },\r\n};\r\nexport default NESTIA_CONFIG;\nimport type { INestApplication } from \"@nestjs/common\";\r\nimport type { OpenApi } from \"@samchon/openapi\";\r\n\r\n/**\r\n * Definition for the `nestia.config.ts` file.\r\n *\r\n * @author Jeongho Nam - https://github.com/samchon\r\n */\r\nexport interface INestiaConfig {\r\n  /**\r\n   * Building `swagger.json` is also possible.\r\n   *\r\n   * If not specified, you can't build the `swagger.json`.\r\n   */\r\n  swagger?: INestiaConfig.ISwaggerConfig;\r\n\r\n  /**\r\n   * Accessor of controller classes.\r\n   *\r\n   * You can specify it within two ways\r\n   *\r\n   *   - Asynchronous function returning `INestApplication` instance\r\n   *   - Specify the path or directory of controller class files\r\n   */\r\n  input:\r\n    | (() => Promise<INestApplication>)\r\n    | INestiaConfig.IInput\r\n    | string[]\r\n    | string;\r\n\r\n  /**\r\n   * Output directory that SDK would be placed in.\r\n   *\r\n   * If not configured, you can't build the SDK library.\r\n   */\r\n  output?: string;\r\n\r\n  /**\r\n   * Target directory that SDK distribution files would be placed in.\r\n   *\r\n   * If you configure this property and runs `npx nestia sdk` command,\r\n   * distribution environments for the SDK library would be generated.\r\n   *\r\n   * After the SDK library generation, move to the `distribute` directory,\r\n   * and runs `npm publish` command, then you can share SDK library with\r\n   * other client (frontend) developers.\r\n   *\r\n   * Recommend to use `\"packages/api\"` value.\r\n   */\r\n  distribute?: string;\r\n\r\n  /**\r\n   * Allow simulation mode.\r\n   *\r\n   * If you configure this property to be `true`, the SDK library would be contain\r\n   * simulation mode. In the simulation mode, the SDK library would not communicate\r\n   * with the real backend server, but just returns random mock-up data\r\n   * with requestion data validation.\r\n   *\r\n   * For reference, random mock-up data would be generated by `typia.random<T>()`\r\n   * function.\r\n   *\r\n   * @default false\r\n   */\r\n  simulate?: boolean;\r\n\r\n  /**\r\n   * Target directory that e2e test functions would be placed in.\r\n   *\r\n   * If you configure this property and runs `npx nestia e2e` command,\r\n   * `@nestia/sdk` will analyze your NestJS backend server code, and\r\n   * generates e2e test functions for every API endpoints.\r\n   *\r\n   * If not configured, you can't run `npx nestia e2e` command.\r\n   */\r\n  e2e?: string;\r\n\r\n  /**\r\n   * Whether to use propagation mode or not.\r\n   *\r\n   * If being configured, interaction functions of the SDK library would\r\n   * perform the propagation mode. The propagation mode means that never\r\n   * throwing exception even when status code is not 200 (or 201), but just\r\n   * returning the {@link IPropagation} typed instance, which can specify its body\r\n   * type through discriminated union determined by status code.\r\n   *\r\n   * @default false\r\n   */\r\n  propagate?: boolean;\r\n\r\n  /**\r\n   * Whether to clone DTO structures or not.\r\n   *\r\n   * If being configured, all of DTOs used in the backend server would be cloned\r\n   * into the `structures` directory, and the SDK library would be refer to the\r\n   * cloned DTOs instead of the original.\r\n   *\r\n   * @default false\r\n   */\r\n  clone?: boolean;\r\n\r\n  /**\r\n   * Whether to wrap DTO by primitive type.\r\n   *\r\n   * If you don't configure this property as `false`, all of DTOs in the\r\n   * SDK library would be automatically wrapped by {@link Primitive} type.\r\n   *\r\n   * For refenrece, if a DTO type be capsuled by the {@link Primitive} type,\r\n   * all of methods in the DTO type would be automatically erased. Also, if\r\n   * the DTO has a `toJSON()` method, the DTO type would be automatically\r\n   * converted to return type of the `toJSON()` method.\r\n   *\r\n   * @default true\r\n   */\r\n  primitive?: boolean;\r\n\r\n  /**\r\n   * Whether to assert parameter types or not.\r\n   *\r\n   * If you configure this property to be `true`, all of the function\r\n   * parameters of SDK library would be checked through\r\n   * [`typia.assert<T>()` function](https://typia.io/docs/validators/assert/).\r\n   *\r\n   * This option would make your SDK library compilation time a little bit slower,\r\n   * but would enahcne the type safety even in the runtime level.\r\n   *\r\n   * @default false\r\n   */\r\n  assert?: boolean;\r\n\r\n  /**\r\n   * Whether to optimize JSON string conversion 10x faster or not.\r\n   *\r\n   * If you configure this property to be `true`, the SDK library would utilize the\r\n   * [`typia.assertStringify<T>() function`](https://github.com/samchon/typia#enhanced-json)\r\n   * to boost up JSON serialization speed and ensure type safety.\r\n   *\r\n   * This option would make your SDK library compilation time a little bit slower,\r\n   * but would enhance JSON serialization speed 10x faster. Also, it can ensure type\r\n   * safety even in the runtime level.\r\n   *\r\n   * @default false\r\n   */\r\n  json?: boolean;\r\n}\r\nexport namespace INestiaConfig {\r\n  /**\r\n   * List of files or directories to include or exclude to specifying the NestJS\r\n   * controllers.\r\n   */\r\n  export interface IInput {\r\n    /**\r\n     * List of files or directories containing the NestJS controller classes.\r\n     */\r\n    include: string[];\r\n\r\n    /**\r\n     * List of files or directories to be excluded.\r\n     */\r\n    exclude?: string[];\r\n  }\r\n\r\n  /**\r\n   * Building `swagger.json` is also possible.\r\n   */\r\n  export interface ISwaggerConfig {\r\n    /**\r\n     * OpenAPI version.\r\n     *\r\n     * If you configure this property to be `2.0` or `3.0`, the newly generated\r\n     * `swagger.json` file would follow the specified OpenAPI version. The newly\r\n     * generated `swagger.json` file would be downgraded from the OpenAPI v3.1\r\n     * specification by {@link OpenApi.downgrade} method.\r\n     *\r\n     * @default 3.1\r\n     */\r\n    openapi?: \"2.0\" | \"3.0\" | \"3.1\";\r\n    \r\n    /**\r\n     * Output path of the `swagger.json`.\r\n     *\r\n     * If you've configured only directory, the file name would be the `swagger.json`.\r\n     * Otherwise you've configured the full path with file name and extension, the\r\n     * `swagger.json` file would be renamed to it.\r\n     */\r\n    output: string;\r\n\r\n    /**\r\n     * Whether to beautify JSON content or not.\r\n     *\r\n     * If you configure this property to be `true`, the `swagger.json` file would\r\n     * be beautified with indentation (2 spaces) and line breaks. If you configure\r\n     * numeric value instead, the indentation would be specified by the number.\r\n     *\r\n     * @default false\r\n     */\r\n    beautify?: boolean | number;\r\n\r\n    /**\r\n     * API information.\r\n     *\r\n     * If omitted, `package.json` content would be used instead.\r\n     */\r\n    info?: Partial<OpenApi.IDocument.IInfo>;\r\n\r\n    /**\r\n     * List of server addresses.\r\n     */\r\n    servers?: OpenApi.IServer[];\r\n\r\n    /**\r\n     * Security schemes.\r\n     *\r\n     * When generating `swagger.json` file through `nestia`, if your controllers or\r\n     * theirs methods have a security key which is not enrolled in here property,\r\n     * it would be an error.\r\n     */\r\n    security?: Record<string, OpenApi.ISecurityScheme>;\r\n\r\n    /**\r\n     * List of tag names with description.\r\n     *\r\n     * It is possible to omit this property or skip some tag name even if\r\n     * the tag name is used in the API routes. In that case, the tag name\r\n     * would be used without description.\r\n     *\r\n     * Of course, if you've written a comment like `@tag {name} {description}`,\r\n     * you can entirely replace this property specification.\r\n     */\r\n    tags?: OpenApi.IDocument.ITag[];\r\n\r\n    /**\r\n     * Decompose query DTO.\r\n     *\r\n     * If you configure this property to be `true`, the query DTO would be decomposed\r\n     * into individual query parameters per each property. Otherwise you set it to be\r\n     * `false`, the query DTO would be one object type which contains all of query\r\n     * parameters.\r\n     *\r\n     * @default false\r\n     */\r\n    decompose?: boolean;\r\n\r\n    /**\r\n     * Operation ID generator.\r\n     *\r\n     * @param props Properties of the API endpoint.\r\n     * @returns Operation ID.\r\n     */\r\n    operationId?(props: {\r\n      class: string;\r\n      function: string;\r\n      method: \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\r\n      path: string;\r\n    }): string;\r\n  }\r\n}\n/**\r\n * Security scheme of Swagger Documents.\r\n *\r\n * `ISecurityScheme` is a data structure representing content of\r\n * `securitySchemes` in `swagger.json` file. It is composed with 5 types of security\r\n * schemes as an union type like below.\r\n *\r\n * @reference https://swagger.io/specification/#security-scheme-object\r\n * @author Jeongho Nam - https://github.com/samchon\r\n */\r\nexport type ISecurityScheme =\r\n  | ISecurityScheme.IHttpBasic\r\n  | ISecurityScheme.IHttpBearer\r\n  | ISecurityScheme.IApiKey\r\n  | ISecurityScheme.IOpenId\r\n  | ISecurityScheme.IOAuth2;\r\nexport namespace ISecurityScheme {\r\n  export interface IHttpBasic {\r\n    type: \"http\";\r\n    scheme: \"basic\";\r\n  }\r\n  export interface IHttpBearer {\r\n    type: \"http\";\r\n    scheme: \"bearer\";\r\n    bearerFormat?: string;\r\n  }\r\n  export interface IApiKey {\r\n    type: \"apiKey\";\r\n    in?: \"header\" | \"query\" | \"cookie\";\r\n    name?: string;\r\n  }\r\n\r\n  export interface IOpenId {\r\n    type: \"openIdConnect\";\r\n    openIdConnectUrl: string;\r\n  }\r\n\r\n  export interface IOAuth2 {\r\n    type: \"oauth2\";\r\n    flows: IOAuth2.IFlowSet;\r\n    description?: string;\r\n  }\r\n  export namespace IOAuth2 {\r\n    export interface IFlowSet {\r\n      authorizationCode?: IFlow;\r\n      implicit?: Omit<IFlow, \"tokenUrl\">;\r\n      password?: Omit<IFlow, \"authorizationUrl\">;\r\n      clientCredentials?: Omit<IFlow, \"authorizationUrl\">;\r\n    }\r\n    export interface IFlow {\r\n      authorizationUrl: string;\r\n      tokenUrl: string;\r\n      refreshUrl: string;\r\n      scopes?: Record<string, string>;\r\n    }\r\n  }\r\n}\nMake nestia.config.ts file and run npx nestia swagger command.At first, create nestia.config.ts file through npx nestia init command. It would be placed on the top level directory of your NestJS backend project. For reference, tsconfig.json file also must be placed in the top level directory, too. After creation, configure the nestia.config.ts file referencing above example code and type definition.At least, you've to configure those two properties:\ninput: Accessor of controller classes\nswagger.output: Path of swagger.json file\nWhen you've completed above configuration, just run npx nestia swagger command. Then, swagger.json file would be newly generated, and placed into the $config.swagger.output directory following your nestia.config.ts configuration.","multiple-files-generation#Multiple Files Generation":"import { INestiaConfig } from \"@nestia/sdk\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\n\r\nimport { AppModule } from \"./src/modules/AppModule\";\r\nimport { BbsModule } from \"./src/modules/BbsModule\";\r\nimport { CommonModule } from \"./src/modules/CommonModule\";\r\n\r\nexport const NESTIA_CONFIGURATIONS: INestiaConfig[] = [\r\n  {\r\n    input: () => NestFactory.create(AppModule),\r\n    swagger: {\r\n      output: \"swagger.json\",\r\n      security: {\r\n        bearer: {\r\n          type: \"apiKey\",\r\n        },\r\n      },\r\n    },\r\n  },\r\n  {\r\n    input: () => NestFactory.create(BbsModule),\r\n    swagger: {\r\n      output: \"bbs.swagger.json\",\r\n      security: {\r\n        bearer: {\r\n          type: \"apiKey\",\r\n        },\r\n      },\r\n    },\r\n  },\r\n  {\r\n    input: () => NestFactory.create(CommonModule),\r\n    swagger: {\r\n      output: \"common.swagger.json\",\r\n      security: {\r\n        bearer: {\r\n          type: \"apiKey\",\r\n        },\r\n      },\r\n    },\r\n  },\r\n];\r\nexport default NESTIA_CONFIGURATIONS;\nYou can build multiple Swagger Document files.Just configure an array of INestiaConfig instances like above example code.Then, @nestia/sdk will generate multiple Swagger Document files following the configurations.","additional-properties#Additional Properties":"Additionally, you can configure the swagger property in the nestia.config.ts file.\nswagger.openapi: OpenAPI version specification.\n\"2.0\"\n\"3.0\"\n\"3.1\" (default)\nswagger.beautify: Whether to beautify JSON content or not.\nswagger.info: API information. If not configured, package.json content be utilized instead.\nswagger.servers: List of server addresses.\nswagger.security: Security schemes.\nswagger.tags: List of tag names with description.\nswagger.decompose: Whether to decompose query DTO as individual parameters.\nswagger.operationId: Operation ID generator.\nFor reference, if you do not configure swagger.info property or omit some members of the information instance, @nestia/sdk will utilize your package.json file content instead. For example, if you omit the swagger.info.version, your package.json file's version property would be written instead.Also, whether you configure swagger.openapi version or not, the newly generated swagger.file starts from the OpenAPI v3.1 specification emended by @samchon/openapi. If your target OpenAPI version is lower than v3.1, @nestia/sdk just downgrades the newly generated OpenAPI v3.1 content by calling OpenApi.downgrade() function.\n See detailed options: \nexport namespace INestiaConfig {\r\n  /**\r\n   * Building `swagger.json` is also possible.\r\n   */\r\n  export interface ISwaggerConfig {\r\n    /**\r\n     * Output path of the `swagger.json`.\r\n     *\r\n     * If you've configured only directory, the file name would be the `swagger.json`.\r\n     * Otherwise you've configured the full path with file name and extension, the\r\n     * `swagger.json` file would be renamed to it.\r\n     */\r\n    output: string;\r\n\r\n    /**\r\n     * OpenAPI version.\r\n     *\r\n     * If you configure this property to be `2.0` or `3.0`, the newly generated\r\n     * `swagger.json` file would follow the specified OpenAPI version. The newly\r\n     * generated `swagger.json` file would be downgraded from the OpenAPI v3.1\r\n     * specification by {@link OpenApi.downgrade} method.\r\n     *\r\n     * @default 3.1\r\n     */\r\n    openapi?: \"2.0\" | \"3.0\" | \"3.1\";\r\n\r\n    /**\r\n     * Whether to beautify JSON content or not.\r\n     *\r\n     * If you configure this property to be `true`, the `swagger.json` file would\r\n     * be beautified with indentation (2 spaces) and line breaks. If you configure\r\n     * numeric value instead, the indentation would be specified by the number.\r\n     *\r\n     * @default false\r\n     */\r\n    beautify?: boolean | number;\r\n\r\n    /**\r\n     * API information.\r\n     *\r\n     * If omitted, `package.json` content would be used instead.\r\n     */\r\n    info?: Partial<OpenApi.IDocument.IInfo>;\r\n\r\n    /**\r\n     * List of server addresses.\r\n     */\r\n    servers?: OpenApi.IServer[];\r\n\r\n    /**\r\n     * Security schemes.\r\n     *\r\n     * When generating `swagger.json` file through `nestia`, if your controllers or\r\n     * theirs methods have a security key which is not enrolled in here property,\r\n     * it would be an error.\r\n     */\r\n    security?: Record<string, OpenApi.ISecurityScheme>;\r\n\r\n    /**\r\n     * List of tag names with description.\r\n     *\r\n     * It is possible to omit this property or skip some tag name even if\r\n     * the tag name is used in the API routes. In that case, the tag name\r\n     * would be used without description.\r\n     *\r\n     * Of course, if you've written a comment like `@tag {name} {description}`,\r\n     * you can entirely replace this property specification.\r\n     */\r\n    tags?: OpenApi.IDocument.ITag[];\r\n\r\n    /**\r\n     * Decompose query DTO.\r\n     *\r\n     * If you configure this property to be `true`, the query DTO would be decomposed\r\n     * into individual query parameters per each property. Otherwise you set it to be\r\n     * `false`, the query DTO would be one object type which contains all of query\r\n     * parameters.\r\n     *\r\n     * @default false\r\n     */\r\n    decompose?: boolean;\r\n\r\n    /**\r\n     * Operation ID generator.\r\n     *\r\n     * @param props Properties of the API endpoint.\r\n     * @returns Operation ID.\r\n     */\r\n    operationId?(props: {\r\n      class: string;\r\n      function: string;\r\n      method: \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\r\n      path: string;\r\n    }): string;\r\n  }\r\n}","cli-arguments#CLI Arguments":"npx nestia swagger\r\nnpx nestia swagger --config nestia2.config.ts\r\nnpx nestia swagger --project tsconfig2.json\r\nnpx nestia swagger --config nestia3.config.ts --project tsconfig3.tsconfig.json\nIf you have a special configuration file that its file name is not nestia.config.ts or the configuration file is not placed on the root directory of the project, you can specify it with --config option like npx nestia swagger --config another.config.ts.Also, if you have a special tsconfig.json file or the project file is not located in the root directory of the project, you can specify it with --project argument like npx nestia swagger --project another.tsconfig.json, too.","special-tags#Special Tags":"","nestjs-decorators#NestJS Decorators":"Swagger generator for @nestia/sdk supports some NestJS decorators. Here is the list of them.\n@nestjs/common\n@Header()\n@HttpCode()\n@Version()\n@nestjs/swagger\n@ApiBasicAuth()\n@ApiBearerAuth()\n@ApiOAuth2()\n@ApiSecurity()\n@ApiTags()\n@ApiExtension()\n@nestia/core\n@TypedException()\n@SwaggerExample.Parameter()\n@SwaggerExample.Response()","controller-methods#Controller Methods":"Swagger generator @nestia/sdk supports three type of comment tags for controller methods:\nHiding\n@deprecated: mark as deprecated\n@internal: hide, never be shown\n@hidden: hide, never be shown\n@ignore: hide, never be shown, even in the SDK side\nLabeling\n@summary : short description of endpoint\n@tag {name} {description?}: grouppig with description\n@operationId {value}: manual operation ID\nSecurity\n@security {key}: security scheme key\n@security {key} {...scopes}: +scopes for OAuth2 type\nAt first, @internal, @hidden and @ignore tags are used to hide the controller method from the Swagger Documents. When you use one of them, the controller method would not be written in the swagger.json file. Otherwise, the @deprecated tag is used to mark the controller method as deprecated. When you use it, Swagger Editor will show the deprecated message about the route method like below.Also, the @summary tag is used to write short description of the endpoint. By the way, the @summary tag can be replaced by writing top sentence ends with . symbol. The other one, @tag {name} {description?} tag is used for only grouping. If you fill the description part, it would be shown in the Swagger-UI.The last one, @security is a tag for security scheme. It specifies target security scheme by writing its key like @security {key}. If target scheme type is OAuth2, and it has configured scopes, you can specify the scopes by writing scopes at the backward like @security {key} read write.For reference, target security schemes must be configured in the nestia.config.ts file. If you use @security tag that is not configured in the nestia.config.ts file, it would be an error. Also, if you've configured @nestia/swagger security decorator like @ApiSecurity, @nestia/sdk also can recognize it too.\nimport { TypedBody, TypedParam, TypedRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport { ApiSecurity } from \"@nestjs/swagger\";\r\nimport typia, { tags } from \"typia\";\r\n\r\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\r\n\r\n@Controller(\"bbs/articles/:section\")\r\nexport class BbsArticlesController {\r\n  /**\r\n   * Would be shown without any mark.\r\n   *\r\n   * @param section Section code\r\n   * @param input Content to store\r\n   * @returns Newly archived article\r\n   *\r\n   * @tag public Some description describing public group...\r\n   * @summary Public API\r\n   * @security bearer\r\n   * @security oauth2 read write\r\n   */\r\n  @TypedRoute.Post()\r\n  public async store(\r\n    @TypedParam(\"section\") section: string,\r\n    @TypedBody() input: IBbsArticle.IStore,\r\n  ): Promise<IBbsArticle> {\r\n    return {\r\n      ...typia.random<IBbsArticle>(),\r\n      ...input,\r\n      section,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Deprecated API.\r\n   *\r\n   * Would be marked as \"deprecated\".\r\n   *\r\n   * For reference, top sentence \"Deprecated API.\" can replace the `@summary` tag.\r\n   *\r\n   * @param section Section code\r\n   * @param id Target article ID\r\n   * @param input Content to update\r\n   * @returns Updated content\r\n   *\r\n   * @deprecated\r\n   * @operationId updateArticle\r\n   * @security basic\r\n   * @security bearer\r\n   */\r\n  @TypedRoute.Put(\":id\")\r\n  public async update(\r\n    @TypedParam(\"section\") section: string,\r\n    @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\r\n    @TypedBody() input: IBbsArticle.IStore,\r\n  ): Promise<IBbsArticle> {\r\n    return {\r\n      ...typia.random<IBbsArticle>(),\r\n      ...input,\r\n      id,\r\n      section,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Would not be shown.\r\n   *\r\n   * @internal\r\n   */\r\n  @ApiSecurity(\"custom\") // LEGACY DECORATOR ALSO CAN BE USED\r\n  @TypedRoute.Delete(\":id\")\r\n  public erase(\r\n    @TypedParam(\"section\") section: string,\r\n    @TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\r\n  ): void {\r\n    section;\r\n    id;\r\n  }\r\n}\n{\r\n  \"openapi\": \"3.1.0\",\r\n  \"servers\": [\r\n    {\r\n      \"url\": \"https://github.com/samchon/nestia\",\r\n      \"description\": \"insert your server url\"\r\n    }\r\n  ],\r\n  \"info\": {\r\n    \"version\": \"3.0.3\",\r\n    \"title\": \"@nestia/test\",\r\n    \"description\": \"Test program of Nestia\",\r\n    \"license\": {\r\n      \"name\": \"MIT\"\r\n    }\r\n  },\r\n  \"paths\": {\r\n    \"/bbs/articles/{section}\": {\r\n      \"post\": {\r\n        \"tags\": [\r\n          \"public\"\r\n        ],\r\n        \"operationId\": \"BbsArticlesController.store\",\r\n        \"parameters\": [\r\n          {\r\n            \"name\": \"section\",\r\n            \"in\": \"path\",\r\n            \"schema\": {\r\n              \"type\": \"string\"\r\n            },\r\n            \"description\": \"Section code\",\r\n            \"required\": true\r\n          }\r\n        ],\r\n        \"requestBody\": {\r\n          \"description\": \"Content to store\",\r\n          \"content\": {\r\n            \"application/json\": {\r\n              \"schema\": {\r\n                \"$ref\": \"#/components/schemas/IBbsArticle.IStore\"\r\n              }\r\n            }\r\n          },\r\n          \"required\": true\r\n        },\r\n        \"responses\": {\r\n          \"201\": {\r\n            \"description\": \"Newly archived article\",\r\n            \"content\": {\r\n              \"application/json\": {\r\n                \"schema\": {\r\n                  \"$ref\": \"#/components/schemas/IBbsArticle\"\r\n                }\r\n              }\r\n            }\r\n          }\r\n        },\r\n        \"summary\": \"Public API\",\r\n        \"description\": \"Would be shown without any mark.\",\r\n        \"security\": [\r\n          {\r\n            \"bearer\": []\r\n          },\r\n          {\r\n            \"oauth2\": [\r\n              \"read\",\r\n              \"write\"\r\n            ]\r\n          }\r\n        ]\r\n      }\r\n    },\r\n    \"/bbs/articles/{section}/{id}\": {\r\n      \"put\": {\r\n        \"deprecated\": true,\r\n        \"tags\": [],\r\n        \"operationId\": \"updateArticle\",\r\n        \"parameters\": [\r\n          {\r\n            \"name\": \"section\",\r\n            \"in\": \"path\",\r\n            \"schema\": {\r\n              \"type\": \"string\"\r\n            },\r\n            \"description\": \"Section code\",\r\n            \"required\": true\r\n          },\r\n          {\r\n            \"name\": \"id\",\r\n            \"in\": \"path\",\r\n            \"schema\": {\r\n              \"type\": \"string\",\r\n              \"format\": \"uuid\"\r\n            },\r\n            \"description\": \"Target article ID\",\r\n            \"required\": true\r\n          }\r\n        ],\r\n        \"requestBody\": {\r\n          \"description\": \"Content to update\",\r\n          \"content\": {\r\n            \"application/json\": {\r\n              \"schema\": {\r\n                \"$ref\": \"#/components/schemas/IBbsArticle.IStore\"\r\n              }\r\n            }\r\n          },\r\n          \"required\": true\r\n        },\r\n        \"responses\": {\r\n          \"200\": {\r\n            \"description\": \"Updated content\",\r\n            \"content\": {\r\n              \"application/json\": {\r\n                \"schema\": {\r\n                  \"$ref\": \"#/components/schemas/IBbsArticle\"\r\n                }\r\n              }\r\n            }\r\n          }\r\n        },\r\n        \"summary\": \"Deprecated API\",\r\n        \"description\": \"Deprecated API.\\n\\nWould be marked as \\\"deprecated\\\".\\n\\nFor reference, top sentence \\\"Deprecated API.\\\" can replace the `@summary` tag.\",\r\n        \"security\": [\r\n          {\r\n            \"basic\": []\r\n          },\r\n          {\r\n            \"bearer\": []\r\n          }\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"components\": {\r\n    \"schemas\": {\r\n      \"IBbsArticle.IStore\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"title\": {\r\n            \"type\": \"string\",\r\n            \"minLength\": 3,\r\n            \"maxLength\": 50\r\n          },\r\n          \"body\": {\r\n            \"type\": \"string\"\r\n          },\r\n          \"files\": {\r\n            \"type\": \"array\",\r\n            \"items\": {\r\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\r\n            }\r\n          }\r\n        },\r\n        \"required\": [\r\n          \"title\",\r\n          \"body\",\r\n          \"files\"\r\n        ]\r\n      },\r\n      \"IAttachmentFile\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"name\": {\r\n            \"oneOf\": [\r\n              {\r\n                \"type\": \"null\"\r\n              },\r\n              {\r\n                \"type\": \"string\",\r\n                \"maxLength\": 255\r\n              }\r\n            ]\r\n          },\r\n          \"extension\": {\r\n            \"oneOf\": [\r\n              {\r\n                \"type\": \"null\"\r\n              },\r\n              {\r\n                \"type\": \"string\",\r\n                \"minLength\": 1,\r\n                \"maxLength\": 8\r\n              }\r\n            ]\r\n          },\r\n          \"url\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"uri\"\r\n          }\r\n        },\r\n        \"required\": [\r\n          \"name\",\r\n          \"extension\",\r\n          \"url\"\r\n        ]\r\n      },\r\n      \"IBbsArticle\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"id\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"uuid\"\r\n          },\r\n          \"section\": {\r\n            \"type\": \"string\"\r\n          },\r\n          \"created_at\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"date-time\"\r\n          },\r\n          \"title\": {\r\n            \"type\": \"string\",\r\n            \"minLength\": 3,\r\n            \"maxLength\": 50\r\n          },\r\n          \"body\": {\r\n            \"type\": \"string\"\r\n          },\r\n          \"files\": {\r\n            \"type\": \"array\",\r\n            \"items\": {\r\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\r\n            }\r\n          }\r\n        },\r\n        \"required\": [\r\n          \"id\",\r\n          \"section\",\r\n          \"created_at\",\r\n          \"title\",\r\n          \"body\",\r\n          \"files\"\r\n        ]\r\n      }\r\n    },\r\n    \"securitySchemes\": {\r\n      \"basic\": {\r\n        \"type\": \"http\",\r\n        \"scheme\": \"basic\"\r\n      },\r\n      \"bearer\": {\r\n        \"type\": \"http\",\r\n        \"scheme\": \"bearer\"\r\n      },\r\n      \"oauth2\": {\r\n        \"type\": \"oauth2\",\r\n        \"flows\": {\r\n          \"implicit\": {\r\n            \"authorizationUrl\": \"https://example.com/api/oauth/dialog\",\r\n            \"refreshUrl\": \"https://example.com/api/oauth/refresh\",\r\n            \"scopes\": {\r\n              \"read\": \"read authority\",\r\n              \"write\": \"write authority\"\r\n            }\r\n          }\r\n        }\r\n      },\r\n      \"custom\": {\r\n        \"type\": \"apiKey\",\r\n        \"in\": \"header\",\r\n        \"name\": \"Authorization\"\r\n      }\r\n    }\r\n  },\r\n  \"tags\": [\r\n    {\r\n      \"name\": \"public\",\r\n      \"description\": \"Some description describing public group...\"\r\n    }\r\n  ],\r\n  \"x-samchon-emended\": true\r\n}\nimport type { INestiaConfig } from \"@nestia/sdk\";\r\n\r\nexport const NESTIA_CONFIG: INestiaConfig = {\r\n  input: [\"src/controllers\"],\r\n  output: \"src/api\",\r\n  swagger: {\r\n    output: \"swagger.json\",\r\n    beautify: true,\r\n    operationId: (props) => `${props.class}.${props.function}`,\r\n    security: {\r\n      //----\r\n      // YOU CAN CHOOSE ANY SECURITY SCHEMES LIKE\r\n      //----\r\n      // @security basic\r\n      // @security bearer\r\n      // @security oauth2 read write\r\n      // @security custom\r\n      basic: {\r\n        type: \"http\",\r\n        scheme: \"basic\",\r\n      },\r\n      bearer: {\r\n        type: \"http\",\r\n        scheme: \"bearer\",\r\n      },\r\n      oauth2: {\r\n        type: \"oauth2\",\r\n        flows: {\r\n          implicit: {\r\n            authorizationUrl: \"https://example.com/api/oauth/dialog\",\r\n            refreshUrl: \"https://example.com/api/oauth/refresh\",\r\n            scopes: {\r\n              //----\r\n              // YOU CAN CHOOSE ANY SCOPES\r\n              //----\r\n              // (@security oauth2 read write) -> BOTH OF THEM\r\n              // (@security oauth2 read) -> ONE OF THEM\r\n              // (@security oauth) -> NOTHING\r\n              read: \"read authority\",\r\n              write: \"write authority\",\r\n            },\r\n          },\r\n        },\r\n      },\r\n      custom: {\r\n        type: \"apiKey\",\r\n        in: \"header\",\r\n        name: \"Authorization\",\r\n      },\r\n    },\r\n  },\r\n};\r\nexport default NESTIA_CONFIG;\n/**\r\n * Security scheme of Swagger Documents.\r\n *\r\n * `OpenApi.ISecurityScheme` is a data structure representing content of\r\n * `securitySchemes` in `swagger.json` file. It is composed with 5 types of security\r\n * schemes as an union type like below.\r\n *\r\n * @reference https://swagger.io/specification/#security-scheme-object\r\n * @author Jeongho Nam - https://github.com/samchon\r\n */\r\nexport type ISecurityScheme =\r\n  | ISecurityScheme.IHttpBasic\r\n  | ISecurityScheme.IHttpBearer\r\n  | ISecurityScheme.IApiKey\r\n  | ISecurityScheme.IOpenId\r\n  | ISecurityScheme.IOAuth2;\r\nexport namespace ISecurityScheme {\r\n  export interface IHttpBasic {\r\n    type: \"http\";\r\n    scheme: \"basic\";\r\n  }\r\n  export interface IHttpBearer {\r\n    type: \"http\";\r\n    scheme: \"bearer\";\r\n    bearerFormat?: string;\r\n  }\r\n  export interface IApiKey {\r\n    type: \"apiKey\";\r\n    in?: \"header\" | \"query\" | \"cookie\";\r\n    name?: string;\r\n  }\r\n\r\n  export interface IOpenId {\r\n    type: \"openIdConnect\";\r\n    openIdConnectUrl: string;\r\n  }\r\n\r\n  export interface IOAuth2 {\r\n    type: \"oauth2\";\r\n    flows: IOAuth2.IFlowSet;\r\n    description?: string;\r\n  }\r\n  export namespace IOAuth2 {\r\n    export interface IFlowSet {\r\n      authorizationCode?: IFlow;\r\n      implicit?: Omit<IFlow, \"tokenUrl\">;\r\n      password?: Omit<IFlow, \"authorizationUrl\">;\r\n      clientCredentials?: Omit<IFlow, \"authorizationUrl\">;\r\n    }\r\n    export interface IFlow {\r\n      authorizationUrl: string;\r\n      tokenUrl: string;\r\n      refreshUrl: string;\r\n      scopes?: Record<string, string>;\r\n    }\r\n  }\r\n}","dto-properties#DTO Properties":"https://swagger.io/docs/specification/data-models/data-types/You can utilize comments and tags to construct special fields of JSON schema.If you write any comment on a property, it would fill the IJsonSchema.description value. When you utilize Special tags of typia, they would be placed into the proper properties of IJsonSchema. Below is the list of supported type and comment tags in the @nestia/sdk.Also, such type and comment tags of DTO properties can be used to enhance validation logic of @nestia/core library. Especially, @TypedBody.${method}(), @TypedParam(), @TypedRoute() and @TypedQuery() functions can use those tags for additional validation.Let's see how those type and comment tags work with example code.\nnumber\nnumber & Type<{keyword}>\nint32\nuint32\nuint64\nint64\nfloat\ndouble\nnumber & Minimum<{number}>\nnumber & Maximum<{number}>\nnumber & ExclusiveMaximum<{number}>\nnumber & ExclusiveMinimum<{number}>\nnumber & MultipleOf<{number}>\nbigint\nbigint & Type<{keyword}>\nint64\nuint64\nbigint & Minimum<{bigint}>\nbigint & Maximum<{bigint}>\nbigint & ExclusiveMaximum<{bigint}>\nbigint & ExclusiveMinimum<{bigint}>\nbigint & MultipleOf<{bigint}>\nstring\nstring & MinLength<{number}>\nstring & MaxLength<{number}>\nstring & Pattern<{regex}>\nstring & Format<{keyword}>\nemail\nuuid\nipv4\nipv6\nurl\ndate: YYYY-MM-DD\ndate-time: Date.toISOString()\nexport interface SpecialTag {\r\n  /**\r\n   * Deprecated tags are just used for marking.\r\n   *\r\n   * @title Unsigned integer\r\n   * @deprecated\r\n   */\r\n  type: number & tags.Type<\"uint32\">;\r\n\r\n  /**\r\n   * Internal tagged property never be shown in JSON schema.\r\n   *\r\n   * It even doesn't be shown in other `typia` functions like `assert<T>()`.\r\n   *\r\n   * @internal\r\n   */\r\n  internal: number[];\r\n\r\n  /**\r\n   * Hidden tagged property never be shown in JSON schema.\r\n   *\r\n   * However, it would be shown in other `typia` functions like `stringify<T>()`.\r\n   *\r\n   * @hidden\r\n   */\r\n  hidden: boolean;\r\n\r\n  /**\r\n   * You can limit the range of number.\r\n   *\r\n   * Also, you can configure `default` property by comment tag.\r\n   *\r\n   * @default 30\r\n   */\r\n  number?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\r\n\r\n  /**\r\n   * You can limit the length of string.\r\n   */\r\n  string: string & tags.MinLength<3>;\r\n\r\n  /**\r\n   * You can limit the pattern of string.\r\n   */\r\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\r\n\r\n  /**\r\n   * You can limit the format of string.\r\n   */\r\n  format: null | (string & tags.Format<\"date-time\">);\r\n\r\n  /**\r\n   * You also can perform union type in type tags.\r\n   */\r\n  ip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\r\n\r\n  /**\r\n   * In the Array case, only type tags can limit elements' type.\r\n   */\r\n  array: Array<string & tags.Format<\"uuid\">> &\r\n    tags.MinItems<3> &\r\n    tags.MaxItems<100>;\r\n}\n{\r\n  \"SpecialTag\": {\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n      \"type\": {\r\n        \"deprecated\": true,\r\n        \"title\": \"Unsigned integer\",\r\n        \"description\": \"Deprecated tags are just used for marking.\",\r\n        \"type\": \"integer\"\r\n      },\r\n      \"number\": {\r\n        \"description\": \"You can limit the range of number.\\n\\nAlso, you can configure `default` property by comment tag.\",\r\n        \"type\": \"number\",\r\n        \"minimum\": 19,\r\n        \"exclusiveMinimum\": true,\r\n        \"maximum\": 100,\r\n        \"default\": 30\r\n      },\r\n      \"string\": {\r\n        \"description\": \"You can limit the length of string.\",\r\n        \"type\": \"string\",\r\n        \"minLength\": 3\r\n      },\r\n      \"pattern\": {\r\n        \"description\": \"You can limit the pattern of string.\",\r\n        \"type\": \"string\",\r\n        \"pattern\": \"^[a-z]+$\"\r\n      },\r\n      \"format\": {\r\n        \"oneOf\": [\r\n          {\r\n            \"type\": \"string\",\r\n            \"format\": \"date-time\",\r\n          },\r\n          {\r\n            \"type\": \"null\",\r\n          }\r\n        ],\r\n        \"description\": \"You can limit the format of string.\",\r\n      },\r\n      \"ip\": {\r\n        \"oneOf\": [\r\n          {\r\n            \"description\": \"You also can perform union type in type tags.\",\r\n            \"type\": \"string\",\r\n            \"format\": \"ipv4\"\r\n          },\r\n          {\r\n            \"description\": \"You also can perform union type in type tags.\",\r\n            \"type\": \"string\",\r\n            \"format\": \"ipv6\"\r\n          }\r\n        ],\r\n        \"description\": \"You also can perform union type in type tags.\"\r\n      },\r\n      \"array\": {\r\n        \"description\": \"In the Array case, only type tags can limit elements' type.\",\r\n        \"type\": \"array\",\r\n        \"items\": {\r\n          \"description\": \"In the Array case, only type tags can limit elements' type.\",\r\n          \"type\": \"string\",\r\n          \"format\": \"uuid\"\r\n        },\r\n        \"maxItems\": 100,\r\n        \"minItems\": 3\r\n      }\r\n    },\r\n    \"required\": [\r\n      \"type\",\r\n      \"string\",\r\n      \"pattern\",\r\n      \"format\",\r\n      \"ip\",\r\n      \"array\"\r\n    ]\r\n  }\r\n}\n/**\r\n * Security schema of Swagger Documents.\r\n *\r\n * `ISecurityScheme` is a data structure representing content of\r\n * `securitySchemes` in `swagger.json` file. It is composed with 5 types of security\r\n * schemes as an union type like below.\r\n *\r\n * @reference https://swagger.io/specification/#security-scheme-object\r\n * @author Jeongho Nam - https://github.com/samchon\r\n */\r\nexport type ISecurityScheme =\r\n  | ISecurityScheme.IHttpBasic\r\n  | ISecurityScheme.IHttpBearer\r\n  | ISecurityScheme.IApiKey\r\n  | ISecurityScheme.IOpenId\r\n  | ISecurityScheme.IOAuth2;\r\nexport namespace ISecurityScheme {\r\n  export interface IHttpBasic {\r\n    type: \"http\";\r\n    scheme: \"basic\";\r\n  }\r\n  export interface IHttpBearer {\r\n    type: \"http\";\r\n    scheme: \"bearer\";\r\n    bearerFormat?: string;\r\n  }\r\n  export interface IApiKey {\r\n    type: \"apiKey\";\r\n\r\n    /**\r\n     * @default header\r\n     */\r\n    in?: \"header\" | \"query\" | \"cookie\";\r\n\r\n    /**\r\n     * @default Authorization\r\n     */\r\n    name?: string;\r\n  }\r\n\r\n  export interface IOpenId {\r\n    type: \"openIdConnect\";\r\n    openIdConnectUrl: string;\r\n  }\r\n\r\n  export interface IOAuth2 {\r\n    type: \"oauth2\";\r\n    flows: IOAuth2.IFlowSet;\r\n    description?: string;\r\n  }\r\n  export namespace IOAuth2 {\r\n    export interface IFlowSet {\r\n      authorizationCode?: IFlow;\r\n      implicit?: Omit<IFlow, \"tokenUrl\">;\r\n      password?: Omit<IFlow, \"authorizationUrl\">;\r\n      clientCredentials?: Omit<IFlow, \"authorizationUrl\">;\r\n    }\r\n    export interface IFlow {\r\n      authorizationUrl: string;\r\n      tokenUrl: string;\r\n      refreshUrl: string;\r\n      scopes?: Record<string, string>;\r\n    }\r\n  }\r\n}","customization#Customization":"Typia > JSON schema > CustomizationIf what you want is not just filling special properties of JSON schema spec, but to adding custom properties into the JSON schema definition, you can accomlish it with typia feature. Define a type based on typia.tags.TagBase or typia.tags.JsonSchemaPlugin, and specify the schema property type as you want.For reference, the custom property must be started with x- prefix. It's a rule of JSON schema.\nimport typia, { tags } from \"typia\";\r\n \r\ntype Monetary<Value extends string> = tags.TagBase<{\r\n  target: \"number\";\r\n  kind: \"monetary\";\r\n  value: Value;\r\n  schema: {\r\n    \"x-monetary\": Value;\r\n  };\r\n}>;\r\n\r\ntype Placeholder<Value extends string> = tags.JsonSchemaPlugin<{\r\n  \"x-placeholder\": Value;\r\n}>;\r\n\r\ninterface IAccount {\r\n  code: string & Placeholder<\"Write you account code please\">;\r\n  balance: number & Monetary<\"dollar\">;\r\n};\r\ntypia.json.application<[IAccount]>();\n({\r\n  version: \"3.1\",\r\n  components: {\r\n    schemas: {\r\n      IAccount: {\r\n        type: \"object\",\r\n        properties: {\r\n          code: {\r\n            type: \"string\",\r\n            \"x-placeholder\": \"Write you account code please\",\r\n          },\r\n          balance: {\r\n            type: \"number\",\r\n            \"x-monetary\": \"dollar\",\r\n          },\r\n        },\r\n        required: [\"code\", \"balance\"],\r\n      },\r\n    },\r\n  },\r\n  schemas: [\r\n    {\r\n      $ref: \"#/components/schemas/IAccount\",\r\n    },\r\n  ],\r\n});\nOtherwise you wanna customize the swagger data, utilize the @SwaggerCustomizer() decorator.As you can see from the below example code, callback function defined in the @SwaggerCustomizer() decorator is changing the swagger data, because it is called when the npx nestia swagger command being executed. Furthermore, it is possible to add plugin property starting with x- characters.Also, this @SwaggerCustomizer() decorator is especially useful when defining an authentication decorator. Developing the authentication logic in the decorator function, apply the @SwaggerCustomizer() with OpenApi.IOperation.security property. Then whenever the decorator function is called, the security scheme would be added into the swagger data.\nexport function SwaggerCustomizer(\r\n  closure: (props: SwaggerCustomizer.IProps) => unknown,\r\n): MethodDecorator;\r\nexport namespace SwaggerCustomizer {\r\n  export interface IProps {\r\n    swagger: OpenApi.IDocument;\r\n    method: string;\r\n    path: string;\r\n    route: OpenApi.IOperation;\r\n    at(func: Function): ISwaggerEndpoint | undefined;\r\n    get(accessor: IAccessor): OpenApi.IOperation | undefined;\r\n  }\r\n  export interface IAccessor {\r\n    path: string;\r\n    method: string;\r\n  }\r\n  export interface ISwaggerEndpoint extends IAccessor {\r\n    route: OpenApi.IOperation;\r\n  }\r\n}\nimport { SwaggerCustomizer, TypedParam, TypedRoute } from \"@nestia/core\";\r\nimport { Controller } from \"@nestjs/common\";\r\nimport { tags } from \"typia\";\r\n\r\n@Controller(\"custom\")\r\nexport class CustomController {\r\n  @SwaggerCustomizer((props: SwaggerCustomizer.IProps) => {\r\n    props.swagger.openapi = \"3.1.99\";\r\n    props.route.description = \"This is a custom description\";\r\n    (props.route as any)[\"x-special-symbol\"] = \"Something Special\";\r\n\r\n    const neighbor = props.at(CustomController.prototype.normal);\r\n    if (neighbor) {\r\n      neighbor.description = \"That is the normal description\";\r\n      (neighbor.route as any)[\"x-special-symbol\"] = \"Something Normal\";\r\n    }\r\n  })\r\n  @TypedRoute.Get(\":key/customize\")\r\n  public customize(@TypedParam(\"key\") key: number): string {\r\n    return key.toString();\r\n  }\r\n\r\n  @TypedRoute.Get(\":id/normal\")\r\n  public normal(@TypedParam(\"id\") id: string & tags.Format<\"uuid\">): string {\r\n    return id.toString();\r\n  }\r\n}\nimport { ExecutionContext, createParamDecorator } from \"@nestjs/common\";\r\nimport { Singleton } from \"tstl\";\r\n\r\nimport { ShoppingSellerProvider } from \"../providers/shoppings/actors/ShoppingSellerProvider\";\r\nimport { SwaggerCustomizer } from \"@nestia/core\";\r\n\r\nexport const ShoppingSellerAuth =\r\n  (): ParameterDecorator =>\r\n  (\r\n    target: Object,\r\n    propertyKey: string | symbol | undefined,\r\n    parameterIndex: number\r\n  ): void => {\r\n    SwaggerCustomizer((props) => {\r\n      props.route.security ??= [];\r\n      props.route.security.push({\r\n        bearer: [],\r\n      });\r\n    })(target, propertyKey as string, undefined!);\r\n    singleton.get()(target, propertyKey, parameterIndex);\r\n  };\r\n\r\nconst singleton = new Singleton(() =>\r\n  createParamDecorator(async (_0: any, ctx: ExecutionContext) => {\r\n    const request = ctx.switchToHttp().getRequest();\r\n    return ShoppingSellerProvider.authorize(request);\r\n  })()\r\n);","distribution#Distribution":"You can choose two options for swagger.json file distribution.The 1st is publishing the swagger.json file in a public repo, and showing it through @nestia/editor like below:The 2nd way is to hosting the swagger.json file in the NestJS backend server.Read below example code, and follow it on yours:\nimport { NestiaSwaggerComposer } from \"@nestia/sdk\";\r\nimport { INestApplication } from \"@nestjs/common\";\r\nimport { NestFactory } from \"@nestjs/core\";\r\nimport { SwaggerModule } from \"@nestjs/swagger\";\r\n\r\nconst main = async (): Promise<void> => {\r\n  const app: INestApplication = await NestFactory.create(ApplicationModule);\r\n  const document = await NestiaSwaggerComposer.document(app, {});\r\n  SwaggerModule.setup(\"api\", app, document as any);\r\n\r\n  await app.listen(3_000);\r\n};\r\nmain().catch(console.error);\nimport { NestFactory } from \"@nestjs/core\";\r\nimport { SwaggerModule } from \"@nestjs/swagger\";\r\nimport fs from \"fs\";\r\n\r\nconst main = async (): Promise<void> => {\r\n  const app = await NestFactory.create(ApplicationModule);\r\n  const docs = require(\"...write swagger.json path\");\r\n  docs.servers = [{ url: \"write your server URL\" }];\r\n  SwaggerModule.setup(\"swagger\", app, docs);\r\n\r\n  await app.listen(8080);\r\n}\r\nmain().catch(console.error);"}}}