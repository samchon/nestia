import { Tabs, Tab } from 'nextra-theme-docs'

## Outline
<Tabs 
  items={['Configuration', 'Build Script', 'Generated SDK Library']} 
  defaultIndex={1}>
  <Tab>
```typescript copy filename="nestia.config.ts" showLineNumbers
import { INestiaConfig } from "@nestia/sdk";
import { NestFactory } from "@nestjs/core";
// import { FastifyAdaptor } from "@nestjs/platform-fastify";

import { YourModule } from "./src/YourModule";

const NESTIA_CONFIG: INestiaConfig = {
  input: async () => {
    const app = await NestFactory.create(YourModule);
    // const app = await NestFactory.create(YourModule, new FastifyAdaptor());
    // app.setGlobalPrefix("api");
    // app.enableVersioning({
    //     type: VersioningType.URI,
    //     prefix: "v",
    // })
    return app;
  },
  output: "src/api",
  distribute: "packages/api",
};
export default NESTIA_CONFIG;
```
  </Tab>
  <Tab>
```bash filename="Terminal" showLineNumbers {}
npx nestia sdk
npx nestia sdk --config nestia.config.ts --project tsconfig.json
```
  </Tab>
  <Tab>
```typescript filename="src/api/functional/bbs/articles/index.ts" showLineNumbers
/**
 * Update an article.
 *
 * @param section Section code
 * @param id Target article ID
 * @param input Content to update
 * @returns Updated content
 *
 * @controller BbsArticlesController.update()
 * @path PUT /bbs/:section/articles/:id
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function update(
  connection: IConnection,
  section: string,
  id: string & Format<"uuid">,
  input: update.Input,
): Promise<update.Output> {
  return PlainFetcher.fetch(
    {
      ...connection,
      headers: {
        ...connection.headers,
        "Content-Type": "application/json",
      },
    },
    {
      ...update.METADATA,
      path: update.path(section, id),
    } as const,
    input,
  );
}
export namespace update {
  export type Input = Primitive<IBbsArticle.IStore>;
  export type Output = Primitive<IBbsArticle>;

  export const METADATA = {
    method: "PUT",
    path: "/bbs/articles/:section/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: null,
  } as const;

  export const path = (
    section: string,
    id: string & Format<"uuid">,
  ): string => {
    return `/bbs/articles/${encodeURIComponent(
      section ?? "null",
    )}/${encodeURIComponent(id ?? "null")}`;
  };
}
```
  </Tab>
</Tabs>

Collection of typed `fetch` functions with DTO structures.

Configure [`nestia.config.ts`](#nestiaconfigts) file and run `npx nestia sdk` command. Then, `@nestia/sdk` will analyze your NestJS backend server code, and generate SDK (Software Development Kit) library. The newly generated SDK library would be composed with `DTO` and `fetch` functions with type definitions following your NestJS server. 

With the SDK library, you can easily develop e2e test program. Also, frontend developers can utilize the SDK library to interact with your NestJS backend server, much safely and conveniently. If you can't imagine how the SDK library works, then look at the gif image of below. Left side is the NestJS backend server program, and right side is the Frontend program interacting with your server.

Isn't it look like much more convenient and safer than before when using [Swagger Documents](swagger)?

![SDK](https://user-images.githubusercontent.com/13158709/215004990-368c589d-7101-404e-b81b-fbc936382f05.gif)

> Left is NestJS server code, and right is client (frontend) code utilizing SDK




## Configuration
### `nestia.config.ts`
<Tabs items={[
  <code>nestia.config.ts</code>, 
  <code>INestiaConfig.ts</code>,
]}>
  <Tab>
```typescript copy filename="nestia.config.ts" showLineNumbers {8-17}
import { INestiaConfig } from "@nestia/sdk";
import { NestFactory } from "@nestjs/core";
// import { FastifyAdaptor } from "@nestjs/platform-fastify";

import { YourModule } from "./src/YourModule";

const NESTIA_CONFIG: INestiaConfig = {
  input: async () => {
    const app = await NestFactory.create(YourModule);
    // const app = await NestFactory.create(YourModule, new FastifyAdaptor());
    // app.setGlobalPrefix("api");
    // app.enableVersioning({
    //     type: VersioningType.URI,
    //     prefix: "v",
    // })
    return app;
  },
  output: "src/api",
  distribute: "packages/api",
};
export default NESTIA_CONFIG;
```
  </Tab>
  <Tab>
```typescript copy filename="INestiaConfig.ts" showLineNumbers {13-32}
import type { INestApplication } from "@nestjs/common";

import type { ISwagger } from "./structures/ISwagger";
import type { ISwaggerInfo } from "./structures/ISwaggerInfo";
import type { ISwaggerSecurityScheme } from "./structures/ISwaggerSecurityScheme";

/**
 * Definition for the `nestia.config.ts` file.
 *
 * @author Jeongho Nam - https://github.com/samchon
 */
export interface INestiaConfig {
  /**
   * Accessor of controller classes.
   *
   * You can specify it within two ways
   *
   *   - Asynchronous function returning `INestApplication` instance
   *   - Specify the path or directory of controller class files
   */
  input:
    | (() => Promise<INestApplication>)
    | INestiaConfig.IInput
    | string[]
    | string;

  /**
   * Output directory that SDK would be placed in.
   *
   * If not configured, you can't build the SDK library.
   */
  output?: string;

  /**
   * Building `swagger.json` is also possible.
   *
   * If not specified, you can't build the `swagger.json`.
   */
  swagger?: INestiaConfig.ISwaggerConfig;

  /**
   * Target directory that SDK distribution files would be placed in.
   *
   * If you configure this property and runs `npx nestia sdk` command,
   * distribution environments for the SDK library would be generated.
   *
   * After the SDK library generation, move to the `distribute` directory,
   * and runs `npm publish` command, then you can share SDK library with
   * other client (frontend) developers.
   *
   * Recommend to use `"packages/api"` value.
   */
  distribute?: string;

  /**
   * Allow simulation mode.
   *
   * If you configure this property to be `true`, the SDK library would be contain
   * simulation mode. In the simulation mode, the SDK library would not communicate
   * with the real backend server, but just returns random mock-up data
   * with requestion data validation.
   *
   * For reference, random mock-up data would be generated by `typia.random<T>()`
   * function.
   *
   * @default false
   */
  simulate?: boolean;

  /**
   * Target directory that e2e test functions would be placed in.
   *
   * If you configure this property and runs `npx nestia e2e` command,
   * `@nestia/sdk` will analyze your NestJS backend server code, and
   * generates e2e test functions for every API endpoints.
   *
   * If not configured, you can't run `npx nestia e2e` command.
   */
  e2e?: string;

  /**
   * Whether to use propagation mode or not.
   *
   * If being configured, interaction functions of the SDK library would
   * perform the propagation mode. The propagation mode means that never
   * throwing exception even when status code is not 200 (or 201), but just
   * returning the {@link IPropagation} typed instance, which can specify its body
   * type through discriminated union determined by status code.
   *
   * @default false
   */
  propagate?: boolean;

  /**
   * Whether to clone DTO structures or not.
   *
   * If being configured, all of DTOs used in the backend server would be cloned
   * into the `structures` directory, and the SDK library would be refer to the
   * cloned DTOs instead of the original.
   *
   * @default false
   */
  clone?: boolean;

  /**
   * Whether to wrap DTO by primitive type.
   *
   * If you don't configure this property as `false`, all of DTOs in the
   * SDK library would be automatically wrapped by {@link Primitive} type.
   *
   * For refenrece, if a DTO type be capsuled by the {@link Primitive} type,
   * all of methods in the DTO type would be automatically erased. Also, if
   * the DTO has a `toJSON()` method, the DTO type would be automatically
   * converted to return type of the `toJSON()` method.
   *
   * @default true
   */
  primitive?: boolean;

  /**
   * Whether to assert parameter types or not.
   *
   * If you configure this property to be `true`, all of the function
   * parameters of SDK library would be checked through
   * [`typia.assert<T>()` function](https://typia.io/docs/validators/assert/).
   *
   * This option would make your SDK library compilation time a little bit slower,
   * but would enahcne the type safety even in the runtime level.
   *
   * @default false
   */
  assert?: boolean;

  /**
   * Whether to optimize JSON string conversion 10x faster or not.
   *
   * If you configure this property to be `true`, the SDK library would utilize the
   * [`typia.assertStringify<T>() function`](https://github.com/samchon/typia#enhanced-json)
   * to boost up JSON serialization speed and ensure type safety.
   *
   * This option would make your SDK library compilation time a little bit slower,
   * but would enhance JSON serialization speed 10x faster. Also, it can ensure type
   * safety even in the rumtime level.
   *
   * @default false
   */
  json?: boolean;
}
export namespace INestiaConfig {
  /**
   * List of files or directories to include or exclude to specifying the NestJS
   * controllers.
   */
  export interface IInput {
    /**
     * List of files or directories containing the NestJS controller classes.
     */
    include: string[];

    /**
     * List of files or directories to be excluded.
     */
    exclude?: string[];
  }

  /**
   * Building `swagger.json` is also possible.
   */
  export interface ISwaggerConfig {
    /**
     * Output path of the `swagger.json`.
     *
     * If you've configured only directory, the file name would be the `swagger.json`.
     * Otherwise you've configured the full path with file name and extension, the
     * `swagger.json` file would be renamed to it.
     */
    output: string;

    /**
     * API information.
     *
     * If omitted, `package.json` content would be used instead.
     */
    info?: Partial<ISwaggerInfo>;

    /**
     * List of server addresses.
     */
    servers?: ISwagger.IServer[];

    /**
     * Security schemes.
     *
     * When generating `swagger.json` file through `nestia`, if your controllers or
     * theirs methods have a security key which is not enrolled in here property,
     * it would be an error.
     */
    security?: Record<string, ISwaggerSecurityScheme>;

    /**
     * Decompose query DTO.
     *
     * If you configure this property to be `true`, the query DTO would be decomposed
     * into individual query parameters per each property.
     *
     * @default false
     */
    decompose?: boolean;

    operationId?(props: {
      class: string;
      function: string;
      method: "HEAD" | "GET" | "POST" | "PUT" | "PATCH" | "DELETE";
      path: string;
    }): string;
  }
}
```
  </Tab>
</Tabs>

Make `nestia.config.ts` file and run `npx nestia sdk` command.

At first, create `nestia.config.ts` file through `npx nestia init` command. It would be placed on the top level directory of your NestJS backend project. For reference, `tsconfig.json` file also must be placed in the top level directory, too. After creation, configure the `nestia.config.ts` file referencing above example code and type definition.

At least, you've to configure those two properties:

  - `input`: Accessor of controller classes
  - `output`: Path of output directory for SDK library

When you've completed above configuration, just run `npx nestia sdk` command. Then, SDK library would be newly generated, and placed into the `$config.output` directory following your `nestia.config.ts` configuration.

### Input Pattern
`nestia.config.ts` supports alternative options instead of using the `Module` instance. 

If your backend application server does not have special configuration like `setGlobalPrefix`, `enableVersioning` and `RouterModule`, it is okay to specifying the target controller classes just by writing their file path like below.

<Tabs 
  items={[
    'Module (express)',
    'Module (fastify)',
    'Directory', 
    'Pattern', 
    'Exclude',
  ]}
  defaultIndex={2}>
  <Tab>
```typescript copy filename="nestia.config.ts" showLineNumbers {7-15}
import { INestiaConfig } from "@nestia/sdk";
import { NestFactory } from "@nestjs/core";

import { YourModule } from "./src/YourModule";

const NESTIA_CONFIG: INestiaConfig = {
  input: async () => {
    const app = await NestFactory.create(YourModule);
    // app.setGlobalPrefix("api");
    // app.enableVersioning({
    //     type: VersioningType.URI,
    //     prefix: "v",
    // })
    return app;
  },
  output: "src/api",
  distribute: "packages/api",
};
export default NESTIA_CONFIG;
```
  </Tab>
  <Tab>
```typescript copy filename="nestia.config.ts" showLineNumbers {8-16}
import { INestiaConfig } from "@nestia/sdk";
import { NestFactory } from "@nestjs/core";
import { FastifyAdaptor } from "@nestjs/platform-fastify";

import { YourModule } from "./src/YourModule";

const NESTIA_CONFIG: INestiaConfig = {
  input: async () => {
    const app = await NestFactory.create(YourModule, new FastifyAdaptor());
    // app.setGlobalPrefix("api");
    // app.enableVersioning({
    //     type: VersioningType.URI,
    //     prefix: "v",
    // })
    return app;
  },
  output: "src/api",
  distribute: "packages/api",
};
export default NESTIA_CONFIG;
```
  </Tab>
  <Tab>
```typescript copy filename="nestia.config.ts" showLineNumbers {4-8}
import { INestiaConfig } from "@nestia/sdk";

const NESTIA_CONFIG: INestiaConfig = {
  input: ["src/controllers", "src/fake/controllers", "src/test/controllers"],
  output: "src/api",
  distribute: "packages/api",
};
export default NESTIA_CONFIG;
```
  </Tab>
  <Tab>
```typescript copy filename="nestia.config.ts" showLineNumbers {4}
import { INestiaConfig } from "@nestia/sdk";

const NESTIA_CONFIG: INestiaConfig = {
  input: "src/**/*.controller.ts",
  output: "src/api",
  distribute: "packages/api",
};
export default NESTIA_CONFIG;
```
  </Tab>
  <Tab>
```typescript copy filename="nestia.config.ts" showLineNumbers {4-7}
import { INestiaConfig } from "@nestia/sdk";

const NESTIA_CONFIG: INestiaConfig = {
  input: {
    include: ["src/controllers"],
    exclude: ["src/**/*.fake.ts"],
  },
  output: "src/api",
  distribute: "packages/api",
};
export default NESTIA_CONFIG;
```
  </Tab>
</Tabs>

### Clone Mode
<Tabs items={[
  <code>nestia.config.ts</code>,
  "Source Controller",
  "Cloned DTO types"
]}>
  <Tab>
```typescript copy filename="nestia.config.ts" showLineNumbers {19}
import { INestiaConfig } from "@nestia/sdk";
import { NestFactory } from "@nestjs/core";
// import { FastifyAdaptor } from "@nestjs/platform-fastify";
 
import { YourModule } from "./src/YourModule";
 
const NESTIA_CONFIG: INestiaConfig = {
  input: async () => {
    const app = await NestFactory.create(YourModule);
    // const app = await NestFactory.create(YourModule, new FastifyAdaptor());
    // app.setGlobalPrefix("api");
    // app.enableVersioning({
    //     type: VersioningType.URI,
    //     prefix: "v",
    // })
    return app;
  },
  output: "src/api",
  clone: true,
  distribute: "packages/api",
};
export default NESTIA_CONFIG;
```
  </Tab>
  <Tab>
```typescript showLineNumbers
import core from "@nestia/core";
import { Controller } from "@nestjs/common";
import typia, { tags } from "typia";

@Controller("bbs/articles/:section")
export class TypedBodyControlleer {
  @core.TypedRoute.Get()
  public async index(
    @core.TypedParam("section") section: string,
    @core.TypedQuery() query: IPage.IRequest,
  ): Promise<IPage<IBbsArticle.ISummary>> {
    const limit: number = query.limit ?? 100;
    const current: number = query.page ?? 1;
    const records: number = limit * (current + 3) + 5;

    return {
      pagination: {
        current,
        limit,
        records,
        pages: Math.ceil(records / limit),
      },
      data: new Array(limit).fill("").map(() => ({
        ...typia.random<IBbsArticle.ISummary>(),
        section,
      })),
    };
  }
}
interface IPage<T> {
  data: T[];
  pagination: IPage.IPagination;
}
namespace IPage {
  export interface IRequest {
    page?: null | (number & tags.Type<"uint32">);
    limit?: null | (number & tags.Type<"uint32">);
  }
  export interface IPagination {
    current: number & tags.Type<"uint32">;
    limit: number & tags.Type<"uint32">;
    records: number & tags.Type<"uint32">;
    pages: number & tags.Type<"uint32">;
  }
}

namespace IBbsArticle {
  export interface ISummary {
    id: string & tags.Format<"uuid">;
    section: string;
    writer: string;
    title: string & tags.MinLength<3> & tags.MaxLength<50>;
    created_at: string & tags.Format<"date-time">;
    /**
     * @format date-time
     */
    updated_at: string;
  }
}
```
  </Tab>
  <Tab>
```typescript showLineNumbers
export namespace IPageIBbsArticle {
  export type ISummary = {
    data: IBbsArticle.ISummary[];
    pagination: IPage.IPagination;
  };
}
export namespace IPage {
  export type IRequest = {
    page?: null | undefined | (number & Type<"uint32">);
    limit?: null | undefined | (number & Type<"uint32">);
  };
  export type IPagination = {
    current: number & Type<"uint32">;
    limit: number & Type<"uint32">;
    records: number & Type<"uint32">;
    pages: number & Type<"uint32">;
  };
}

export namespace IBbsArticle {
  export type ISummary = {
    id: string & Format<"uuid">;
    section: string;
    writer: string;
    title: string & MinLength<3> & MaxLength<50>;
    created_at: string & Format<"date-time">;
    updated_at: string & Format<"date-time">;
  };
}
```
  </Tab>
</Tabs>

If you configure `clone` property to be `true` in the `nestia.config.ts` file, all of DTO structures used in the backend server would be cloned into the `structures` directory, and the SDK library would be refer to the cloned DTO structures instead of the original.

This `clone` mode is useful when you'd not separated DTO structures from the ORM models. When you're using `TypeORM` or `Prisma`, and returning the ORM generated instance directly in the controller without independent DTO structure definition, your SDK library requires the `TypeORM` or `Prisma` dependency install. By the dependency, client (frontend) developers may install the ORM library that they never need. 

In that case, it would better to remove the dependency by using this `clone` mode.




### Propagation Mode
<Tabs items={[
  <code>nestia.config.ts</code>, 
  <code>IPropagation.ts</code>,
]}>
  <Tab>
```typescript copy filename="nestia.config.ts" showLineNumbers {19}
import { INestiaConfig } from "@nestia/sdk";
import { NestFactory } from "@nestjs/core";
// import { FastifyAdaptor } from "@nestjs/platform-fastify";

import { YourModule } from "./src/YourModule";

const config: INestiaConfig = {
  input: async () => {
    const app = await NestFactory.create(YourModule);
    // const app = await NestFactory.create(YourModule, new FastifyAdaptor());
    // app.setGlobalPrefix("api");
    // app.enableVersioning({
    //     type: VersioningType.URI,
    //     prefix: "v",
    // })
    return app;
  },
  output: "src/api",
  propagate: true,
  distribute: "packages/api",
};
export default config;
```
  </Tab>
  <Tab>
```typescript filename="IPropagation.ts" showLineNumbers
import { Primitive } from "./Primitive";

/**
 * Propagation type.
 *
 * `IPropagation` is a type gathering all possible status codes and their body
 * data types as a discriminated union type. You can specify the status code and
 * its body data type just by using conditional statement like below.
 *
 * ```typescript
 * type Output = IPropagation<{
 *    200: ISeller.IAuthorized;
 *    400: TypeGuardError.IProps;
 * >};
 *
 * const output: Output = await sdk.sellers.authenticate.join(input);
 * if (output.success) {
 *     // automatically casted to "ISeller.IAuthorized" type
 *     const authorized: ISeller.IAuthorized = output.data;
 * } else if (output.status === 400) {
 *     // automatically casted to "TypeGuardError.IProps" type
 *     const error: TypeGuardError.IProps = output.data;
 * } else {
 *     // unknown type when out of pre-defined status codes
 *     const result: unknown = output.data;
 * }
 * ```
 *
 * For reference, this `IPropagation` type is utilized by SDK library generated by
 * `@nestia/sdk`, when you've configured {@link INestiaConfig.propagate} to be `true`.
 * In that case, SDK functions generated by `@nestia/sdk` no more returns response DTO
 * typed data directly, but returns this `IPropagation` typed object instead.
 *
 * @template StatusMap Map of status code and its body data type.
 * @template Success Default success status code.
 * @author Jeongho Nam - https://github.com/samchon
 */
export type IPropagation<
  StatusMap extends {
    [P in IPropagation.Status]?: any;
  },
  Success extends number = 200 | 201,
> =
  | {
      [P in keyof StatusMap]: IPropagation.IBranch<
        P extends Success ? true : false,
        P,
        StatusMap[P]
      >;
    }[keyof StatusMap]
  | IPropagation.IBranch<false, unknown, unknown>;
export namespace IPropagation {
  /**
   * Type of configurable status codes.
   *
   * The special characters like `2XX`, `3XX`, `4XX`, `5XX` are meaning the range
   * of status codes. If `5XX` is specified, it means the status code is in the
   * range of `500` to `599`.
   */
  export type Status = number | "2XX" | "3XX" | "4XX" | "5XX";

  /**
   * Branch type of propagation.
   *
   * `IPropagation.IBranch` is a branch type composing `IPropagation` type,
   * which is gathering all possible status codes and their body data types
   * as a union type.
   */
  export interface IBranch<Success extends boolean, StatusValue, BodyData> {
    success: Success;
    status: StatusValue extends "2XX" | "3XX" | "4XX" | "5XX"
      ? StatusRange<StatusValue>
      : StatusValue extends number
      ? StatusValue
      : never;
    data: Primitive<BodyData>;
    headers: Record<string, string | string[]>;
  }

  /**
   * Range of status codes by the first digit.
   */
  export type StatusRange<T extends "2XX" | "3XX" | "4XX" | "5XX"> = T extends 0
    ? IntRange<200, 299>
    : T extends 3
    ? IntRange<300, 399>
    : T extends 4
    ? IntRange<400, 499>
    : IntRange<500, 599>;

  type IntRange<F extends number, T extends number> = Exclude<
    Enumerate<T>,
    Enumerate<F>
  >;

  type Enumerate<
    N extends number,
    Acc extends number[] = [],
  > = Acc["length"] extends N
    ? Acc[number]
    : Enumerate<N, [...Acc, Acc["length"]]>;
}
```
  </Tab>
</Tabs>

Returns `IPropagation` typed instance instead of throwing exception.

When you configure propagate property of `nestia.config.ts` file, all of SDK functions generated by `@nestia/sdk` will perform propagation mode. The propagation mode means that never throwing exception (`HttpError`) even when response status code is not 200 (or 201), but just returning the `IPropagation` typed object, which can specify its body data type through discriminated union determined by status code.

Looking at below code tabs one by one, then you may understand exactly, what the propagation mode is. As you can see from below example code, [`@TypedException()`](../core/TypedException) decorator function can be utilized to define the failure type with specific status code. Also, if returned status code is out of pre-defined, the `IPropagation.data` type would be automatically casted to `unknown` type.

<Tabs items={[
  <code>BbsArticlesController.ts</code>,
  "Propagation Mode SDK",
  "Utilization Case",
]}>
  <Tab>
```typescript filename="src/controllers/BbsArticlesController.ts" showLineNumbers
import core from "@nestia/core";
import { Controller } from "@nestjs/common";
import typia, { tags } from "typia";

import { IBbsArticle } from "@api/lib/structures/IBbsArticle";

@Controller("bbs/articles/:section")
export class BbsArticlesController {
  /**
   * Update an article.
   *
   * @param section Section code
   * @param id Target article ID
   * @param input Content to update
   * @returns Updated content
   */
  @core.TypedException<TypeGuardError.IProps>(400)
  @core.TypedRoute.Put(":id")
  public async update(
    @core.TypedParam("section") section: string,
    @core.TypedParam("id") id: string & tags.Format<"uuid">,
    @core.TypedBody() input: IBbsArticle.IStore,
  ): Promise<IBbsArticle> {
    return {
      ...typia.random<IBbsArticle>(),
      id,
      section,
      ...input,
    };
  }
}
```
  </Tab>
  <Tab>
```typescript filename="src/api/functional/bbs/articles/index.ts" showLineNumbers {19, 36-42}
/**
 * Update an article.
 *
 * @param section Section code
 * @param id Target article ID
 * @param input Content to update
 * @returns Updated content
 *
 * @controller BbsArticlesController.update()
 * @path PUT /bbs/:section/articles/:id
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function update(
  connection: IConnection,
  section: string,
  id: string & Format<"uuid">,
  input: update.Input,
): Promise<update.Output> {
  return PlainFetcher.propagate(
    {
      ...connection,
      headers: {
        ...connection.headers,
        "Content-Type": "application/json",
      },
    },
    {
      ...update.METADATA,
      path: update.path(section, id),
    } as const,
    input,
  );
}
export namespace update {
  export type Input = Primitive<IBbsArticle.IStore>;
  export type Output = IPropagation<
    {
      200: IBbsArticle;
      400: TypeGuardError.IProps;
    },
    200
  >;

  export const METADATA = {
    method: "PUT",
    path: "/bbs/articles/:section/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: null,
  } as const;

  export const path = (
    section: string,
    id: string & Format<"uuid">,
  ): string => {
    return `/bbs/articles/${encodeURIComponent(
      section ?? "null",
    )}/${encodeURIComponent(id ?? "null")}`;
  };
}
```
  </Tab>
  <Tab>
```typescript showLineNumbers
const output = await api.functional.bbs.articles.update(section, id, input);
if (output.success) {
  // automatically casted to "IBbsArticle" when status 200 (success)
  const article: IBbsArticle = output.data;
} else if (output.status === 400) {
  // casted to "TypeGuardError.IProps" when status 400
  const error: TypeGuardError.IProps = output.data;
} else {
  // casted to "unknown" when out of pre-defined status codes
  const result: unknown = output.data;
}
```
  </Tab>
</Tabs>




## Comment Tags
### Hiding
If you want to hide some API endpoints from the SDK library, write a comment tag to the controller method.

  - `@deprepcated`: warning from IDE
  - `@internal`: hide from `d.ts` files
  - `@ignore`: actually ignore, so that not even generated

At first, `@deprecated` does not hide target API from the SDK library, but just mark as deprecated. In that case, IDE will warn to the SDK users. In such reason, `@deprecated` comment tag is useful for legacy API endpoints that would be removed in the future.

The second `@internal` tag also does not hide from the SDK library, but it would be disappeared from `d.ts` files, so that client developers can't identify the API. Therefore, `@internal` tag is useful for some API endpoints that would be used only in the backend server for testing or debugging purpose.

The last `@ignore` tag is the most powerful one. If you write `@ignore` tag to the controller method, the SDK library would never generate the API endpoint at all. In that case, client developers can't use the API endpoint even if they know the API endpoint path and method. It is useful for some endpoints that are not supported in the SDK library.

<Tabs items={['NestJS Server Code', 'SDK Library Code']}>
  <Tab>
```typescript copy filename="BbsArticlesController.ts"
import { Controller } from "@nestjs/common";

import { IBbsArticle } from "@api/lib/structures/IBbsArticle";

@Controller("bbs/articles")
export class BbsArticlesController {
  /**
   * Store an article.
   *
   * @param input Content to store
   * @returns Newly archived article
   * @deprecated
   */
  public async create(
    @TypedBody() input: IBbsArticle.IStore,
  ): Promise<IBbsArticle> {
      ...
  }

  /**
   * @internal
   */
  public async update(
    @TypedParam("id") id: string & tags.Format<"uuid">,
    @TypedBody() input: IBbsArticle.IUpdate,
  ): Promise<void> {
      ...
  }

  /**
   * @ignore
   */
  public async erase(
    @TypedParam("id") id: string & tags.Format<"uuid">,
  ): Promise<void> {
      ...
  }
}
```
  </Tab>
  <Tab>
```typescript filename="src/api/functional/bbs/articles/index.ts"
/**
 * @packageDocumentation
 * @module api.functional.bbs.articles
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
//================================================================
import type { IConnection, Primitive } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import type { Format } from "typia/lib/tags/Format";

import type { IBbsArticle } from "../../../structures/IBbsArticle";

/**
 * Store an article.
 *
 * @param input Content to store
 * @returns Newly archived article
 * @deprecated
 *
 * @controller BbsArticlesController.store
 * @path POST /bbs/articles
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function store(
  connection: IConnection,
  input: store.Input,
): Promise<store.Output> {
  return PlainFetcher.fetch(
    {
      ...connection,
      headers: {
        ...connection.headers,
        "Content-Type": "application/json",
      },
    },
    {
      ...store.METADATA,
      path: store.path(),
    } as const,
    input,
  );
}
export namespace store {
  export type Input = Primitive<IBbsArticle.IStore>;
  export type Output = Primitive<IBbsArticle>;

  export const METADATA = {
    method: "POST",
    path: "/bbs/articles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: null,
  } as const;

  export const path = (): string => {
    return `/bbs/articles`;
  };
}

/**
 *
 * @internal
 *
 * @controller BbsArticlesController.update
 * @path PUT /bbs/articles/:id
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function update(
  connection: IConnection,
  id: string & Format<"uuid">,
  input: update.Input,
): Promise<void> {
  return PlainFetcher.fetch(
    {
      ...connection,
      headers: {
        ...connection.headers,
        "Content-Type": "application/json",
      },
    },
    {
      ...update.METADATA,
      path: update.path(id),
    } as const,
    input,
  );
}
export namespace update {
  export type Input = Primitive<Partial<IBbsArticle.IStore>>;

  export const METADATA = {
    method: "PUT",
    path: "/bbs/articles/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: null,
  } as const;

  export const path = (id: string & Format<"uuid">): string => {
    return `/bbs/articles/${encodeURIComponent(id ?? "null")}`;
  };
}
```
  </Tab>
</Tabs>

### Headers
Also, SDK library of `@nestia/sdk` supports special comment tags configuring client headers.

  - `@setHeader`
  - `@assignHeaders`

At first, `@setHeader {accessor}` configures only one header property. It reads special value of response body data with the `accessor`, and configures the special value to client header with last accessor key. In the below example case, key of `authorization.token` would be `token`, and key of `authorization.timeout` would be `timeout`.

The other one `@assignHeaders` overwrites every property values to the client headers, with special instance of response body data with `accessor`. In the below example case, every properties in `IShoppingCustomer.IActivated["authorization"]` would be assigned to the clinet headers.

If you're confused, read example codes of below, clicking each tabs.

<Tabs items={['NestJS Server Code', 'SDK Library Code']}>
  <Tab>
```typescript copy filename="ShoppingConsumerAuthenticateController.ts" showLineNumbers {6-7, 15}
import { Controller } from "@nestjs/common";

@Controller("shoppings/consumers/authenticate")
export class ShoppingConsumerAuthenticateController {
  /**
   * @setHeader authorization.token token
   * @setHeader authorization.timeout timeout
   */
  @TypedRoute.Post("join")
  public join(
    @TypedBody() input: IShoppingConsumer.IJoin
  ): Promise<IShoppingConsumer.IActivated>;

  /**
   * @assignHeaders authorization
   */
  @TypedRoute.Post("login")
  public login(
    @TypedBody() inpu: IShoppingConsumer.ILogin
  ): Promise<IShoppingConsumer.IActivated>;
}
```
  </Tab>
  <Tab>
```typescript filename="src/api/functional/shoppings/customers/authenticate.ts" showLineNumbers {24-27, 47-49}
/**
 * @packageDocumentation
 * @module api.functional.shoppings.consumers.authenticate
 * @nestia Generated by Nestia - https://github.com/samchon/nestia 
 */
//================================================================
import type { IConnection, Primitive } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";

import type { IShoppingConsumer } from "../../../../structures/IShoppingConsumer";

export async function join(
  connection: IConnection,
  input: IShoppingConsumer.IJoin,
): Promise<IShoppingConsumer.IActivated> {
  const output: IShoppingConsumer.IActivated = await Fetcher.fetch(
    connection,
    join.ENCRYPTED,
    join.METHOD,
    join.path(),
    input,
  );

  // configure header(s)
  connection.headers ??= {};
  connection.headers.token = output.authorization.token;
  connection.headers.timeout = output.authorization.timeout;

  return output;
}
export namespace join {
    ...
}

export async function login(
  connection: IConnection,
  input: IShoppingConsumer.IJoin,
): Promise<IShoppingConsumer.IActivated> {
  const output: IShoppingConsumer.IActivated = await Fetcher.fetch(
    connection,
    login.ENCRYPTED,
    login.METHOD,
    login.path(),
    input,
  );

  // configure header(s)
  connection.headers ??= {};
  Object.assign(connection.headers, output.authorization);

  return output;
}
export namespace login {
    ...
}
```
  </Tab>
</Tabs>




## Distribution
```typescript copy filename="nestia.config.ts" showLineNumbers {19}
import { INestiaConfig } from "@nestia/sdk";
import { NestFactory } from "@nestjs/core";
// import { FastifyAdaptor } from "@nestjs/platform-fastify";

import { YourModule } from "./src/YourModule";

const NESTIA_CONFIG: INestiaConfig = {
  input: async () => {
    const app = await NestFactory.create(YourModule);
    // const app = await NestFactory.create(YourModule, new FastifyAdaptor());
    // app.setGlobalPrefix("api");
    // app.enableVersioning({
    //     type: VersioningType.URI,
    //     prefix: "v",
    // })
    return app;
  },
  output: "src/api",
  distribute: "packages/api",
};
export default NESTIA_CONFIG;
```

The best to way to distributing SDK library is just publishing as an NPM module.

Configure `distribute` property of [`nestia.config.ts`](#nestiaconfigts) file, and run `npx nestia sdk` command. After that, distribution environments would be automatically composed with SDK library generation. At last, move to the `packages/api` directory, and run `npm run deploy` command for publishing.

From now on, client developers can use the SDK library just by using `npm install` command.

```bash filename="deploy.sh" copy showLineNumbers
cd packages/api
npm run deploy
```

Of course, before publishing the NPM module, you've to customize some configurations like package name. Initial name of the distribution envirionments is `@ORGANIZATION/PROJECT-api`, but you must change the package name of yours, isn't it?

Also, if your SDK library utilize special alias `paths`, you also need to customize `tsconfig.json` file, too. Reading below example `package.json` and `tsconfig.json` files generated by `nestia`, consider which features to customize.

<Tabs items={[
  <code>package.json</code>, 
  <code>tsconfig.json</code>,
]}>
  <Tab>
```json filename="package.json" showLineNumbers {2}
{
  "name": "@ORGANIZATION/PROJECT-api",
  "version": "0.1.0",
  "description": "SDK library generated by Nestia",
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "scripts": {
    "build": "npm run build:sdk && npm run compile",
    "build:sdk": "rimraf ../../src/api/functional && cd ../.. && npx nestia sdk && cd packages/api",
    "compile": "rimraf lib && tsc",
    "deploy": "npm run build && npm publish"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/samchon/nestia"
  },
  "author": "Jeongho Nam",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/samchon/nestia/issues"
  },
  "homepage": "https://nestia.io",
  "devDependencies": {
    "rimraf": "^5.0.0",
    "typescript": "^5.4.2",
    "ts-patch": "^3.1.0"
  },
  "dependencies": {
    "@nestia/fetcher": "^2.3.4",
    "typia": "^6.0.0"
  },
  "files": [
    "lib",
    "package.json",
    "README.md"
  ]
}
```
  </Tab>
  <Tab>
```json filename="tsconfig.json" showLineNumbers
{
  "compilerOptions": {
    "target": "ES5",
    "lib": [
      "DOM",
      "ES2015"
    ],
    "module": "commonjs",
    "declaration": true,
    "sourceMap": true,
    "outDir": "./lib",
    "downlevelIteration": true,
    "newLine": "lf",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true
  },
  "include": [
    "../../src/api"
  ]
}

```
  </Tab>
</Tabs>